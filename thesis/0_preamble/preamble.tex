\usepackage{listings}
\lstdefinelanguage{Granule}{%
  mathescape=true,
  morecomment=[l]{--},
%  backgroundcolor = \color{white},
  % morestring=[s]{"}{"},
  % stringstyle=\itshape, %\color{OliveGreen!90!Black},%\color{orange!60!black},
  moredelim=[s][\itshape]{`}{`},
  % moredelim=[s][\color{coeffectColor}]{[}{]},
  showspaces=false,
  xleftmargin=2.5em,
  commentstyle=\itshape\color{black!60},
  % identifierstyle=\color{violet!80!black},
  basicstyle=\ttfamily\small,%\sffamily\small,%
  flexiblecolumns=true,
  columns=[l]flexible,
  columns=fullflexible,
  keepspaces=true,
  % basewidth={0.55em,0.9em},
  literate=%
  % {[0]}{[{\textcolor{coeffectColor}{0}}]}1
  % {[1]}{[{\textcolor{coeffectColor}{1}}]}1
  % {[2]}{[{\textcolor{coeffectColor}{2}}]}1
  % {[3]}{[{\textcolor{coeffectColor}{3}}]}1
  % {[4]}{[{\textcolor{coeffectColor}{4}}]}1
  % {[5]}{[{\textcolor{coeffectColor}{5}}]}1
  % {[6]}{[{\textcolor{coeffectColor}{6}}]}1
  % {[r]}{[{\textcolor{coeffectColor}{r}}]}1
  % {[s]}{[{\textcolor{coeffectColor}{s}}]}1
  {<}{\textcolor{effectColor}{<}}1
  {>}{\textcolor{effectColor}{>}}1
  {[}{\textcolor{coeffectColor}{[}}1
  {]}{\textcolor{coeffectColor}{]}}1
  {[r' : R']}{[{\textcolor{coeffectColor}{r' : R'}}]}1
  {[([}{\textcolor{coeffectColor}{[[}}2  % I don't think this is valid, consider [([x],[y])] % but need this as a hack for OTT.
  {])]}{\textcolor{coeffectColor}{]]}}2
  {forall}{$\forall$}1
  {Inf}{$\infty$}1
  {->}{$\rightarrow$}1
  {-o}{$\multimap$}1
  {=>}{$\Rightarrow$}1
  {<-}{\textcolor{effectColor}{$\leftarrow$}}1
  {/\\}{$\sqcap$}1
  {\\/}{$\sqcup$}1
  {<=}{$\leqslant$}1
  {>=}{$\geqslant$}1
  {\\}{$\lambda$}1
  {_1}{$\mathtt{_1}$}1
  {_2}{$\mathtt{_2}$}1
  {_3}{$\mathtt{_3}$}1
  {_4}{$\mathtt{_4}$}1
  {_L}{$\mathtt{_{L}}$}1
  {_LH}{$\mathtt{_{LH}}$}1
  {_Gr}{$\mathtt{_{Gr}}$}1
  {_p}{$\mathtt{_{p}}$}1
  {_q}{$\mathtt{_{q}}$}1
  {-o}{$\multimap$}1
  {\\times}{$\times$}1
  {--BLANK}{}1,
  % % Main keywords
  keywordstyle = \color{blue!40!black},%\color{WildStrawberry!90!Black},
  keywords = {data, type, let, in, case, of, if, then, else, where, import, Type, Semiring, Protocol},
  % % morekeywords = {∀,|,:,=,\{,\},->,←,.,\,,(,),;},
  % % % Type Constructors
  % % keywordstyle = [2]\color{red!40!black},%\color{YellowOrange!80!Maroon},
  % % keywords = [2]{Int, Bool, Vec, Type, Coeffect, Effect, Char, String, Maybe, List, N, Handle, Nat, Level},
  % % % morekeywords = [2]{()},
  % % % Data Constructors
  % % keywordstyle = [7]\color{purple!40!black},%Mahogany!70!WildStrawberry},
  % % keywords = [7]{Some, None, Nil, NilL, Cons, ConsL, ReadMode, S, Z},
  % % % Coeffects
  % keywordstyle = [3]\color{coeffectColor},
  % keywords     = [3]{Private, Public},
  % morekeywords = [3]{..,+,*,Inf},
  % % % Effects
  keywordstyle = [4]\bfseries\color{effectColor},
  keywords     = [4]{pure},%{IO,
                          %Open,Read,IOExcept,Close,Write,ReadWrite},
  numbers=left,
  numberstyle=\tiny\color{gray}
  % morekeywords = [4]{<,>},
  % % % universals
  % % keywords = [6]{a,b,t,s},
  % % keywordstyle = [6]\color{black}\textit,
}

\lstnewenvironment{granule}
{\lstset{language=Granule}}{}
%% $

\lstnewenvironment{granuleInterface}
{\lstset{language=Granule,numbers=none}}{}

% inline Granule
\newcommand{\granin}[1]{\lstinline[language=Granule]{#1}}

%%%%%% HASKELL
\definecolor{multiplicity}{rgb}{0,0.3,0.08}

\lstdefinelanguage{Haskell}{%
  mathescape=true,
%  backgroundcolor = \color{white},
  morecomment=[l]{--},
  comment=[l]{\{-},
  moredelim=[s][\itshape]{`}{`},
  showspaces=false,
  commentstyle=\itshape\color{black!60},
  basicstyle=\ttfamily\footnotesize,%\sffamily\small,%
  flexiblecolumns=true,
  columns=[l]flexible,
  columns=fullflexible,
  keepspaces=true,
  xleftmargin=2.5em,
  literate=%
   {\%r}{\textcolor{multiplicity}{\%r}}1
   {\%'Many}{\textcolor{multiplicity}{\%'Many}}1
   {\%1}{\textcolor{multiplicity}{\%1}}1,
  % % Main keywords
  keywordstyle = \color{blue!40!black},%\color{WildStrawberry!90!Black},
  keywords = {data, type, let, in, case, of, if, then, else, where,
  import, class, instance},
  % % morekeywords = {∀,|,:,=,\{,\},->,←,.,\,,(,),;},
  % % % Type Constructors
  % % keywordstyle = [2]\color{red!40!black},%\color{YellowOrange!80!Maroon},
  % % % Data Constructors
  % % keywordstyle = [7]\color{purple!40!black},%Mahogany!70!WildStrawberry},
  % % keywords = [7]{Some, None, Nil, NilL, Cons, ConsL, ReadMode, S, Z},
  numbers=left,
  numberstyle=\tiny\color{gray}
  % morekeywords = [4]{<,>},
  % % % universals
  % % keywords = [6]{a,b,t,s},
  % % keywordstyle = [6]\color{black}\textit,
}

\lstnewenvironment{haskell}
{\lstset{language=Haskell}}{}
%% $

% inline Haskell
\newcommand{\haskin}[1]{\lstinline[language=Haskell]{#1}}

%%%%%% IDRIS (but I just copied haskell and changed the name, fix later!!)

\lstdefinelanguage{Idris}{%
%  backgroundcolor = \color{white},
  mathescape=true,
  morecomment=[l]{--},
  comment=[l]{\{-},
  moredelim=[s][\itshape]{`}{`},
  showspaces=false,
  commentstyle=\itshape\color{black!60},
  basicstyle=\ttfamily\footnotesize,%\sffamily\small,%
  flexiblecolumns=true,
  columns=[l]flexible,
  columns=fullflexible,
  keepspaces=true,
  xleftmargin=2.5em,
  literate=%
   {\%r}{\textcolor{multiplicity}{\%r}}1
   {\%'Many}{\textcolor{multiplicity}{\%'Many}}1
   {\%1}{\textcolor{multiplicity}{\%1}}1,
  % % Main keywords
  keywordstyle = \color{blue!40!black},%\color{WildStrawberry!90!Black},
  keywords = {data, type, let, in, case, of, if, then, else, where,
  import, class, instance},
  % % morekeywords = {∀,|,:,=,\{,\},->,←,.,\,,(,),;},
  % % % Type Constructors
  % % keywordstyle = [2]\color{red!40!black},%\color{YellowOrange!80!Maroon},
  % % % Data Constructors
  % % keywordstyle = [7]\color{purple!40!black},%Mahogany!70!WildStrawberry},
  % % keywords = [7]{Some, None, Nil, NilL, Cons, ConsL, ReadMode, S, Z},
  numbers=left,
  numberstyle=\tiny\color{gray}
  % morekeywords = [4]{<,>},
  % % % universals
  % % keywords = [6]{a,b,t,s},
  % % keywordstyle = [6]\color{black}\textit,
}

\lstnewenvironment{idris}
{\lstset{language=Idris}}{}
%% $

% inline Idris
\newcommand{\idrin}[1]{\lstinline[language=Idris]{#1}}

\usepackage[most]{tcolorbox}

\makeatletter
\newtcblisting[auto counter]{haskellp}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  top=-0.5em,
  left=0em,
  bottom=-0.5em,
  bottomrule=0.5pt,
  boxsep=0em,
  after skip=1em,
  before skip=1em,
  listing options={language={haskell}},
  listing only,
  colback=white,
  sharp corners,
  overlay={\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Haskell};
           %\node[inner sep=2pt,xshift=+2cm,fill=white] (B) at (frame.north west) {#2};
  },
  #1,
}
\makeatother

\makeatletter
\newtcblisting[auto counter]{haskellf}[1][]{%
  top=0em,
  left=0em,
  bottom-0.5em,
  bottomrule=0.5pt,
  boxsep=0em,
  after skip=1em,
  before skip=0.5em,
  listing options={language={haskell}},
  listing only,
  colback=white,
  #1,
}
\makeatother

\makeatletter
\newtcblisting[auto counter]{granulep}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  bottomrule=0.5pt,
  top=-0.5em,
  left=-0.5em,
  bottom=-0.5em,
  boxsep=0em,
  after skip=1em,
  before skip=0.5em,
  listing options={language={granule}},
  listing only,
  colback=white,
  sharp corners,
  overlay={%\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Granule};
           \node[inner sep=2pt,xshift=-1cm,fill=white] (B) at (frame.south east) {Granule};
  },
  #1,
}
\makeatother


\makeatletter
\newtcblisting[auto counter]{granulepill}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  bottomrule=0.5pt,
  top=-0.5em,
  left=0em,
  bottom=-0.5em,
  boxsep=0em,
  after skip=1em,
  before skip=0.5em,
  listing options={language={granule}},
  listing only,
  colback=white,
  sharp corners,
  overlay={%\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Granule};
           \node[inner sep=2pt,xshift=-2cm,fill=white] (B) at
           (frame.south east) {Ill-typed Granule};
  },
  #1,
}
\makeatother


\makeatletter
\newtcblisting[auto counter]{idrisp}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  bottomrule=0.5pt,
  top=-0.5em,
  left=0em,
  bottom=0em,
  boxsep=0em,
  after skip=1em,
  before skip=1em,
  listing options={language={idris}},
  listing only,
  colback=white,
  sharp corners,
  overlay={%\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Granule};
           \node[inner sep=2pt,xshift=-2cm,fill=white] (B) at (frame.south east) {Idris 2};
  },
  #1,
}
\makeatother




% SUBTRACTIVE RULES
\newcommand*{\subLinVar}{
                             \inferrule*[right=\subLinVarName]
                             {\quad}{[[G, x : A |- A =>- x ; G]]}
  }

  \newcommand*{\subGrVar}{
      \inferrule*[right=\subGrVarName]
  {[[ exists s . r <= {s + 1} ]]}{[[G, x : [A] r |- A =>- x ; G , x : [A] s]]}
    }

  \newcommand*{\subAbs}{
      \inferrule*[right=\subAbsName]
  {[[G, x : A |- B =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G |- A -o B =>- \x. t ; D ]]}
    }
  \newcommand*{\subApp}{
  \inferrule*[right=\subAppName]
  {[[G, x2 : B |- C =>- t1 ; D1]] \qquad [[ x2 notin D1 ]] \qquad [[D1 |- A =>- t2 ; D2]]}{[[G, x1 : A -o B
      |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
    }
  \newcommand*{\subDer}{
      \inferrule*[right=\subDerName]
{[[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G, x : [A] r |- B =>- [x/y] t ; D, x : [A] s' ]]}
    }
  \newcommand*{\subBox}{
  \inferrule*[right=\subBoxName]
  {[[G |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; G - r * (G - D)]]}
    }
  \newcommand*{\subBoxAlt}{
  \inferrule*[right=R${\square'^{-}}$]
  {[[G / r |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; r * D ]]}
    }
  \newcommand*{\subUnbox}{
  \inferrule*[right=\subUnboxName]
    {[[ G, x2 : [A] r |- B =>- t ; D, x2 : [A] s ]] \\ 0 \sqsubseteq [[ s]]}{[[G, x1 : [] r A |- B =>- let [x2] = x1 in t ; D ]]}
    }
  \newcommand*{\subPairIntro}{
    \inferrule*[right=\subPairIntroName]
    {[[G |- A =>- t1 ; D1]] \\ [[ D1 |- B =>- t2 ; D2 ]]}{[[G |- Tup A B =>- pair t1 t2 ; D2]]}
    }
  \newcommand*{\subPairElim}{
    \inferrule*[right=\subPairElimName]
    {[[ G, x1 : A, x2 : B |- C =>- t2 ; D]] \\ [[ x1 notin D ]] \\ [[ x2 notin D ]]}
    {[[ G, x3 : Tup A B |- C =>- letpair x1 x2 = x3 in t2 ; D ]]}
    }
  \newcommand*{\subSumIntroL}{
    \inferrule*[right=\subSumIntroLname]
    {[[G |- A =>- t ; D]]}
    {[[G |- Sum A B =>- inl t ; D]]}
    }
  \newcommand*{\subSumIntroR}{
    \inferrule*[right=\subSumIntroRname]
    {[[G |- B =>- t ; D]]}
    {[[G |- Sum A B =>- inr t ; D]]}
    }
  \newcommand*{\subSumElim}{
    \inferrule*[right=\subSumElimName]
      {[[G, x2 : A |- C =>- t1 ; D1]] \quad\,
       [[G, x3 : B |- C =>- t2 ; D2]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
{\Gamma, x_1 : [[ Sum A B ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ | \ \Delta_1 \sqcap \Delta_2}
    }
  \newcommand*{\subUnitIntro}{
    \inferrule*[right=\subUnitIntroName]
    {\quad}
    {[[G |- Unit =>- () ; G]]}
    }
  \newcommand*{\subUnitElim}{
    \inferrule*[right=\subUnitElimName]
    {[[G |- C =>- t ; D]]}
    {[[G, x : Unit |- C =>- let () = x in t ; D]]}
    }

% ADDITIVE RULES
\newcommand*{\addLinVar}{
    \inferrule*[right=LinVar$^{+}$]
    {\quad}
    {[[G, x : A |- A =>+ x ; x : A]]}
  }

  \newcommand*{\addGrVar}{
    \inferrule*[right=GrVar$^{+}$]
    {\quad}
      {[[ G, x : [A] r |- A =>+ x ; x :[A] 1 ]] }
    }

  \newcommand*{\addAbs}{
    \inferrule*[right=\addAbsName]
    {[[G, x : A |- B =>+ t ; D, x : A]]}{[[G |- A -o B =>+ \x . t ; D]]}
    }
  \newcommand*{\addApp}{
    \inferrule*[right=\addAppName]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
    }
\newcommand*{\addPruneApp}{
\inferrule*[right=\addPruningAppName]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G - D1 |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
}
  \newcommand*{\addDer}{
\inferrule*[right=\addDerName]
{ [[ G, x : [A]s, y : A |- B =>+ t ; D, y : A ]] }
{ [[ G, x : [A]s |- B =>+ [x / y] t ; D + x : [A]1 ]] }
    }
  \newcommand*{\addBox}{
    \inferrule*[right=\addBoxName]
    {[[G |- A =>+ t ; D]]}{[[G |- [] r A =>+ [t] ; r * D ]]}
    }
  \newcommand*{\addUnbox}{
    \inferrule*[right=\addUnboxName]
    {[[ G, x2 : [A] r |- B =>+ t ; D ]] \\ \textit{if}\ [[x2 : [A] s]] \in
      [[D]]\ \textit{then}\ s \sqsubseteq r \ \textit{else}\  0 \sqsubseteq r}{[[G, x1 : [] r A |- B =>+
      let [x2] = x1 in t ; (D \ x2 ), x1 : [] r A ]]}
    }
  \newcommand*{\addPairIntro}{
    \inferrule*[right=\addPairIntroName]
    {[[G |- A =>+ t1 ; D1]] \\ [[G |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
    }
  \newcommand*{\addPrunePairIntro}{
    \inferrule*[right=\addPruningPairIntroName]
    {[[G |- A =>+ t1 ; D1]] \\ [[G - D1 |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
    }
  \newcommand*{\addPairElim}{
    \inferrule*[right=\addPairElimName]
    {[[ G, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}
    {[[ G, x3 : Tup A B |- C =>+ letpair x1 x2 = x3 in t2 ; D, x3 : Tup A B ]]}
    }
  \newcommand*{\addSumIntroL}{
    \inferrule*[right=\addSumIntroLName]
    {[[G |- A =>+ t ; D]]}
    {[[G |- Sum A B =>+ inl t ; D]]}
    }
  \newcommand*{\addSumIntroR}{
    \inferrule*[right=\addSumIntroRName]
    {[[G |- B =>+ t ; D]]}
    {[[G |- Sum A B =>+ inr t ; D]]}
    }
  \newcommand*{\addSumElim}{
    \inferrule*[right=\addSumElimName]
    {[[G, x2 : A |- C =>+ t1 ; D1, x2 : A]] \\ [[G, x3 : B |- C =>+ t2 ; D2,
      x3 : B ]]}
{\Gamma, x_1 : [[ Sum A B ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ |\ \Delta_1 \sqcup \Delta_2, [[ x1 : Sum A B ]]}
    }
  \newcommand*{\addUnitIntro}{
    \inferrule*[right=\addUnitIntroName]
    {\quad}
    {[[G |- Unit =>+ () ; .]]}
    }
  \newcommand*{\addUnitElim}{
    \inferrule*[right=\addUnitElimName]
    {[[G |- C =>+ t ; D]]}
    {[[G, x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
    }


% FOCUSED SUBTRACTIVE RULES
\newcommand*{\fSubAbsRule}{
    \inferrule*[right=\fSubAbsName,Lab=RightAsync]
    {[[G ; O, x : A |- B async =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G ; O |- {A -o B} async =>- \ x . t ; D]]}
}
\newcommand*{\fSubAbsRuleNoLabel}{
    \inferrule*[right=\fSubAbsName]
    {[[G ; O, x : A |- B async =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G ; O |- {A -o B} async =>- \ x . t ; D]]}
}
\newcommand*{\fSubRAsyncTransitionRule}{
  \inferrule*[right=\fSubRAsyncTransitionName]
  {[[ G ; O async |- C =>- t ; D ]] \\ [[ C ]] \text{ not right async}}{[[G ; O |-
  C async =>- t ; D]]}
}
\newcommand*{\fSubPairElimRule}{
    \inferrule*[right=\fSubPairElimName,lab=LeftAsync]
    {[[G ; {O, x1 : A, x2 : B} async |- C =>- t2 ; D ]] \\ [[ x1 notin D ]] \\ [[
  x2 notin D ]]}{[[G ; {O, x3 : Tup A B} async |- C =>- letpair x1 x2
    = x3 in t2 ; D]]}
}
\newcommand*{\fSubPairElimRuleNoLabel}{
    \inferrule*[right=\fSubPairElimName]
    {[[G ; {O, x1 : A, x2 : B} async |- C =>- t2 ; D ]] \\ [[ x1 notin D ]] \\ [[
  x2 notin D ]]}{[[G ; {O, x3 : Tup A B} async |- C =>- letpair x1 x2
    = x3 in t2 ; D]]}
}
\newcommand*{\fSubSumElimRule}{
    \inferrule*[right=\fSubSumElimName]
    {[[G ; {O, x2 : A} async |- C =>- t1 ; D1]] \quad\, [[ G ; {O, x3 : B} async |- C =>- t2 ; D2
      ]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
{\Gamma ; [[ {O, x1 :  Sum A B} async ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ | \ \Delta_1 \sqcap \Delta_2}
    % {[[G ; {O, x1 : A + B} async |- C =>- case x2 of inl x2 -> t1 | inr x3 -> t2 ; D1 ++- D2]]}
}
\newcommand*{\fSubUnboxRule}{
    \inferrule*[right=\fSubUnboxName]
    {[[G ; {O, x2 : [A] r} async |- B =>- t ; D, x2 : [A] s ]] \\ 0 \sqsubseteq [[ s]]}{[[G; {O, x1 : []
                                                      r A} async |- B =>- let [x2] = x1
                                                      in t ; D]]}
}
\newcommand*{\fSubUnitElimRule}{
    \inferrule*[right=\fSubUnitElimName]
    {[[G ; .|- C =>- t ; D]]}
    {[[G ; x : Unit |- C =>- let () = x in t ; D]]}
}
\newcommand*{\fSubDerRule}{
\inferrule*[right=\fSubDerName]
{[[ G ; {x : [A] s, y : A } async |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G ; {x : [A] r} async |- B =>- [x/y] t ; D, x : [A] s' ]]}
}
\newcommand*{\fSubLAsyncTransitionRule}{
  \inferrule*[right=\fSubLAsyncTransitionName]
  {[[G, x : A ; O async |- C =>- t ; D ]] \\ \text{ A not left async}}{[[G ; {O, x
  : A} async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusRRule}{
\inferrule*[right=\fSubFocusRName,lab=Focus]
  {[[G ; . |- C sync =>- t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusRRuleNoLabel}{
\inferrule*[right=\fSubFocusRName]
  {[[G ; . |- C sync =>- t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusLRule}{
\inferrule*[right=\fSubFocusLName]
  {[[G ; {x : A} sync |- C =>- t ; D]]}{[[ G, x : A; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubPairIntroRule}{
    \inferrule*[right=\fSubPairIntroName,lab=RightSync]
    {[[G ; . |- A sync =>- t1 ; D1]] \\ [[D1 ; . |- B sync =>- t2 ; D2 ]]}{[[G ; .
  |- {Tup A B} sync
    =>- pair t1 t2 ; D2]]}
}
\newcommand*{\fSubPairIntroRuleNoLabel}{
    \inferrule*[right=\fSubPairIntroName]
    {[[G ; . |- A sync =>- t1 ; D1]] \\ [[D1 ; . |- B sync =>- t2 ; D2 ]]}{[[G ; .
  |- {Tup A B} sync
    =>- pair t1 t2 ; D2]]}
}
\newcommand*{\fSubSumIntroRuleL}{
    \inferrule*[right=\fAddSumIntroNameL]
    {[[G ; . |- A sync =>- t ; D]]}{[[ G ; . |- {Sum A B} sync =>- inl t ; D ]]}
}
\newcommand*{\fSubSumIntroRuleR}{
    \inferrule*[right=\fAddSumIntroNameR]
    {[[G ; . |- B sync =>- t ; D]]}{[[ G ; . |- {Sum A B} sync =>- inr t ; D ]]}
}
\newcommand*{\fSubBoxRule}{
    \inferrule*[right=\fSubBoxName]
    {[[G; . |- A async =>- t ; D]]}{[[G ; . |- { [] r A} sync =>- t ; G - r * (G - D)]]}
}
\newcommand*{\fSubUnitIntroRule}{
    \inferrule*[right=\fSubUnitIntroName]
    {\quad}
    {[[G |- Unit =>- () ; G]]}
}
\newcommand*{\fSubRSyncTransitionRule}{
  \inferrule*[right=\fSubRSyncTransitionName]
  {[[ G ; . |-  A async =>- t ; D]]}{ [[ G ; . |- A sync =>- t ; D ]]}
}
\newcommand*{\fSubAppRule}{
    \inferrule*[right=\fSubAppName,lab=LeftSync]
    {[[ G ; {x2 : B} sync |- C =>- t1 ; D1 ]] \qquad [[ x2 notin D1 ]] \qquad  [[D1 ; . |- A sync =>- t2 ; D2]]}{[[G ; {x1 :
    A -o B} sync |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
}
\newcommand*{\fSubAppRuleNoLabel}{
    \inferrule*[right=\fSubAppName]
    {[[ G ; {x2 : B} sync |- C =>- t1 ; D1 ]] \qquad [[ x2 notin D1 ]] \qquad  [[D1 ; . |- A sync =>- t2 ; D2]]}{[[G ; {x1 :
    A -o B} sync |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
}
\newcommand*{\fSubLinVarRule}{
    \inferrule*[right=\fSubLinVarName]
    {\quad}{[[G ; {x : A} sync |- A =>- x ; G]]}
}
\newcommand*{\fSubGrVarRule}{
    \inferrule*[right=\fSubGrVarName]
    {[[ exists s . r <= {s + 1} ]]}{[[G ; {x : [A] r} sync |- A =>- x ; G, x : [A] s]]}
}
\newcommand*{\fSubLSyncTransitionRule}{
  \inferrule*[right=\fSubLSyncTransitionName]
  {[[G ; {x : A} async |- C =>- t ; D]] \\ \text{ A not atomic and not left sync}}{[[G ; {x : A} sync |- C =>- t ; D]]}
}

% FOCUSED ADDITIVE RULES
\newcommand*{\fAddAbsRule}{
    \inferrule*[right=\fAddAbsName, lab=RightAsync]
    {[[G ; O, x : A |- B async =>+ t ; D, x : A]]}{[[ G ; O |- {A -o B} async =>+
  \ x . t ; D]]}
}
\newcommand*{\fAddAbsRuleNoLabel}{
    \inferrule*[right=\fAddAbsName]
    {[[G ; O, x : A |- B async =>+ t ; D, x : A]]}{[[ G ; O |- {A -o B} async =>+
  \ x . t ; D]]}
}
\newcommand*{\fAddRAsyncTransitionRule}{
  \inferrule*[right=\fAddRAsyncTransitionName]
  {[[ G ; O async |- C =>+ t ; D ]] \\ [[ C ]] \text{ not right async}}{[[G ; O |-
  C async =>+ t ; D]]}
}
\newcommand*{\fAddPairElimRule}{
    \inferrule*[right=\fAddPairElimName,lab=LeftAsync]
    {[[G ; O, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}{[[G ; O, x3 : Tup A B |- C =>+ letpair x1 x2
  = x3 in t2 ; D, x3 : Tup A B ]]}
}
\newcommand*{\fAddPairElimRuleNoLabel}{
    \inferrule*[right=\fAddPairElimName]
    {[[G ; O, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}{[[G ; O, x3 : Tup A B |- C =>+ letpair x1 x2
  = x3 in t2 ; D, x3 : Tup A B ]]}
}
\newcommand*{\fAddSumElimRule}{
    \inferrule*[right=\fAddSumElimName]
    {[[G ; {O, x2 : A} async |- C =>+ t1 ; D1, x2 : A]] \\ [[ G ; {O, x3 : B} async |- C =>+ t2 ;
    D2, x3 : B
    ]]}
  {[[ G ]] ; [[ {O, x1 : Sum A B} async ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ |\ \Delta_1 \sqcup \Delta_2, [[ x1 : Sum A B ]]}
}
\newcommand*{\fAddUnboxRule}{
    \inferrule*[right=\fAddUnboxName]
    {[[G ; {O, {x2 : [A] r async}} |- B =>+ t ; D]] \\ \textit{if}\ [[x2 : [A] s]]
                                                               \in [[D]]\ \textit{then}\ [[s]]
                                                               \sqsubseteq [[ r]]\ \textit{else}\  0
   \sqsubseteq [[ r ]]}
  {[[G ; O, x1 : [] r A |- B =>+ let [x2] = x1 in t ; (D \ x2), x1 : [] r A]]}
}
\newcommand*{\fAddUnitElimRule}{
    \inferrule*[right=\fAddUnitElimName]
    {[[G ; . |- C =>+ t ; D]]}
    {[[G ; x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
}
\newcommand*{\fAddDerRule}{
  \inferrule*[right=\fAddDerName]
  { [[ G ; {x : [A]s, y : A} async |- B =>+ t ; D, y : A ]] }
  { [[ G ; x : [A]s async |- B =>+ [x / y] t ; D + x : [A] 1 ]] }
}
\newcommand*{\fAddLAsyncTransitionRule}{
  \inferrule*[right=\fAddLAsyncTransitionName]
  {[[G, x : A ; O async |- C =>+ t ; D ]] \\ \text{ A not left async}}{[[G ; {O, x
  : A} async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusRRule}{
\inferrule*[right=\fAddFocusRName,lab=Focus]
  {[[G ; . |- C sync =>+ t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusRRuleNoLabel}{
\inferrule*[right=\fAddFocusRName]
  {[[G ; . |- C sync =>+ t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusLRule}{
\inferrule*[right=\fAddFocusLName]
  {[[G ; {x : A} sync |- C =>+ t ; D]]}{[[ G, x : A; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddPairIntroRule}{
    \inferrule*[right=\fAddPairIntroName,lab=RightSync]
    {[[G ; . |- A sync =>+ t1 ; D1]] \\ [[G ; . |- B sync =>+ t2 ; D2 ]]}{[[G
  ; . |- {Tup A B} sync
    =>+ pair t1 t2 ; D1 + D2]]}
}
\newcommand*{\fAddPairIntroRuleNoLabel}{
    \inferrule*[right=\fAddPairIntroName]
    {[[G ; . |- A sync =>+ t1 ; D1]] \\ [[G ; . |- B sync =>+ t2 ; D2 ]]}{[[G
  ; . |- {Tup A B} sync
    =>+ pair t1 t2 ; D1 + D2]]}
}
\newcommand*{\fAddSumIntroRuleL}{
    \inferrule*[right=\fAddSumIntroNameL]
    {[[G ; . |- A sync =>+ t ; D]]}{[[ G ; . |- {Sum A B} sync =>+ inl t ; D ]]}
}
\newcommand*{\fAddSumIntroRuleR}{
    \inferrule*[right=\fAddSumIntroNameR]
    {[[G ; . |- B sync =>+ t ; D]]}{[[ G ; . |- {Sum A B} sync =>+ inr t ; D ]]}
}
\newcommand*{\fAddBoxRule}{
    \inferrule*[right=\fAddBoxName]
    {[[G; . |- A async =>+ t ; D]]}{[[G ; . |- { [] r A} sync =>+ [t] ; r * D]]}
}
\newcommand*{\fAddUnitIntroRule}{
    \inferrule*[right=\fAddUnitIntroName]
    {\quad}
    {[[G ; . |- Unit =>+ () ; .]]}
}
\newcommand*{\fAddRSyncTransitionRule}{
  \inferrule*[right=\fAddRSyncTransitionName]
  {[[ G ; . |-  A async =>+ t ; D]]}{ [[ G ; . |- A sync =>+ t ; D ]]}
}
\newcommand*{\fAddAppRule}{
    \inferrule*[right=\fAddAppName,lab=LeftSync]
    {[[ G ; {x2 : B} sync |- C =>+ t1 ; D1, x2 : B]] \\ [[G ; . |- A sync =>+ t2
  ; D2]]}{[[G ; { x1 :
  A -o B } sync |- C =>+ [(x1 t2) / x2] t1 ; (D1 + D2), x1: A -o B ]]}
}
\newcommand*{\fAddAppRuleNoLabel}{
    \inferrule*[right=\fAddAppName]
    {[[ G ; {x2 : B} sync |- C =>+ t1 ; D1, x2 : B]] \\ [[G ; . |- A sync =>+ t2
  ; D2]]}{[[G ; { x1 :
  A -o B } sync |- C =>+ [(x1 t2) / x2] t1 ; (D1 + D2), x1: A -o B ]]}
}
\newcommand*{\fAddLinVarRule}{
    \inferrule*[right=\fAddLinVarName]
  {\quad}{[[G ; x : A |- A =>+ x ; x : A]]}
}
\newcommand*{\fAddGrVarRule}{
    \inferrule*[right=\fAddGrVarName]
    {\quad}{[[G ; x : [A] r |- A =>+ x ; x : [A] 1]]}
}
\newcommand*{\fAddLSyncTransitionRule}{
  \inferrule*[right=\fAddLSyncTransitionName]
  {[[G ; {x : A} async |- C =>+ t ; D]] \\ \text{ A not atomic and not left sync
  }}{[[G ; {x : A} sync |- C =>+ t ; D]]}
}

% ADDITIVE PRUNING FOCUS RULES

\newcommand*{\fAddAltAppRule}{
    \inferrule*[right=\fAddAltAppName]
    {[[G ; x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G - D1 ; . |- A =>+ t2 ; D2
      ]]}{[[G ; x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
}
\newcommand*{\fAddAltPairIntroRule}{
    \inferrule*[right=\fAddAltPairIntroName]
    {[[G ; . |- A =>+ t1 ; D1]] \\ [[G - D1 ; . |- B =>+ t2 ; D2]]}
    {[[G ; . |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
}


% GRADED BASE SYNTHESIS RULES
\newcommand*{\synVar}{\GRANULEdruleVar{}}
\newcommand*{\synAbs}{\GRANULEdruleAbs{}}
\newcommand*{\synApp}{\GRANULEdruleApp{}}
\newcommand*{\synCon}{\GRANULEdruleCon{}}
\newcommand*{\synConAlt}{\GRANULEdruleConAlt{}}
\newcommand*{\synCase}{\GRANULEdruleCase{}}
\newcommand*{\synBox}{\GRANULEdruleBox{}}
\newcommand*{\synUnbox}{\GRANULEdruleUnbox{}}
\newcommand*{\synCaseSub}{\GRANULEdruleCaseSub{}}


\newcommand*{\fsynVar}{\GRANULEdruleVarF{}}
\newcommand*{\fsynAbs}{\GRANULEdruleAbsF{}}
\newcommand*{\fsynUnbox}{\GRANULEdruleUnboxF{}}
\newcommand*{\fsynApp}{\GRANULEdruleAppF{}}
\newcommand*{\fsynCon}{\GRANULEdruleConF{}}
\newcommand*{\fsynCase}{\GRANULEdruleCaseF{}}
\newcommand*{\fsynBox}{\GRANULEdruleBoxF{}}

\newcommand*{\fsynRAsyncTrans}{
  \inferrule*[right=\fsynRAsyncTransName]
  {[[ G ; O async |- B => t ; D ]] \\ [[ B ]] \text{ not right async}}{[[G ; O |-
  B async => t ; D]]}
}
%
\newcommand*{\fsynLAsyncTrans}{
  \inferrule*[right=\fsynLAsyncTransName]
  {[[G, x : A ; O async |- B => t ; D ]] \\ \text{A not left async}}{[[G ; {O, x
  : A} async |- B => t ; D]]}
}
%
\newcommand*{\fsynFocusR}{
\inferrule*[right=\fsynFocusRName,lab=Focus]
{[[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ G ; . async |- B =>+ t ; D]]}
}
%
\newcommand*{\fsynFocusRNoLabel}{
\inferrule*[right=\fsynFocusRName]
{[[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ G ; . async |- B =>+ t ; D]]}
}
%
\newcommand*{\fsynFocusL}{
\inferrule*[right=\fsynFocusLName]
  {[[G ; {x : A} sync |- B => t ; D]]}{[[ G, x : A; . async |- B => t ; D]]}
}
%
\newcommand*{\fsynRSyncTrans}{
  \inferrule*[right=\fsynRSyncTransName]
  {[[ G ; . |-  A async => t ; D]]}{ [[ G ; . |- A sync => t ; D ]]}
}
%
\newcommand*{\fsynLSyncTrans}{
  \inferrule*[right=\fsynLSyncTransName]
  {[[G ; {x : A} async |- B => t ; D]] \\ \text{ A not atomic and not left sync
  }}{[[G ; {x : A} sync |- B => t ; D]]}
}

% \newcommand*{\fsynCaseSub}{\GRANULEdruleCaseSub{}}
% \newcommand*{\fsynCase}{\GRANULEdruleCase{}}
% \newcommand*{\synCaseAltAlt}{\GRANULEdruleCaseAltAlt{}}
% SYNTAX AND TYPES
\newcommand{\synLet}[3]{\textbf{let}\ #1 \leftarrow #2\ \textbf{in}\ #3}
% \newcommand{\synCase}[2]{\mathbf{case}\ #1\ \mathbf{of}\ #2}
\newcommand{\synCaseBranch}[2]{#1 \rightarrow #2}

\newcommand{\synCaseOne}[3]
  {\synCase{#1}{\synCaseBranch{#2}{#3}}}

\newcommand{\synCaseTwo}[5]
  {\synCase{#1}{\begin{array}[t]{l}\synCaseBranch{#2}{#3};\\ \synCaseBranch{#4}{#5}\end{array}}}


\newcommand{\synCaseTwoMultiLine}[5]
  {\begin{array}[t]{l}
   \synCase{#1}{\\ \begin{array}[t]{l}\synCaseBranch{#2}{#3};\\
                     \synCaseBranch{#4}{#5}\end{array}}
  \end{array}}


\newcommand{\synCaseTwoShort}[5]
  {\synCase{#1}{\begin{array}[t]{l}\synCaseBranch{#2}{#3};\;\; \synCaseBranch{#4}{#5}\end{array}}}

\newcommand{\synLetRec}[3]
 {\mathbf{letrec}\ #1 = #2\ \mathbf{in}\ #3}

% \newcommand{\synUnbox}[3]
%  {\mathbf{let}\ [#1] = #2\ \mathbf{in}\ #3}

% \definecolor{coeffectColor}{HTML}{0a40a1}
% \newcommand{\coeff}[1]{\textcolor{coeffectColor}{#1}}

\newcommand{\tcF}{\mathsf{F}}

% DERIVING

\newcommand{\deriv}[2]{\llbracket{#2}\rrbracket_{\mathsf{#1}}}

% STRUCTURAL for the paper / work

\newcommand{\paragrapho}[1]{\medskip\noindent \textbf{#1}$\;\;$}
\newcommand{\grminip}{\textsc{GrMini}$^P$}

% PROOFS

\newcommand{\pr}[1]{\{\textit{#1}\}}
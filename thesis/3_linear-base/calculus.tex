We extend the syntax of the graded linear $\lambda$-calculus with multiplicatve
product types $\otimes$, additive coproduct types $\oplus$, and a multiplicative
unit $1$. The syntax for the full language is given by the following grammar:
\begin{align*}
\hspace{-0.8em} [[ t ]] ::= \;
       & [[ x ]]
  \mid [[ \x . t ]]
  \mid [[ t1 t2 ]]
  \mid [[ [t] ]]
  \mid [[ let [ x ] = t1 in t2 ]]
\mid [[ pair t1 t2 ]]
  \mid [[ letpair x1 x2 = t1 in t2 ]] \\
\hspace{-0.9em}  \mid \; & () \mid [[ let () = t1 in t2 ]]
\mid [[ inl t ]] \mid [[ inr t ]] \mid \textbf{case} \ t_{1}\ \textbf{of}\ \textbf{inl}\ x_{1} \rightarrow t_{2};\ \textbf{inr}\ x_{2} \rightarrow t_{3}
{\small{\tag{terms}}}
\end{align*}
We use the syntax $()$ for the inhabitant of  the multiplicative unit $1$.
Pattern matching via a $\textbf{let}$ is used to eliminate products and unit
types; for sum types, $\textbf{case}$ is used to distinguish the constructors.

\begin{figure}[H]
\begin{align*}
\hspace{-0.5em}
  \begin{array}{c}
\inferrule*[right = Pair]
  {[[ G1 |- t1 : A ]] \\ [[ G2 |- t2 : B ]]}
  {[[ G1 + G2 |- pair t1 t2 : Tup A B]]}
\\[0.9em]
\inferrule*[right = LetPair]
  {[[ G1  |- t1 : Tup A B ]] \;\; [[ G2, x1 : A, x2 : B |- t2 : C ]]}
  {[[ G1 + G2 |- letpair x1 x2 = t1 in t2 : C  ]]}
\\[0.9em]
\inferrule*[right = Inl]
  {[[ G |- t : A ]]}
  {[[ G |- inl t : Sum A B ]]}
\;\;\;
\inferrule*[right = Inr]
  {[[ G |- t : B ]]}
  {[[ G |- inr t : Sum A B]]}
\\[0.9em]
\inferrule*[right = Case]
  {[[ G1 |- t1 : Sum A B ]] \\ [[ G2, x1 : A |- t2 : C]] \\ [[ G3, x2 : B |- t3 : C]]}
    {\Gamma + (\Gamma_{2} \sqcup \Gamma_{3}) \vdash\ \textbf{case} \ t_{1}\ \textbf{of}\ \textbf{inl}\ x_{1} \rightarrow t_{2};\ \textbf{inr}\ x_{2} \rightarrow t_{3} : C }
\\[0.9em]
\inferrule*[right = 1]
 {\quad}{[[ . |- () : Unit ]]}
\;\;\;
\inferrule*[right = Let$1$]
 {[[G1 |- t1 : Unit ]] \quad [[ G2 |- t2 : A ]]}
 {[[ G1 + G2 |- let () = t1 in t2 : A ]]}
\end{array}
\end{align*}
\vspace{-1.25em}
  \caption{Typing rules of for $\otimes$, $\oplus$, and $1$}
\label{fig:typing-prod-sum-unit}
 \end{figure}

Figure~\ref{fig:typing-prod-sum-unit} gives the typing rules.  Rules for
multiplicative products (pairs) and additive coproducts (sums) are routine,
where pair introduction ($\textsc{Pair}$) adds the contexts used to type the
pair's constituent subterms. Pair elimination ($\textsc{LetPair}$) binds a
pair's components to two linear variables in the scope of the body $[[t2]]$. The
$\textsc{Inl}$ and $\textsc{Inr}$ rules handle the typing of constructors for
the sum type $[[Sum A B]]$. Elimination of sums ($\textsc{Case}$) takes the
least upper bound (defined above) of the contexts used to type the two branches
of the case.

In the typing of $\mathbf{case}$ expressions, the \emph{least-upper bound} of
  the two contexts used to type each branch is used, defined:

\begin{definition}[Partial least-upper bounds of
  contexts]\label{def:context-lub} For all $[[ G1 ]]$, $[[ G2 ]]$:
\begin{align*}
\label{def:lub}
[[G1]] \sqcup [[G2]] =
%%
\left\{\begin{matrix}
\begin{array}{lll}
%% Both empty case
\emptyset
  & [[ G1 ]] = \emptyset & \wedge \; [[ G2 ]] = \emptyset
\\
%
%% Left empty
(\emptyset \sqcup [[ G2' ]]), [[ x : [ A ] {lub 0 s} ]]
  & [[ G1 ]] = \emptyset & \wedge \; [[G2]] = [[ G2',x : [A] s]]
\\
%
%% Left is left linear
([[G1']] \sqcup [[(G2',G2'')]]), [[x : A]]
 & [[G1]] = [[{G1', x : A} ]] & \wedge \; [[ G2 ]] = [[ {G2', x : A},, G2'' ]]
\\
%
%% Left is graded
([[G1']] \sqcup [[(G2',G2'')]]), [[x : [A] {lub r s}]]\;\;
 & [[G1]] = [[ G1',x : [A] r]] & \wedge \; [[ G2 ]] = [[{G2', x : [A] s}, G2'']]
\end{array}
\end{matrix}\right.
\end{align*}
where $r\!\sqcup\!s$ is the least-upper bound of grades $[[r]]$ and $[[s]]$ if
it exists, derived from $\sqsubseteq$.
\end{definition}
%
As an example of the partiality of $\sqcup$, if one branch of a \textbf{case}
uses a linear variable, then the other branch must also use it to maintain
linearity overall, otherwise the upper-bound of the two contexts for these
branches is not defined.

 With these extensions in place, we now have the capacity to write more
 idiomatic functional programs in our target language. As a demonstration of
 this, and to showcase how graded modalities interact with these new type
 extensions, we provide two further examples of different graded modalities
 which complement these new types.

\begin{example}%[Intervals]
\label{exm:or3}
Exact usage analysis is less useful when control-flow is involved, e.g.,
eliminating sum types where each control-flow branch uses variables differently.
The above $\mathbb{N}$-semiring can be imbued with a notion of
\emph{approximation} via less-than-equal ordering, providing upper bounds. A
more expressive semiring is that of natural number
intervals~\cite{DBLP:journals/pacmpl/OrchardLE19}, given by pairs $\mathbb{N}
\times \mathbb{N}$ written $[[ Intrv r s ]]$ here for the lower-bound $r \in
\mathbb{N}$ and upper-bound usage $s \in \mathbb{N}$ with $0 = [[ Intrv 0 0 ]]$
and $1 = [[ Intrv 1 1 ]]$, addition and multiplication defined pointwise, and
ordering $[[ Intrv r s ]] \sqsubseteq [[ Intrv r' s' ]] = [[ r' ]] \leq [[ r ]]
\wedge [[ s ]] \leq [[ s' ]]$. Thus a coproduct elimination function can be
written and typed:
%
\begin{align*}
\oplus_e & : [[ {[] {Intrv 0 1} (A -o C)} -o {{[] {Intrv 0 1} (B -o C)} -o {(Sum A B) -o C}} ]] \\
\oplus_e & =
\lambda x' . \lambda y' . \lambda z. \textbf{let}\ [x] = x'\ \textbf {in}\
\textbf{let}\ [y] = y'\ \textbf{in}\ \textbf{case}\ z\ \textbf{of}\
\textbf{inl}\ u \rightarrow x\ u\ |\ \textbf{inr}\ v\ \rightarrow y\ v
\end{align*}
\end{example}

\begin{example}%[Information flow]
\label{exm:security}
%
Graded modalities can capture a form of information-flow security, tracking the
flow of labelled data through a program~\cite{DBLP:journals/pacmpl/OrchardLE19},
with a lattice-based semiring on $\mathcal{R} = \{[[ Irrelevant ]] \sqsubseteq
[[ Private ]] \sqsubseteq  [[ Public ]]\}$ where $0 = [[ Irrelevant ]]$, $1 = [[
Private ]]$, $+ = \sqcup$ and if $r = [[ Irrelevant ]]$ or $s = [[ Irrelevant
]]$ then $[[r * s ]] = [[ Irrelevant ]]$ otherwise $[[ r * s ]] = \sqcup$. This
allows the following well-typed program, eliminating a pair of $[[ Public ]]$
and $[[ Private ]]$ security values, picking the left one to pass to a
continuation expecting a $[[ Public ]]$ input:
%
\begin{align*}
\textit{noLeak} & : [[ (Tup {[] Public A} {[] Private A}) -> {({[]
                  Public (Tup A Unit)} -> B) -> B} ]] \\
\textit{noLeak} & = [[ \z . {\z' . {letpair x' y' = z in {let [x] = x' in
                  {let [y] = y' in {z' [ pair x () ]}}}}} ]]
\end{align*}
\end{example}

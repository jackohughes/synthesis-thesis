The additive and subtractive calculi presented above serve as starting points
for the implementation of a synthesis algorithm in Granule. However,
implementing the rules in their current form would yield a highly inefficient
tool. As they stand, the rules exhibit a high degree of non-determinism with
regard to order in which they may be applied. 

For example, consider the following synthesis scenario:
\begin{align*} 
    x :_{0 .. 5} A \otimes B \vdash A \multimap (A \otimes B) \otimes A \Rightarrow\ ?\ |\ ? 
\end{align*}
Here we have two choices for the next rule to apply: either an introduction rule
towards the goal type: $\multimap_\textsc{R}$, or an
$\otimes_{\textsc{L}}$ elimination rule on $x$. If we do chose to apply
$\multimap_\textsc{R}$, we are again presented with a choice to apply an
elimination rule again, even though the final synthesised term would remain the
same regardless of where this elimination takes place in the synthesis
derivation tree. 

This leads to us exploring a large number of redundant search branches which can
be avoided through the application of a technique from linear logic proof theory
called \textit{focusing}~\cite{focusing}. Focusing is based on the observation
that some of the synthesis rules are invertible, i.e. whenever the conclusion of
the rule is derivable, then so are its premises. In other words, the order in
which we apply invertible rules doesn't matter. By fixing a particular ordering
on the application of these rules, we eliminate much of the non-determinism that
arises from trying branches which differ only in the order in which invertible
rules are applied. 

We take our both of our calculi and apply this focusing technique to them,
yielding two \textit{focusing} calculi. To do so, we augment our previous
synthesis judgement with an additional input context $\Omega$:
\begin{align*}
\Gamma ; \Omega \vdash [[ A ]] \Rightarrow [[t ]]\ |\ \Delta
\end{align*}
Unlike $\Gamma$ and $\Delta$, $\Omega$ is an \textit{ordered} context, which 
behaves like a stack.

Using the terminology of Pfenning, we refer to rules that are invertible as
\textit{asynchronous} and rules that are not as
\textit{synchronous}~\cite{pfenninglecture}. The intuition here is that
asynchronous rules can be applied eagerly, while the non-invertible synchronous
rules require us to \textit{focus} on a particular part of the judgement: either
on the assumption (if we are in an elimination rule) or on the goal (for an
introduction rule). When focusing we apply a chain of synchronous rules, until
we either reach a position where no rules may be applied (at which point the
branch terminates), we have synthesised a term for our goal, or we have exposed
an asynchronous connective at which point we switch back to applying
asynchronous rules.

We divide our synthesis rules into four categories, each with their own
judgement form, which refines the focusing judgement above with an arrow
indicating which part of the judgement is currently in focus. An $\Uparrow$
indicates an asynchronous phase, while a $\Downarrow$ indicates a synchronous
(focused) phase. The location of the arrow in the judgement indicates whether we
are focusing on the left or right:
\begin{enumerate}
  \item Right Async: $\multimap_{\textsc{R}}$ rule with the judgement:
        \begin{align*}\Gamma ; \Omega \vdash A \Uparrow\ \Rightarrow t\ |\ \Delta \end{align*}
        \item Left Async:  $\otimes_{\textsc{L}}$, $\oplus_{\textsc{L}}$, $1_{\textsc{L}}$, $\textsc{Der}$, and $\Box_{\textsc{L}}$ rules with the judgement:
        \begin{align*}\Gamma ; \Omega \Uparrow\ \vdash A \Rightarrow t\ |\ \Delta \end{align*}
        \item Right Sync:  $\otimes_{\textsc{R}}$, $\oplus1_{\textsc{R}}$, $\oplus2_{\textsc{R}}$, $1_{\textsc{R}}$, and $\Box_{\textsc{R}}$ rules with the judgement:
        \begin{align*}\Gamma ; \Omega \vdash A \Downarrow\ \Rightarrow t\ |\ \Delta \end{align*}
        \item Left Sync:   $\multimap_{\textsc{L}}$ rule with the judgement:
        \begin{align*}\Gamma ; \Omega \Downarrow\ \vdash A \Rightarrow t\ |\ \Delta \end{align*}
\end{enumerate}

The complete calculi of focusing synthesis rules are given in
figures~\ref{fig:focus-sub-right-async}-\ref{fig:focus-sub-left-sync} for the
subtractive calculus,
and~\ref{fig:focus-add-right-async}-\ref{fig:focus-add-left-sync} for the
additive, divided into focusing phases. The focusing rules for the additive pruning 
calculus are identical to the additive calculus, save for the $\otimes^{+}_{\textsc{R}}$ and 
$\multimap^{+}_{\textsc{L}}$ rules. These rules are given in figure~\ref{fig:focus-add-pruning}.

For the most part, the translation from
non-focused to focused rules is straightforward. The most notable change occurs
in rules in which assumptions are bound. In the cases where a fresh assumption's
type falls into the Left Async category (i.e. $\otimes$, $oplus$, etc.), then it is bound in the
ordered context $\Omega$ instead of $\Gamma$. Likewise, Left Async rules will
operate on assumptions in $\Omega$. This results in invertible elimination rules
being applied as fully as possible before \textit{focusing} on non-invertible
rules when $\Omega$ is empty.

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fSubAbsRuleNoLabel
  \\[0.5em]
  \fSubRAsyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Right Async rules of the focused subtractive synthesis calculus}
  \label{fig:focus-sub-right-async}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fSubPairElimRuleNoLabel
  \\[0.5em]
  \fSubSumElimRule
  \\[0.5em]
  \fSubUnboxRule
  \\[0.5em]
  \fSubUnitElimRule
  \\[0.5em]
  \fSubDerRule
  \\[0.5em]
  \fSubLAsyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Left Async rules of the focused subtractive synthesis calculus}
  \label{fig:focus-sub-left-async}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fSubFocusRRuleNoLabel
  \\[0.5em]
  \fSubFocusLRule
  \end{array}
  \end{align*}
  \caption{Focus rules of the focused subtractive synthesis calculus}
  \label{fig:focus-sub-focus}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
\fSubPairIntroRuleNoLabel
  \\[0.5em]
  \fSubSumIntroRuleR
  \,
  \fSubSumIntroRuleL
  \\[0.5em]
  \fSubBoxRule
  \\[0.5em]
  \fSubUnitIntroRule
  \,
  \fSubRSyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Right Sync rules of the focused subtractive synthesis calculus}
  \label{fig:focus-sub-right-sync}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fSubAppRuleNoLabel
  \\[0.5em]
  \fSubLinVarRule
  \,
  \fSubGrVarRule
  \\[0.5em]
  \fSubLSyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Left Sync and Var rules of the focused subtractive synthesis calculus}
  \label{fig:focus-sub-left-sync}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fAddAbsRuleNoLabel
  \\[0.5em]
  \fAddRAsyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Right Async rules of the focused additive synthesis calculus}
  \label{fig:focus-add-right-async}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fAddPairElimRuleNoLabel
  \\[0.5em]
  \fAddSumElimRule
  \\[0.5em]
  \fAddUnboxRule
  \\[0.5em]
  \fAddDerRule
  \\[0.5em]
  \fAddUnitElimRule
  \\[0.5em]
  \fAddLAsyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Left Async rules of the focused additive synthesis calculus}
  \label{fig:focus-add-left-async}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fAddFocusRRuleNoLabel
  \\[0.5em]
  \fAddFocusLRule
  \end{array}
  \end{align*}
  \caption{Focus rules of the focused additive synthesis calculus}
  \label{fig:focus-add-focus}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fAddPairIntroRuleNoLabel
  \\[0.5em]
  \fAddSumIntroRuleL
  \,
  \fAddSumIntroRuleR
  \\[0.5em]
  \fAddBoxRule
  \,
  \fAddUnitIntroRule
  \\[0.5em]
  \fAddRSyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Right Sync rules of the focused additive synthesis calculus}
  \label{fig:focus-add-right-sync}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
  \fAddAppRule
  \\[0.5em]
  \fAddLinVarRule
  \,
  \fAddGrVarRule
  \\[0.5em]
  \fAddLSyncTransitionRule
  \end{array}
  \end{align*}
  \caption{Left Sync and Var rules of the focused additive synthesis calculus}
  \label{fig:focus-add-left-sync}
\end{figure}

\begin{figure}[H]
  \begin{align*}
\begin{array}{c}
\fAddAltAppRule
  \\[0.5em]
\fAddAltPairIntroRule
  \end{array}
  \end{align*}
  \caption{Rules of the focused additive pruning synthesis calculus}
  \label{fig:focus-add-pruning}
\end{figure}

One way to view focusing is in terms of a finite state machine, such as
figure~\ref{fig:focusingFSM}. States comprise the four phases of focusing, plus
two additional states, \textsc{Focus}, and \textsc{Var}. Edges are then the
synthesis rules that direct the transition between focusing phases. The
transitions between these focusing phases are handled by dedicated focusing
rules for each transition. For the asynchronous phases, the
$\Uparrow_{R}$/$\Uparrow_{L}$ handle the transition between right to left
phases, and left to focusing phases, respectively. Conversely, the
$\Downarrow{R}$ rule deals with the transition from a right synchronous phase
back to a right asynchronous phase, with the $\Downarrow{L}$ rule likewise
transitioning to a left asynchronous phase. Depending on the current phase of
focusing, these rules consider the goal type, the assumption currently being
focused on's type, as well as the size of $\Omega$, to decide whether to
transition between focusing phases. 

This focused approach to synthesis ensures that we are restricted to generating
programs in $\beta$-normal form, which eliminates a class of redundant programs
for which behaviourally equivalent $\beta$-normal forms can be synthesised in
less steps.

\begin{restatable}[Soundness of focusing ]{lemma}{linearBaseFocusingSoundness}
  For all contexts $[[ G ]]$, $[[ O ]]$ and types $[[ A ]]$:
  \begin{align*}
  \begin{array}{lll}
   1.\ Right\ Async: & [[ G ; O |- A async => t ; D ]] \quad &\implies \quad [[ G ,, O |- A => t ; D ]]\\
   2.\ Left\ Async: & [[ G ; O async |- B => t ; D ]] \quad &\implies \quad [[ G ,, O |- B => t ; D ]]\\
   3.\ Right\ Sync: & [[ G ]] ; \emptyset \vdash [[ A ]] \Downarrow\ \ \Rightarrow [[ t ]] \mid\  [[ D ]] \quad &\implies \quad [[ G |- A => t ; D ]]\\
   4.\ Left\ Sync: & [[ G ; {x : A} sync |- B => t ; D ]] \quad &\implies \quad [[ G, x : A |- B => t ; D ]]\\
   5.\ Focus\ Right: & [[ G ]] ; \emptyset \vdash [[ B]] \Rightarrow [[ t]] \mid\ [[ D ]] \quad &\implies \quad [[ G |- B => t ; D ]]\\
   6.\ Focus\ Left: & [[ G, x : A]] ; \emptyset \vdash [[ B]] \Rightarrow [[t ]] \mid\ [[ D ]] \quad &\implies \quad [[ G, x : A |- B => t ; D ]]
  \end{array}
  \end{align*}
i.e. $[[ t ]]$ has type $[[ A ]]$
under context $[[ D ]]$,
which contains assumptions with grades reflecting their use in $[[ t ]]$.
The appendix provides the proof.
Appendix~\ref{sec:soundness-proofs} provides the proof.
  \end{restatable}

\tikzset{
->, % makes the edges directed
node distance=5cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

\begin{figure}[H] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
\centering 

\scalebox{0.85}{
\begin{tikzpicture}[every text node part/.style={align=center}]
\node[state, initial, draw] (RA) {\textsc{Right Async} \\ $ \Gamma ; \Omega \vdash A \Uparrow\ \Rightarrow t\ |\ \Delta $};
\node[state] at (10,  0) (LA) { \textsc{Left Async} \\ $\Gamma ; \Omega \Uparrow\ \vdash A \Rightarrow t\ |\ \Delta $};
\node[state] at (5, -5) (F) { \textsc{Focus} \\ $\Gamma ; \emptyset \Uparrow\ \vdash A \Rightarrow t\ |\ \Delta $};
\node[state] at (0, -10) (RS) { \textsc{Right Sync} \\ $\Gamma ; \emptyset \vdash A\ \Downarrow\ \Rightarrow t\ |\ \Delta $};
\node[state] at (10, -10) (LS) { \textsc{Left Sync} \\ $\Gamma ; [[ x : B ]] \Downarrow\ \vdash A \Rightarrow t\ |\ \Delta $};
\node[state, accepting] at (5, -12) (V) { \textsc{Var} \\ $\Gamma ; [[ x : A ]] \Downarrow\ \vdash A \Rightarrow t\ |\ \Delta $};
\draw (RA) edge[loop above] node{$\multimap_{\textsc{R}}$} (RA)
(RA) edge[above, bend left] node{$\Uparrow_{\textsc{R}}$} (LA)
(LA) edge[loop above] node{$\otimes_{\textsc{L}}$, $\oplus_{\textsc{L}}$, \\ $1_\textsc{L}$, $\textsc{Der}$, \\ $\Box_{\textsc{L}}$, $\Uparrow_{\textsc{L}}$ } (LA)
% (LA) edge[loop right] node{$\Uparrow_{L}$} (LA)
(LA) edge[left, bend right] node{$\otimes_{\textsc{L}}$, $\oplus_{\textsc{L}}$, \ \ \ \\ $1_\textsc{L}$, $\textsc{Der}$, \ \ \ \ \\ $\Box_{\textsc{L}}$, $\Uparrow_\textsc{L}$ \ \ \ \ \\  } (F)
% (LA) edge[right, bend left] node{$\Uparrow_{L}$} (F)
(F) edge[below, bend right] node{\ \ \ \  $\textsc{F}_{\textsc{R}}$} (RS)
(RS) edge[left, bend left] node{$\Downarrow_{\textsc{L}}$} (RA)
(F) edge[below, bend left] node{$\textsc{F}_{\textsc{L}}$\ \ } (LS)
(LS) edge[right, bend right] node{$\Downarrow_{\textsc{L}}$} (LA)
(LS) edge[below, bend right] node{$\multimap_{\textsc{L}}$} (RS)
(LS) edge[loop below] node{$\multimap_{\textsc{L}}$} (LS)
(RS) edge[loop below] node{$\otimes_{\textsc{R}}$, $\oplus1_{\textsc{R}}$, $\oplus2_{\textsc{R}}$, \\ $1_\textsc{R}$, $\Box_{\textsc{R}}$} (RS)
(LS) edge[below, bend left] node{\ \ \ $\textsc{LinVar}$, \\ \ \ \ $\textsc{GrVar}$ } (V)
;
\end{tikzpicture}
}
\caption{Focusing State Machine}
\label{fig:focusingFSM}
\end{figure}

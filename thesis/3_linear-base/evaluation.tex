\newcommand{\stderr}[1]{\textcolor{gray}{${#1}$}} % \pm{#1}
\newcommand{\fail}{\textcolor{mypink3}{$\times$}}
\newcommand{\success}{\checkmark}
\newcommand{\highlight}[1]{%
{\setlength{\fboxsep}{0pt}\colorbox{yellow!50}{$\displaystyle#1$}}}

Prior to evaluation, we made the following hypotheses about the
relative performance of the additive versus subtractive approaches:
%
\begin{enumerate}[itemsep=0em]
\item Additive synthesis should make fewer calls to the solver, with lower
complexity theorems (fewer quantifiers). Dually,
subtractive synthesis makes more calls to the solver with
higher complexity theorems (more quantifiers);

\item For complex problems, additive synthesis will
explore more paths as it cannot tell whether a variable is not
well-resourced until closing a binder; additive pruning and subtractive will
explore fewer paths as they can fail sooner.

\item A corollary of the above two: simple examples will
likely be faster in additive mode, but more complex examples will be
faster in subtractive mode.
\end{enumerate}

\subsubsection{Methodology}
We implemented our approach as a synthesis tool for
Granule, integrated with its core tool. Granule features
ML-style polymorphism (rank-0 quantification) but we do not address polymorphism here.
Instead, programs are synthesised from type schemes treating universal
type variables as logical atoms. %Multiplicative products are
%primitive in Granule, although additives coproducts are provided via
%ADTs, from which we define a core sum type to use here.

Constraints on resource usage are handled via Granule's existing
symbolic engine, which compiles constraints on grades (for various semirings)
to the SMT-lib format for Z3~\cite{z3}.
%In the case of graded variable synthesis in the subtractive
%scheme, the kind of the assumption's grade (i.e., what semiring it
%belongs to) is inferred using Granule's type
%checker, which is used to generate an existential variable representing
%the remaining available usage of the graded assumption.
We use the LogicT
monad for backtracking search~\cite{logict}
and the Scrap Your Reprinter library for
splicing synthesised code into syntactic ``holes'',
preserving the rest of the program text~\cite{clarke2017scrap}.

To evaluate our synthesis tool we developed a suite of benchmarks comprising
Granule type schemes for a variety of operations using linear and graded modal
types. We divide our benchmarks into several classes of problem:
%
\begin{itemize}[itemsep=0em,leftmargin=1.1em]
\item \textbf{Hilbert}: the Hilbert-style axioms of
  intuitionistic logic (including SKI combinators), with appropriate $\mathbb{N}$ and $\mathbb{N}$-intervals
  grades where needed (see, e.g., $S$ combinator in
  Example~\ref{ex:s-comb} or coproduct elimination in Example~\ref{exm:or3}).

\item \textbf{Comp}: various translations of function composition
into linear logic: multiplicative, call-by-value and
call-by-name using $!$~\cite{girard1987linear}, I/O using $!$~\cite{liang2009focusing},
and coKleisli composition over $\mathbb{N}$ and arbitrary semirings:
e.g. $\forall r, s \in \mathcal{R}$:
%
\begin{equation*}
\textit{comp-}\textit{coK}_{\mathcal{R}} : [[ {[] r ({[] s A} -> B)} -> {({[] r B} -> C) -> {{[] {r * s} A} -> C}} ]]
\end{equation*}
%
\item \textbf{Dist}: distributive laws of various graded
modalities over functions, sums, and products~\cite{hughes2020},
e.g., $\forall r \in \mathbb{N}$, or
$\forall r \in \mathcal{R}$ in any semiring, or $r = [[ Intrv 0 Inf ]]$:
%
\begin{equation*}
\textit{pull}_\oplus : [[ (Sum {[] r A} {[] r B}) -> [] r (Sum A B) ]]
\quad\;\;\;
\textit{push}_\multimap : [[ {[] r (A -> B)} -> {{[] r A} -> [] r B} ]]
\end{equation*}
%
%% data type and vice vera as our second class of programs. In the latter case, we have programs
%which \textit{pull} natural number, !, and general modalities out of sum,
%product, and vector data types. In the former case, we have programs
%which distribute (\textit{push}) natural number, !, and general graded modalities over a
%function type. The ability to synthesise \textit{push} over other data types is
%further work (see section \ref{sec:futurework}).

\item \textbf{Vec}: map operations on
vectors of fixed size encoded as products, e.g.:
%
\begin{equation*}
\!\!
\textit{vmap}_5 : [[ {[] 5 (A -> B)} -> {(Tup (Tup (Tup (Tup A A) A) A) A) -> (Tup (Tup (Tup (Tup B B) B) B) B)} ]]
\end{equation*}
%

\item \textbf{Misc}: includes Example~\ref{exm:security}
  (information-flow security) and  functions which must share or split resources
between graded modalities, e.g.:
%one problem requires two graded values (the first two parameters)
%to be shared between two applications of a function given as the third input:
%
\begin{equation*}
\!\!
\textit{share}: [[ {{[] 4 A} -> {{[] 6 A} -> {[] 2 {({(Tup {(Tup {(Tup {(Tup A A)} A)} A)} A)} ->
    B)} }}} -> {(Tup B B)}  ]]
\end{equation*}
%
\end{itemize}
%
Appendix~\ref{app:list-of-types} lists the type schemes for these
synthesis problems (32 in total).

We found that Z3 is highly variable in its solving time, so timing
measurements are computed as the mean of 20 trials. We used
Z3 version 4.8.8 on a Linux laptop with an Intel i7-8665u @ 4.8 Ghz
and 16 Gb of RAM.

\subsubsection{Results and analysis}
%
For each synthesis problem, we recorded whether synthesis
was successful or not (denoted $\success$ or \fail), the mean
total synthesis time ($\mu{T}$), the mean total time spent by
the SMT solver ($\mu\textsc{smt}$), and the number of
calls made to the SMT solver (\textsc{N}).
Table~\ref{tab:results} summarises the results with the fastest case for each
benchmark highlighted.
For all benchmarks that used
the SMT solver, the solver accounted for $91.73\%-99.98\%$
of synthesis time, so we report only the mean
total synthesis time $\mu{T}$. % as this gives a good proxy of the solver time.
We set a timeout of 120 seconds.

\begin{table}[t]
{\small{
\begin{center}
\setlength{\tabcolsep}{0.3em}
% this is wide enough to show 4 modes worth of data
\begin{tabular}{p{2.5em}r|p{0.75em}rr|p{0.5em}rr|p{0.5em}rr}
 & & \multicolumn{3}{c|}{Additive}&\multicolumn{3}{c|}{Additive (pruning)}&\multicolumn{3}{c|}{Subtractive}\\ \hline
\multicolumn{2}{c|}{{Problem}} &  & \multicolumn{1}{c}{$\mu{T}$ (ms)} & \multicolumn{1}{r|}{\textsc{N}} & & \multicolumn{1}{c}{$\mu{T}$ (ms)} & \multicolumn{1}{r|}{\textsc{N}} & & \multicolumn{1}{c}{$\mu{T}$ (ms)} & \multicolumn{1}{r|}{\textsc{N}} \\ \hline\hline
\multirow{5}{*}{{\rotatebox{90}{\textbf{Hilbert}}}}
& $\otimes{}$Intro & \success{} &   {\highlight{$6.69 (\stderr{  0.05})$}} &   2  &    \success{}
                                             &   9.66 (\stderr{  0.23}) &   2
                                                                     &     \success{}   &  10.93 (\stderr{  0.31}) &   2 \\
& $\otimes{}$Elim                     & \success{} &   0.22 (\stderr{  0.01}) &   0       & \success{} &   {\highlight{$0.05 (\stderr{  0.00})$}} &   0       & \success{} &   0.06 (\stderr{  0.00}) &   0      \\
& $\oplus{}$Intro & \success{} &   0.08 (\stderr{  0.00}) &   0    &  \success{}
                                          &   {\highlight{$0.07 (\stderr{  0.00})$}} &   0
                                                                   &    \success{}
                                                                                 &
                                                                                   {\highlight{$0.07
                                                                                   (\stderr{
                                                                                   0.00})$}}
                                                                                                                   &   0 \\
& $\oplus{}$Elim                       & \success{} &   {\highlight{$7.26 (\stderr{  0.30})$}} &   2       & \success{} &  13.25 (\stderr{  0.58}) &   2       & \success{} & 204.50 (\stderr{  8.78}) &  15      \\ %SmtT/T = 93.85304985917998%, 91.73667044352199%, 99.1533306157868%
& SKI & \success{} &   {\highlight{$8.12 (\stderr{  0.25})$}} &   2  &    \success{} &  24.98
                                                                      (\stderr{
                                                                      1.19}) &
                                                                               2
                                                                             &  \success{}
                                                                                 &
                                                                                   41.92
                                                                                   (\stderr{
                                                                                   2.34})
                                                                                                                   &
                                                                                                                     4
                 \\
\hline
\multirow{6}{*}{{\rotatebox{90}{\textbf{Comp}}}}
& 01                        & \success{} &  {\highlight{$28.31 (\stderr{  3.09})$}} &   5       & \success{} &  41.86 (\stderr{  0.38}) &   5  & \fail{} & Timeout & -    \\
& cbn                       & \success{} &  {\highlight{$13.12 (\stderr{  0.84})$}} &   3       & \success{} &  26.24 (\stderr{  0.27}) &   3  & \fail{} & Timeout & -    \\
& cbv                       & \success{} &  {\highlight{$19.68 (\stderr{  0.98})$}} &   5       & \success{} &  34.15 (\stderr{0.98}) &   5   & \fail{} & Timeout & -   \\
& $\circ\textit{coK}_\mathcal{R}$                 & \success{} &  33.37 (\stderr{  2.01}) &   2       & \success{} &  {\highlight{$27.37$}} (\stderr{  0.78}) &   2       & \fail{}  &  92.71 (\stderr{  2.37}) &   8      \\  % SmtT/T = 98.56608024136683%, 98.56541178986083%, 98.70614421865372%
& $\circ\textit{coK}_\mathbb{N}$                 & \success{} &  27.59 (\stderr{  0.67}) &   2       & \success{} &  {\highlight{$21.62$}} (\stderr{  0.59}) &   2       & \fail{}  &  95.94 (\stderr{  2.21}) &   8      \\ % SmtT/T = 98.36019681512148%, 98.35210841341276%, 98.63478123527435%
& mult                      & \success{} &   0.29 (\stderr{  0.02}) &   0       & \success{} &   0.12 (\stderr{  0.00}) &   0       & \success{} &   {\highlight{$0.11 (\stderr{  0.00})$}} &   0      \\     % SmtT/T = 0.0%, 0.0%, 0.0%
\hline
\multirow{9}{*}{{\rotatebox{90}{\textbf{Dist}}}}
& $\otimes$-!                 & \success{} &  {\highlight{$12.96 (\stderr{  0.48})$}} &   2       & \success{} &  32.28 (\stderr{  1.32}) &   2       & \success{} & 10487.92 (\stderr{  4.38}) &   7      \\ % SmtT/T = 96.84305139487837%, 99.16605247629178%, 99.98233353925326%
& $\otimes$-$\mathbb{N}$                  & \success{} &  {\highlight{$24.83 (\stderr{  1.01})$}} &   2       & \fail{}  &  32.18 (\stderr{  0.80}) &   2       & \fail{}  &  31.33 (\stderr{  0.65}) &   2      \\  % SmtT/T = 99.16249211706345%, 98.19366472714205%, 97.68400765522344
& $\otimes$-$\mathcal{R}$                  & \success{} &  {\highlight{$28.17 (\stderr{  1.01})$}} &   2       & \fail{}  &  29.72 (\stderr{  0.90}) &   2       & \fail{}  &  31.91 (\stderr{  1.02}) &   2      \\ % SmtT/T = 99.26176085615197%, 97.2013820814111%, 97.92618319348946%
& $\oplus$-!                & \success{} &   {\highlight{$7.87 (\stderr{  0.23})$}} &   2       & \success{} &  16.54 (\stderr{  0.43}) &   2       & \success{} & 160.65 (\stderr{  2.26}) &   4      \\ % SmtT/T = 96.52232766433309%, 96.54651122326587%, 99.69538508877449
& $\oplus$-$\mathbb{N}$                & \success{} &  {\highlight{$22.13 (\stderr{  0.70})$}} &   2       & \success{} &  30.30 (\stderr{  1.02}) &   2       & \fail{}  &  23.82 (\stderr{  1.13}) &   1      \\  % SmtT/T = 99.00528362933007%, 99.08548651040508%, 98.49944141606836%
& $\oplus$-$\mathcal{R}$                & \success{} &  {\highlight{$22.18 (\stderr{  0.60})$}} &   2       & \success{} &  31.24 (\stderr{  1.40}) &   2       & \fail{}  &  16.34 (\stderr{  0.40}) &   1      \\ % SmtT/T = 99.08179689945528%, 99.16435051551996%, 98.4221935356417%
& $\multimap$-!                & \success{} &   {\highlight{$6.53 (\stderr{  0.16})$}} &   2       & \success{} &  10.01 (\stderr{  0.25}) &   2       & \success{} & 342.52 (\stderr{  2.64}) &   4      \\% SmtT/T = 96.72718832940333%, 96.60077128502638%, 99.698687842732%
& $\multimap$-$\mathbb{N}$                  & \success{} &  29.16 (\stderr{  0.82}) &   2       & \success{} &  {\highlight{$28.71 (\stderr{  0.67})$}} &   2       & \fail{}  &  54.00 (\stderr{  1.53}) &   4      \\% SmtT/T = 99.14821593847735%, 99.13267964321408%, 99.00055370249412%
& $\multimap$-$\mathcal{R}$                  & \success{} &  29.31 (\stderr{  1.84}) &   2       & \success{} &  {\highlight{$27.44 (\stderr{  0.60})$}} &   2       & \fail{}  &  61.33 (\stderr{  2.28}) &   4      \\% SmtT/T = 99.22644411928067%, 99.20991868100477%, 99.01094953081872%
\hline
\multirow{4}{*}{{\rotatebox{90}{\textbf{Vec}}}}
& vec5                      & \success{} &   {\highlight{$4.72 (\stderr{  0.07})$}} &   1       & \success{} &  14.93 (\stderr{  0.21}) &   1       & \success{} &  78.90 (\stderr{  2.25}) &   6      \\% SmtT/T = 80.52034229302626%, 95.98937410635435%, 98.89325740352668%
& vec10                     & \success{} &   {\highlight{$5.51 (\stderr{  0.36})$}} &   1       & \success{} &  20.81 (\stderr{  0.77}) &   1       & \success{} & 142.87 (\stderr{  5.86}) &  11      \\  % SmtT/T = 57.23088868771888%, 91.78964923101526%, 98.76365835388931%
& vec15                     & \success{} &   {\highlight{$9.75 (\stderr{  0.25})$}} &   1       & \success{} &  22.09 (\stderr{  0.24}) &   1       & \success{} & 195.24 (\stderr{  3.20}) &  16      \\ % SmtT/T = 37.28829884651822%, 88.79604744779657%, 98.11179611018657%
& vec20                     & \success{} &  {\highlight{$13.40 (\stderr{  0.46})$}} &   1       & \success{} &  30.18 (\stderr{  0.20}) &   1       & \success{} & 269.52 (\stderr{  4.25}) &  21      \\ % SmtT/T = 25.881885439958207%, 82.374721744386%, 97.48691949245291%
\hline
\multirow{4}{*}{{\rotatebox{90}{\textbf{Misc}}}}
& split$\oplus$            & \success{} &   {\highlight{$3.79 (\stderr{  0.04})$}} &   1       & \success{} &   5.10 (\stderr{  0.16}) &   1       & \success{} & 10732.65 (\stderr{  8.01}) &   6      \\ % SmtT/T = 94.19385210967563%, 94.14708972520134%, 99.97155844397255%
& split$\otimes$                      & \success{} &  {\highlight{$14.07 (\stderr{  1.01})$}} &   3       & \success{} &  46.27 (\stderr{  2.04}) &   3       & \fail{} & Timeout & -                            \\ % SmtT/T = 87.40012646315907%, 97.15716368724911%
& share                     & \success{} & 292.02 (\stderr{ 11.37}) &  44       & \success{} & {\highlight{$100.85 (\stderr{  2.44})$}} &   6       & \success{} & 193.33 (\stderr{  4.46}) &  17      \\ % SmtT/T = 94.3058504587738%, 97.15508002763923%, 99.19701142373343%
& exm.~\ref{exm:security}                 & \success{} &   {\highlight{$8.09 (\stderr{  0.46})$}} &   2       & \success{} &  26.03 (\stderr{  1.21}) &   2       & \success{} & 284.76 (\stderr{  0.31}) &   3      \\ % SmtT/T = 96.70245619318075%, 99.14227225428877%, 99.83905641669199%
\end{tabular}
\end{center}}}

\caption{Results. $\mu{T}$ in \emph{ms} to 2 d.p.
with standard sample error in brackets}
\label{tab:results}
\vspace{-2.5em}
\end{table}



\paragraph{Additive versus subtractive}
As expected, the additive approach generally synthesises programs faster
than the subtractive. Our first hypothesis (that the additive approach in general
makes fewer calls to the SMT solver) holds for almost all benchmarks, with the
subtractive approach often far exceeding the number made by the additive. This is explained by
the difference in graded variable synthesis between approaches. In the
additive, a constant grade $1$ is given for graded assumptions in the output
context, whereas in the subtractive, a fresh grade
variable is created with a constraint on its usage which
is checked immediately. As the
total synthesis time is almost entirely spent in the SMT solver (more than 90\%), solving constraints is by far the most costly part of synthesis
leading to the additive approach synthesising most examples in a shorter amount of time.

Graded variable synthesis in the subtractive case also results
in several examples failing to synthesise. In some cases, e.g.,
the first three \textit{comp} benchmarks, the subtractive approach
times-out as synthesis diverges with constraints growing in size
due to the maximality condition and absorbing behaviour of
$[[ Intrv 0 Inf ]]$ interval. In the case of $\textit{coK-$\mathcal{R}$}$
and $\textit{coK-$\mathbb{N}$}$, the generated constraints
have the form $\forall r. \exists s. r \sqsupseteq s + 1 $ which
is not valid $\forall r \in \mathbb{N}$ (e.g., when $r = 0$),
which suggests that the subtractive approach does not work well for
polymorphic grades. As further work, we are
considering an alternate rule for synthesising promotion with
constraints of the form $\exists s . s = s' * r$, i.e.,
a multiplicative inverse constraint.
%solving approach cannot tell this holds for all semirings. Indeed, it
%is false for $\ma
%which is not satisfiable for all semirings, including \textsc{N}, causing examples
%with arbitrary \textsc{N} grades to also fail.

In more complex examples we see evidence to support
our second hypothesis. The \textit{share} problem requires a lot
of graded variable synthesis which is problematic for the additive
approach, for the reasons described in the second hypothesis. In contrast, the subtractive approach
performs better, with $\mu{T} = 193.3\textit{ms}$ as opposed to additive's
$292.02\textit{ms}$. However, additive pruning outperforms both.

% Not as important
%Notably, on examples which are purely linear such as \textit{andElim} from
%Hilbert's axioms or \textit{mult} for function composition, the subtractive
%approach generally performs better. Linear programs without graded modalities
%can be synthesised without the need to interface with Z3 at all, making the
%differences here somewhat negligible as solver time generally makes up for the
%vast proportion of total synthesis time.

\paragraph{Additive pruning}
The pruning variant of additive synthesis (where subtraction
takes place in the premises of multiplicative rules) had mixed results
compared to the default. In simpler examples, the overhead of pruning
(requiring SMT solving) outweighs
the benefits obtained from reducing the space. However, in more
complex examples which involve synthesising many graded variables (e.g. \textit{share}), pruning is
especially powerful, performing better than the subtractive
approach. However, additive pruning failed to synthesis two
 examples which are polymorphic in their grade
 ($\otimes$-$\mathbb{N}$) and in the semiring/graded-modality ($\otimes$-$\mathcal{R}$).


Overall, the additive approach outperforms the subtractive and is
successful at synthesising more examples, including ones polymorphic
in grades and even the semiring itself. Given that the literature on linear logic theorem proving
is typically subtractive, this is an interesting result. Going forward, we will focus on the additive
scheme. 
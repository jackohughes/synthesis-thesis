We present two linear-base synthesis calculi with subtractive and additive resource
management schemes, extending an input-output context management approach to graded
modal types. The structure of the synthesis calculi mirrors a
cut-free sequent calculus, with
\textit{left} and \textit{right} rules for each type constructor. Right rules
synthesise an introduction form for the goal type. Left rules
eliminate (deconstruct) assumptions so that they may be
used inductively to synthesise subterms. Each type in the
core language has right and left
rules corresponding to its constructors and destructors respectively.


\begin{figure}[H]
\begin{align*}
\hspace{-0.5em}
  \begin{array}{c}
    \subLinVar
    \,
    \subGrVar
    \\[0.5em]
    \subAbs
    \\[0.5em]
    \subApp
    \\[0.5em]
    \subDer
    \\[0.5em]
    \subBox
    \,
    \subUnbox
    \\[0.5em]
    \subPairIntro
    \\[0.5em]
    \subPairElim
    \\[0.5em]
    \subSumIntroL
    \,
    \subSumIntroR
    \\[0.5em]
    \subSumElim
    \\[0.5em]
    \subUnitIntro
    \,
    \subUnitElim
  \end{array}
\end{align*}
\caption{Collected rules of the subtractive synthesis calculus}
\label{fig:sub-rules}
  \end{figure}



\subsection{Subtractive Resource Management}
  Our subtractive approach follows the philosophy of earlier work on
  linear logic proof search~\cite{HODAS1994327,CERVESATO2000133},
  structuring synthesis rules around an input context of the available
  resources and an output context of the remaining resources that
  can be used to synthesise subsequent subterms. Synthesis rules
  are read bottom-up, with judgments $\Gamma \vdash A \Rightarrow^{-} t\ |\ \Delta$
  meaning from the \emph{goal type} $[[A]]$ we can synthesise a term $[[t]]$ using
  assumptions in $[[G]]$, with output context $[[D]]$. We describe
  the rules in turn to aid understanding. Figure~\ref{fig:sub-rules} collects the
  rules for reference.


  \paragraph{Variables}
Variable terms can be synthesised from linear or graded assumptions by rules:
%
  \begin{align*}
  \subLinVar
  \;\;
  \subGrVar
  \end{align*}
%
On the left, a variable $[[x]]$ may be synthesised for the goal
$[[ A ]]$ if a linear assumption $[[ x : A ]]$ is present
  in the input context. The input context without $[[x]]$ is then returned as
  the output context, since $x$ has been used. On the right,
  we can synthesise a variable $x$ for $A$ we have a graded
  assumption of $x$ matching the type. However, % to synthesise $[[ x ]]$
  %it may be the case that
  %using $x$ violates the constraints placed by the assumption's grade. For example,
  %the input context may contain assumptions graded by 0, either because this was
  %specified by the type or the variable has been used as far as it's grade
  %permits already. For this reason, the ability to synthesise a
  %graded variable $[[x]]$
%  requires that $[[x]]$'s grade $r$ can be factored into some grade
%  $s + 1$
  the grading $[[ r ]]$ must permit $[[ x ]]$ to
  be used once here. Therefore, the premise states that there exists
  some grade $s$ such that grade $r$ approximates $s + 1$. The grade $s$
  represents the use of $x$ in the rest of the synthesised term, and
  thus $[[ x : [ A ] s ]]$ is in the output context. For the natural
  numbers semiring, this constraint is satisfied by $s = r - 1$ whenever $r \neq
  0$, e.g., if $r = 3$ then $s = 2$. For
  intervals, the role of approximation is more apparent: if $r = [[
  Intrv 0 3]]$ then this rule is satisfied by $s = [[ Intrv 0 2 ]]$
  where $s + 1 = [[ Intrv 0 2 ]] + [[ Intrv 1 1 ]] = [[ Intrv 1 3 ]]
  \sqsubseteq [[ Intrv 0 3 ]]$.
  This is captured by the instantiation of a new
  existential variable representing the new grade for $[[x]]$ in the output
  context of the rule. In the natural numbers semiring, this could be done by
  simply subtracting $1$ from the assumption's
  existing grade $r$. However, as not all semirings have an
  additive inverse, this is instead handled via a constraint on the new grade
  $s$, requiring that $ r \sqsupseteq s + 1 $. In the implementation, the constraint is
  discharged via an SMT solver, where an unsatisfiable result terminates
  this branch of synthesis.

  \paragraph{Functions}
In typing, $\lambda$-abstraction binds linear variables to introduce
  linear functions. Synthesis from a linear function type therefore mirrors typing:
%
  \begin{align*}
\subAbs
    \end{align*}
%
  Thus, $\lambda x . t$ can be synthesised given that
  $t$ can be synthesised from $B$ in the context of $[[G]]$ extended with a fresh linear assumption $[[ x
  : A]]$. To ensure that $[[x]]$ is used linearly
  by $[[t]]$ we must therefore check that it is not present in
  $[[D]]$.

The left-rule for linear function types then synthesises applications
(as in~\cite{HODAS1994327}):
%
  \begin{align*}
    \subApp
    \end{align*}
%
  %The left rule equivalent of $\textsc{R}\multimap^{-}$ for
  %synthesising an abstraction is the rule for
  %synthesising an application $\textsc{L}\multimap^{+}$.
  The rule synthesises a term for type $[[ C ]]$ in a context that
  contains an assumption $[[ x1 : A -o B ]]$.
%
%, we can apply some value
%  of type $[[A]]$ to this to obtain a value of type $[[B]]$ to use in the
  %synthesis of $[[t1]]$ from the goal type $[[C]]$.
  The first premise synthesises a term $[[t1]]$ for $[[C]]$ under the context
  extended with a fresh linear assumption $[[x2
  : B]]$, i.e., assuming the result of $[[ x1 ]]$. This produces an output context $[[D1]]$ that must not contain
  $[[x2]]$, i.e., $[[x2]]$ is used by $[[t1]]$. The remaining
  assumptions $[[D1]]$ provide the input context to
  synthesise $[[t2]]$ of type $[[A]]$: the argument to the function $[[x1]]$. In the conclusion,
  the application $[[x1 t2]]$ is substituted for $[[x2]]$ inside
  $[[t1]]$, and $[[D2]]$ is the output context.

\paragraph{Dereliction} Note that the above rule synthesises the application of a
function given by a linear assumption. What if we have a graded
assumption of function type? Rather than duplicating every left rule
for both linear and graded assumptions, we mirror the
dereliction typing rule (converting a linear assumption to graded) as:
%
  \begin{align*}
    \subDer
    \end{align*}
%
  Dereliction captures the ability to reuse a graded assumption being
  considered in a left rule. A fresh linear assumption $[[y]]$ is generated that
  represents the graded assumption's use in a left rule, and must be used
  linearly in the subsequent synthesis of $[[t]]$. The output context of this premise then contains $[[x]]$ graded by $s'$, which reflects how $[[x]]$ was used in the synthesis of $[[t]]$, i.e. if $[[x]]$ was not used then $s' = s$. The premise $[[ exists s . r >= s + 1 ]]$ constrains the number of times dereliction can be applied so that it does not exceed $x$'s
  original grade $r$.

  \paragraph{Graded modalities}
  For a graded modal goal type $[[ [] r A ]]$, we synthesise a promotion
$[[ [ t ] ]]$ if we can synthesise the `unpromoted' $[[t]]$ from $[[A]]$:
%Synthesis of promoted values is captured by the
%  rule $\textsc{R}\square^{-}$.
  \begin{align*}
    \subBox
    \end{align*}
%
  A non-graded value $[[t]]$ may be promoted to a graded value using
  the box syntactic construct.
  Recall that typing of a promotion $[[ [ t ] ]]$
  scales all the graded assumptions used to type $[[ t ]]$ by $r$. Therefore,
  to compute the output context we must ``subtract'' $r$-times the use of the variables in $[[
  t ]]$. However, in the subtractive model $[[ D ]]$ tells us what is
  left, rather than what is used. Thus we first compute the
  \textit{context subtraction} of $[[G]]$ and $[[D]]$
  yielding the variables usage information about $[[ t ]]$:
 %
  \begin{definition}[Context subtraction]\label{def:contextSub}
  For all $[[ G1 ]], [[ G2 ]]$ where $ [[G2]] \subseteq [[G1]]$:
\begin{align*}
[[G1 - G2]] =
\left\{\!\begin{matrix}
\begin{array}{lll}
% Base case
[[G1]]
  & [[G2]] = \emptyset
\\[0.25em]
([[G1']], [[G1'']]) - [[G2']]
  & [[G2]] = [[ G2', x : A]] & \wedge\ [[G1]] = [[G1', x : A]], [[G1'']]
\\[0.25em]
(([[G1']], [[G1'']]) - [[G2']]), [[x : [A] q]]
  & [[ G2]] = [[G2', x : [A] s]] & \wedge\ [[G1]] = [[ G1',x : [A]
                                   r]],[[G1'']] \\[0em]
          & \wedge \ [[ exists q . r >= q + s]]
          & \!\! \wedge \ \maximal{q}{q'}{r}{q' + s}
\end{array}
\end{matrix}\right.
\end{align*}
%
\end{definition}
As in graded variable synthesis, context subtraction existentially quantifies a
variable $q$ to express the relationship
between grades on the right being ``subtracted'' from those on the
left. The last conjunct states
$q$ is the greatest element (wrt.
to the pre-order) satisfying this constraint, i.e., for all
other $q' \in \mathcal{R}$ satisfying the subtraction constraint
then $[[ q >= q']]$ e.g., if $r = [[ Intrv 2 3 ]]$
and $s = [[ Intrv 0 1]]$ then $q = [[ Intrv 2 2 ]]$ instead of, say,
$[[ Intrv 0 1]]$. This \emph{maximality} condition is
important for soundness (that synthesised programs are well-typed).
%, which does not satisfy
%maximality.

%There may be many such existentially quantified variables coming from
%a subtraction, and we sometimes write $\exists \Sigma . [[ G1 - G2 ]]$
%to denote the set $\Sigma$ of existential variables introduced by such
%a context subtraction.

Thus for \subBoxName, $[[ G - D ]]$ is multiplied by the goal type grade $r$ to obtain how these
  variables are used in $[[t]]$ after promotion. This is then subtracted from
  the original input context $[[G]]$ giving an output context
  containing the left-over variables and grades. Context
  multiplication
  requires that $[[G - D]]$ contains only graded variables,
  preventing the incorrect use of linear variables from $[[G]]$ in
  $[[t]]$.

Synthesis of graded modality elimination, is handled by the
  \subUnboxName\ left rule:
  \begin{align*}
    \subUnbox
    \end{align*}
%
  Given an input context comprising $[[ G ]]$ and a linear
  assumption $[[ x1 ]]$ of graded modal type, we can synthesise an unboxing of
  $[[x1]]$ if we can synthesise a term $[[t]]$ under $[[G]]$
  extended with a graded assumption $[[x2 : [A] r]]$. This returns an output
  context that must contain $[[x2]]$ graded by $s$
  with the constraint that $s$ must approximate $0$. This enforces
  that $x_2$ has been used as much as stated by the grade $r$.

\paragraph{Products}
The right rule for products \subPairIntroName\ behaves similarly to the
\subAppName\ rule, passing the entire input context $[[ G ]]$ to the first
premise. This is in then used to synthesise the first sub-term of the pair
$[[ t1 ]]$, yielding an output context $ [[ D1 ]]$, which is passed to the
second premise. After synthesising the second sub-term $[[ t2 ]]$, the output
context for this premise becomes the output context of the rule's conclusion.

The left rule equivalent \subPairElimName\  binds two assumptions
$[[ x1 : A ]]$ $[[ x2 : B ]]$ in the premise, representing the constituent sides
of the pair. As with \subAppName, we also ensure that these bound assumptions must not
present in the premise's output context $[[ D ]]$.

\begin{align*}
\begin{array}{c}
  \subPairIntro
\\[0.75em]
  \subPairElim
\end{array}
\end{align*}
\paragraph{Sums}
The \subSumElimName\ rule synthesises the left and
right branches of a case statement that may use resources
differently. The output context therefore takes the \textit{greatest
lower bound} ($\sqcap$) of $[[ D1 ]]$ and $[[ D2 ]]$, given by definition~\ref{def:context-glb},

\begin{definition}[Partial greatest-lower bounds of
  contexts]\label{def:context-glb}
For all $[[ G1 ]]$, $[[ G2 ]]$:
\begin{align*}
\label{def:lub}
[[G1]] \sqcap [[G2]] =
%%
\left\{\begin{matrix}
\begin{array}{lll}
%% Both empty case
\emptyset
  & [[ G1 ]] = \emptyset & \wedge \; [[ G2 ]] = \emptyset
\\
%
%% Left empty
(\emptyset \sqcap [[ G2' ]]), [[ x : [ A ] {glb 0 s} ]]
  & [[ G1 ]] = \emptyset & \wedge \; [[G2]] = [[ G2',x : [A] s]]
\\
%
%% Left is left linear
([[G1']] \sqcap [[(G2',G2'')]]), [[x : A]]
 & [[G1]] = [[{G1', x : A} ]] & \wedge \; [[ G2 ]] = [[ {G2', x : A}, G2'' ]]
\\
%
%% Left is graded
([[G1']] \sqcap [[(G2',G2'')]]), [[x : [A] {glb r s}]]\;\;
 & [[G1]] = [[ G1',x : [A] r]] & \wedge \; [[ G2 ]] = [[{G2', x : [A] s}, G2'']]
\end{array}
\end{matrix}\right.
\end{align*}
where $r\!\sqcap\!s$ is the greatest-lower bound of grades $[[r]]$
and $[[s]]$ if it exists, derived from $\sqsubseteq$.
\end{definition}
%
%
\begin{align*}
\begin{array}{c}
  \subSumIntroL
  \subSumIntroR
\\[0.75em]
  \subSumElim
\end{array}
\end{align*}

As an example of $\sqcap$, consider the semiring of intervals over natural numbers and two
judgements that could be used as premises for the (\subSumElimName) rule:
%
\begin{align*}
& [[ G, y : [A'] Intrv 0 5, x2 : A |- C =>- t1 ; y : [A'] Intrv 2 5 ]] \\
& [[ G, y : [A'] Intrv 0 5, x3 : B |- C =>- t2 ; y : [A'] Intrv 3 4 ]]
\end{align*}
%
where $t_1$ uses $y$ such that there are $2$-$5$ uses remaining
and $t_2$ uses $y$ such that there are $3$-$4$
uses left. To synthesise $\textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2}$
the output context must be pessimistic about what resources are left,
thus we take the greatest-lower bound yielding the interval $[
2\dots4 ]$ here: we know $y$ can be used at least twice and at most
$4$ times in the rest of the synthesised program.

\paragraph{Unit}
The right and left rules for units are then
self-explanatory following the subtractive resource model:
%
\begin{align*}
\begin{array}{c}
  \subUnitIntro
  \subUnitElim
\end{array}
\end{align*}

%

This completes subtractive synthesis. We conclude
with a key result, that synthesised terms are well-typed at the type from which they
were synthesised:
%
\begin{restatable}[Subtractive synthesis soundness]{lemma}{subSynthSound}
\label{lemma:subSynthSound}
For all $[[ G ]]$ and $[[ A ]]$
then:
\begin{align*}
[[ G |- A =>- t ; D ]] \quad \implies \quad [[ G - D |- t : A ]]
\end{align*}
i.e. $[[ t ]]$ has type $[[ A ]]$
under context $[[ G - D ]]$,
that contains just those linear and
graded variables with grades reflecting their use in $[[ t ]]$.
Appendix~\ref{sec:linear-proofs} provides the proof.
\end{restatable}
%
\iffalse
\subsubsection{Alternative promotion}
We consider an alternate synthesis for graded modal terms,
replacing (R$\square^{-}$) (repeated on the left) with an alternate
version (R${\square'^{-}}$):
%
  \begin{align*}
    \subBox
    \;\;
    \subBoxAlt
    \end{align*}
%
  In this rule, the input context to the
  premise consists of the context $[[G]]$ ``divided'' by the grade of the goal type
  $[[r]]$ where division is defined:
%
%\begin{definition}[Scalar context division]\label{def:contextDiv}
\begin{align*}
   [[ . / r ]] = [[ . ]]
    \qquad\qquad
  [[ (G , x : [ A ] s) / r ]] = [[ G' / r, x : [A] s' ]]\ where\ [[ exists s' . s'
  * r = s ]]
\end{align*}
%\end{definition}
  Similarly to context subtraction, context division existentially quantifies
  over a grade $s'$ to express the relationship between the grades
  in the context $[[G]]$ being ``divided'' by $r$. %Equations of the form
  %$[[ exists s' . s' * r = s]]$ may only be satisfiable if a
  %multiplicative inverse exists, requiring some constraint solving.
  The output context for the synthesis of $[[t]]$ is then multiplied
  by $r$ in the conclusion of the rule. Such constraints require the
  SMT solver to compute a factorisation, which is typically expensive.
  Section~\ref{sec:evaluation} considers the cost implications, comparing
  performance of (R$\square^{-}$) versus (R${\square^{-}}'$).
\fi

\begin{figure}[H]
\begin{align*}
\begin{array}{c}
  \addLinVar
  \,
  \addGrVar
\\[0.5em]
  \addDer
\\[0.5em]
  \addAbs
\\[0.5em]
  \addApp
\\[0.5em]
  \addBox
  \\[0.5em]
  \addUnbox
\\[0.5em]
  \addPairIntro
\\[0.5em]
  \addPairElim
\\[0.5em]
  \addSumIntroL
  \,
  \addSumIntroR
\\[0.5em]
  \addSumElim
\\[0.5em]
  \addUnitIntro
  \,
  \addUnitElim
      \end{array}
  \end{align*}
\caption{Collected rules of the additive synthesis calculus}
\label{fig:add-rules}
  \end{figure}

\subsection{Additive Resource Management}
We now present the dual to subtractive resource management --- the
\emph{additive} approach.
Additive synthesis also uses the input-output context approach, but where
output contexts describe exactly which assumptions were used to synthesise
a term, rather than which assumptions are still available. Additive
   synthesis rules are read bottom-up, with $[[G |- A =>+ t; D]]$
  meaning that from the type $[[A]]$ we synthesise a term $[[t]]$ using
  exactly the assumptions $[[D]]$ that originate from the input
  context $[[G]]$.

  \paragraph{Variables}
  We unpack the rules, starting with variables:
%
\begin{align*}
  \addLinVar
  \addGrVar
  \end{align*}
%
For a linear assumption, the output context contains
just the variable that was synthesised. For a graded assumption $[[x : [A] r]]$, the output
context contains the assumption graded by $1$. To synthesise a
variable from a graded assumption, we must check that the use is
compatible with the grade.

\paragraph{Graded modalities}
The subtractive approach handled the \textsc{GrVar$^{-}$}
by a constraint $[[ exists s . r >= s + 1]]$. Here however, the
point at which we check that a graded assumption has been used
according to the grade takes place in the \addUnboxName rule, where graded
assumptions are bound:
%
\begin{align*}
  \addUnbox
  \end{align*}
%
Here, $[[t]]$ is synthesised under a fresh graded assumption
$[[ x2 : [A] r]]$. This produces an output context containing $[[x2]]$ with
some grade $s$ that describes how $[[x2]]$ is used in $[[t]]$. An
additional premise requires that the original grade $r$ approximates either $s$
if $[[x2]]$ appears in $[[D]]$ or $0$ if it does not,
ensuring that $[[x2]]$ has been used correctly. For the
$\mathbb{N}$-semiring with equality as the ordering, this would
ensure that a variable has been used exactly the number of times
specified by the grade.

The synthesis of a promotion is considerably simpler in the additive
approach. In subtractive resource management it was necessary to calculate how
resources were used in the synthesis of $[[t]]$ before then applying the
scalar context multiplication by the grade $r$ and subtracting this from the
original input $[[G]]$. In additive resource management, however, we can simply
apply the multiplication directly to the output context $[[D]]$ to obtain how
our assumptions are used in $[[ [t] ]]$:
%
\begin{align*}
  \addBox
\end{align*}

\paragraph{Functions}
Right and left rules for $\multimap$ have a similar shape to the
subtractive calculus:
%
\begin{align*}
\begin{array}{c}
\addAbs
\\[0.8em]
\addApp
\end{array}
\end{align*}
%
Synthesising an abstraction (\addAbsName) requires that $[[x : A]]$ is in
the output context of the premise, ensuring that linearity is preserved.
Likewise for application (\addAppName), the output
context of the first premise must contain the linearly bound $[[x2 :
B]]$ and the final output context must contain the assumption being used in the
application $[[ x1 : A -o B ]]$. This output context computes the \emph{context
addition} (Def.~\ref{def:contextAdd}) of both output contexts of the premises $[[D1 + D2]]$. If $[[D1]]$
describes how assumptions were used in $[[t1]]$ and $[[D2]]$ respectively for
$[[t2]]$, then the addition of these two contexts describes the usage of
assumptions for the entire subprogram. Recall, context addition
ensures that a linear assumption may not appear in both $[[D1]]$ and
$[[D2]]$, preventing us from synthesising terms that violate linearity.



\paragraph{Dereliction}
As in the subtractive calculus,
%the additive equivalent of dereliction ($\textsc{Der}$) also allows us to
%reuse graded assumptions in a left rule:
we avoid duplicating left rules to
match graded assumptions by giving a synthesising version of dereliction:
\begin{align*}
  \addDer
  \end{align*}
%
The fresh linear assumption $[[ y : A ]]$ must
appear in the output context of the premise, ensuring it is used. The final
context therefore adds to $[[ D ]]$ an assumption of $[[x]]$ graded by
$1$, accounting for this use of $[[ x ]]$ (temporarily renamed to
$y$).

\paragraph{Products}
The right rule for products \addPairIntroName\ follows the same structure as its
subtractive equivalent, however, here $[[ G ]]$ is passed to both premises.
The conclusion's output context is then formed by taking the context addition of
the $[[ D1 ]]$ and $[[ D2 ]]$. The left rule, \addPairElimName\ follows fairly
straightforwardly from the resource scheme.
\begin{align*}
\begin{array}{c}
  \addPairIntro
\\[0.8em]
  \addPairElim
\end{array}
  \end{align*}

\paragraph{Sums}
In contrast to the subtractive rule, the rule \addSumElimName\ takes the least-upper bound of
the premise's output contexts (see definition~\ref{def:context-lub}). Otherwise,
the right and left rules for synthesising programs from sum types are straightforward.
\begin{align*}
\begin{array}{c}
  \addSumIntroL
  \addSumIntroR
\\[0.8em]
{\small{\!\!\addSumElim}}
\end{array}
  \end{align*}

\paragraph{Unit}
As in the subtractive approach, the right and left rules for unit types, are
as expected.
\begin{align*}
\begin{array}{c}
  \addUnitIntro
  \addUnitElim
\end{array}
  \end{align*}


  Thus concludes the rules for additive synthesis. As with subtractive, we
  have prove that this calculus is sound.
  \begin{restatable}[Additive synthesis soundness]{lemma}{addSynthSound}
\label{lemma:addSynthSound} For all $[[ G ]]$ and $[[ A ]]$:
%
\begin{align*}
[[ G |- A =>+ t ; D ]] \quad \implies \quad [[ D |- t : A ]]
\end{align*}
Appendix~\ref{sec:soundness-proofs} gives the proof.
\end{restatable}
Thus, the synthesised term $[[ t ]]$ is well-typed
at $[[ A ]]$ using only the assumptions $[[ D ]]$.
, where $[[D]]$ is a
subset of $[[G]]$.
i.e., synthesised terms are well typed at the type from which they
were synthesised.

\subsubsection{Additive pruning}
%
As seen above, the additive approach delays checking
whether a variable is used according to its linearity/grade
until it is bound. We hypothesise that this can lead additive synthesis to explore
many ultimately ill-typed (or \emph{ill-resourced})
paths for too long. Subsequently, we define a ``pruning''
variant of any additive rules with multiple sequenced
premises. For \addPairIntroName\ this is:
%
\begin{align*}
  \begin{array}{c}
    \addPrunePairIntro
  \end{array}
\end{align*}
%
Instead of passing $[[G]]$ to both
premises, $[[G]]$ is the input only for
the first premise. This premise outputs context $[[D1]]$ that
is subtracted from $[[G]]$ to give the input context
of the second premise. This provides an opportunity to
terminate the current branch of synthesis early if $[[ G - D1
]]$ does not contain the necessary resources to attempt the
second premise.
The \addAppName\ rule is similarly adjusted:

\begin{align*}
  \begin{array}{c}
    \addPruneApp
  \end{array}
\end{align*}

\begin{restatable}[Additive pruning synthesis soundness]{lemma}{addPruningSynthSound}
\label{lemma:addPruningSynthSound} For all $[[ G ]]$ and $[[ A ]]$:
%
\begin{align*}
[[ G |- A =>+ t ; D ]] \quad \implies \quad [[ D |- t : A ]]
\end{align*}
Appendix~\ref{sec:soundness-proofs} gives the proof.
\end{restatable}
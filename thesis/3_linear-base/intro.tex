We begin our journey into resourceful program synthesis with a synthesis system
for a linear type system with graded modalities, based on the linear graded
$\lambda$-calculus introduced in~\ref{sec:linear-base}. The aim of this chapter
is two-fold: as well as outlining a synthesis tool for a linear-base type
system, we introduce the problem of \textit{resource mangement}. We therefore
opt for a type system which is as minimal as possible. Instead, this chapter
focuses on introducing the core concepts of resourceful program synthesis. More
expressive language features are considered in chapter~\ref{}. 

Type-directed program synthesis is an inversion of type checking. In
type checking, we have typically have a judgement of the form: 
\begin{align*}
    \Gamma \vdash t : A {\small{\tag{type checking}}}
\end{align*}
stating that under some context of assumptions $\Gamma$ we can assing the 
program term $t$ the type $A$. Here, $\Gamma$ and $t$ are ``inputs'' to the
judgement, while the type $A$ is the ``output'', derived from the information
contained by the inputs. In synhtesis, we instead have:
\begin{align*}
    \Gamma \vdash A \Rightarrow t {\small{\tag{synthesis}}}
\end{align*}
This judgement states that, using the assumptions in $\Gamma$, we can construct
a program term $t$ from the type $A$, with $\Gamma$ and $A$ acting as the inputs
to the judgement, and $t$ as the output. Synthesis then becomes a task of
inductively synthesising programs in a ``bottom-up'' way: the goal type $A$ is
broken into sub-goals, from which sub-terms are synthesised until we are left
with a complete program (or synthesis times out). This is the essence of
type-directed program synthesis. 

Program synthesis with resourceful types, such as linear and graded modal types,
introduces an additional concern though: how do we ensure that the assumptions
in $\Gamma$ are used according to their resource constraints in synthesis of
$t$? This is known as the \textit{resource management} problem. 
This is . Section~\ref{} provides a
detailed description of the resource management problem and introduces two
potential solutions based on an approach first proposed by Hodas and Miller for
proof search in Linear Logic proof search.

To do this we must overcome the problem of \textit{resource management}. This
issue was touched on in~\ref{chapter:intro}. In
section~\ref{sec:resource-management}, we expand on the problem and provide an
overview of its history. We identify two approaches to resource
management named \textit{additive} and \textit{subtractive}, and implement a
synthesis calculus for both in section~\ref{sec:core-synth-calculi}. Both
approaches follow a similar structure; inverting the typing rules to derive a
a set of synthesis rules, yet they differ significantly in how resources are
managed.

To adress this resource management problem, we extend our linear graded
$\lambda$-calculus with multiplicative products, additive co-products, and a
multiplicative unit type. These additions, while comprising only a fragment of the full
expressivity of Granule, each pose different challenges with regard to resource
management in synthesis. Section~\ref{sec:linear-base-calculus} provides the
syntax, typing rules, and detailed descriptions of these new features.

Having outlined both a suitable target language and an approach to dealing with
the issue of resource management, we are then in a position to describe a
synthesis algorithm for our target language. This approach is described in
detail in section~\ref{}. We opt for a comparative approach: which of . 

These differences carry implications with regard to performance and
implementation. Both the subtractive and additive calculi are implemented as
part of a synthesis tool for Granule~\footnote{}. The implementation of the
rules themselves is mostly straightforward, leading us to elide most of the
details. However, we highlight an important optimisation technique in
section~\ref{}: focusing. Focusing removes much of the uneccessary
non-determinism that result from a direct implementation of our synthesis rules
by fixing and ordering on when rules can be applied. We present two ``focused''
forms of our original calculi which form the basis of our Granule
implementation.

By the end of this chapter, we will have outlined the design and implementation
of fully usable program synthesis tool for Granule~\footnote{}. While the
expressivity of this tool is limited, it lays the theoretical groundwork for the
complete synthesis tool for fully graded languages in chapter~\ref{}. 
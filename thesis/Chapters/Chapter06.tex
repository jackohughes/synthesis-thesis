\chapter{Conclusion}
\label{chapter:conclusion}
In this dissertation, we have provided a framework for designing program
synthesis tool based on linear and graded type systems, overcoming the
challenges imposed by treating program values as resources, and leveraging the
type systems' properties to build two efficient synthesis tools, targeting two
common flavours of graded type system. In summary, in our work we have succeeded
in: 
\begin{itemize}
    \item Building several core calculi for a two varieties of quantitative type
          systems, encompassing the major approaches in the literature, with
          both styles differing in expressivity and imposing unique
          requirements. 
    \item Implementing these synthesis calculi as tools for Granule, as fully integrated 
          components of the Granule toolchain. 
    \item Evaluating each of these systems in a variety of criteria, our main
          result being that synthesis with graded types is an effective way of
          reducing the program synthesis search space.  
    \item Showing that programs require fewer examples than in a purely
          example-driven synthesis setting, such as \textsc{MYTH}. 
    \item Providing an alternative approach to generating graded combinators, based on a generic programming methodology. 
    \item Adapting our synthesis technique to Linear Haskell, showing the
          viability of our framework as a foundation for building synthesis
          tools for other quantitative type systems. 
    \item Proved the soundness of each of these systems, reasoning about the
          behavioural properties of our synthesis calculi. 
\end{itemize}

Essentially, we have shown that program synthesis from linear and graded types
is a feasible and effective approach to reducing the search space of a program
synthesis task. The expressivity of linear and graded types in describing the
static semantics of a program is highly valued by many programmers, so
harnessing this expressivity in synthesis is a something that we find will be
useful to programs in this context, allowing the synthesis of programs often without
the need for additional specification such as examples.

There remain many avenues for future exploration, which intend to pursue, and
hope that others will also find use in this approach when designing synthesis
tools for their own type systems. 

\section{Future Directions}
\label{section:future}

Our goal was to create a program synthesis tool for Granule which assists the
programmer in writing programs with resource-sensitive types. We intend to
pursue further improvements to our tool which serve this end, including reducing
the overhead of SMT solving, integrating examples into the search algorithm
itself in the style of \textsc{Myth}~\citep{oseraMYTH1} and
Leon~\citep{10.1145/2509136.2509555}, as well as considering possible
semiring-dependent optimisations that may be applicable.

\subsection{Subtractive Resource Management}
Ultimately, we opted to focus on the additive resource management scheme for
Chapter~\ref{chapter:extended} due to concerns regarding the efficiency of its
implementation for a fully graded typing calculus.

In the subtractive scheme, the $\textsc{Var}$ rule generates a constraint which
determines if the use of a variable is permissible based on the rest of the
partially synthesised program:
\begin{align*}
  \inferrule*[Right=Var]
  {\exists s .\ r \sqsupseteq s + 1}
  {\Gamma, x :_{r} A \vdash A \Rightarrow x\ |\ \Gamma, x :_{s} A}
\end{align*}
i.e., $r$ must overapproximate one use of $x$ plus the future use of
$x$ given by the existential $s$.

Our comparative evaluation of the additive and subtractive schemes in
Section~\ref{sec:linear-base-evaluation} showed that these, and other associated
constraints from the subtractive approach, are larger, typically more complex,
and are discharged more frequently than their counterparts in the additive
system (every time a variable usage is being considered in the above case).
Their evaluation concluded that the only situation where subtractive decisively
outperformed additive was on purely linear programs. This, coupled with the fact
that the subtractive approach has limitations in the presence of polymorphic
grades, influenced our decision to adopt the additive scheme, especially as we
considered much more complex programs than in the calculi of
Chapter~\ref{chapter:core}, e.g., targeting recursion.


\subsection{SMT Solving}
Related to the above, there is scope for improving the interaction between the
synthesis tool and the SMT solver, to make synthesis more efficient. Both
evaluations showed that the bulk of synthesis time is spent solving constraints
in the SMT solver. Making this interaction more streamlined is therefore
particularly appealing. One approach would be to run an ``online'' SMT solving
procedure. This would reduce the overhead of discharging constraints to the
solver by eliminating the need to re-solve already solved constraints. 

Alternatively, one could imagine implementing custom solvers for the more
commonly used semirings. From our lists of benchmarking examples in
Tables~\ref{fig:list-of-types} and~\ref{tab:problems}, we can see the natural
number, and intervals over the natural numbers semirings appear frequently, more
than any other semiring. An SMT solver which focuses purely on solving in these
semirings, sacrificing the generality provided by solvers such as Z3~\citep{z3},
may be a worthwhile avenue of exploration. 


\subsection{Generalised Algebraic Data Types}
A logical next step is to incorporate GADTs (Generalised ADTs),
i.e., indexed types,  into the synthesis algorithm.
Granule provides support for user-defined GADTs, and the interaction
between grades and type indices is a key contributor to Granule's expressive power~\citep{DBLP:journals/pacmpl/OrchardLE19}.
Consider our list type benchmarks for example. In most cases, when we want to
synthesise a recursive function definition which takes a list as input, we have
to give the list a $0..\infty$ interval grade to account for potentially unlimited
usage. Take for example the \granin{map} benchmark:
\begin{granule}
map : forall a b . (a % 1..$\infty$ -> b) % 0..$\infty$ -> List a % 1..$\infty$ -> List b
spec
    map % 0..$\infty$
map = ?
\end{granule}
With indexed types, we can be much more precise. Consider a size-indexed vector type,
defined as:
\begin{granule}
data Vec (n : Nat) t where
  Nil  : Vec 0 t;
  Cons : t -> Vec n t -> Vec (n+1) t
\end{granule}
%
The corresponding \granin{map} function
can be given a much tighter specification, connecting the usage of the
input function to the length of the vector, from which we could
synthesise the program:
\begin{granule}
vmap : forall {a b : Type, n : Nat} . (a -> b) %n -> Vec n a -> Vec n b
spec
    vmap % n
vmap f Nil = Nil;
vmap f (Cons x xs) = Cons (f x) (vmap f xs)
\end{granule}
The latter type not only provides us with a greater opportunity to prune
grade-violating programs, its type is also much more descriptive of the user's intent.
Adapting our approach to GADTs is future work, and mostly consists of extending
the typing for our synthesis rule for \textbf{case} statements to handle GADT specialisation.

GADTs are sometimes referred to as \emph{lightweight} dependent types. Dependent
type systems allow arbitrary program properties to be expressed and verified
during type checking, with types being indexed by arbitrary program terms.
Several works have endeavoured to integrate fully-dependent types into a
quantitative setting~\citep{DBLP:journals/pacmpl/ChoudhuryEEW21,
10.1145/3607862, McBride2016, 10.1145/2676726.2676969}. One such
examples,~\citet{DBLP:conf/esop/MoonEO21}'s \textsc{GERTY}, is based on Granule
and has a prototype implementation, making it a particularly appealing target
for experimenting with the synthesis in a fully-dependent graded setting, using
the foundations laid by the work in this thesis.


\subsection{Large Language Models}
With the rise in LLMs (Large Language Models) showing their power at program
synthesis tasks~\citep{DBLP:journals/corr/abs-2108-07732,jain2021jigsaw}, the
deductive approach still has something to contribute: it provides
correct-by-construction synthesis based on specifications, rather than predicted
programs which may violate more fine-grained type constraints (e.g., as provided
by grades). Future approaches may combine both LLM approaches with deductive
approaches, where the logical engine of the deductive approach can guide
prediction. Exploring this is further work and a general opportunity and
challenge for the deductive synthesis community.


\section{Final Remarks}
Type-directed program synthesis has been long been an attractive field in
computer science partially due to the potential it offers: the ability to write
programs that are correct by construction, with significant help from the
computer. 

We feel that type-directed program synthesis complements linear and graded types
very well: as richer types further constrain the number of possible inhabitants,
theoretically there is less work to be done by the computer to identify the
program which behaves according to the user's intent.

Programming with linear and graded types can require significantly more
forethought than standard functional programming, and programs which seem
correct at first glance to a user might actually be resource-violating. Our hope
is that the tools developed in this work may be useful in reducing this
cognitive overhead, and that the ideas we have developed may be useful to those
in both the program synthesis, and the quantitative types communities.
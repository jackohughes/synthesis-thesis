\chapter{Background}
\label{chapter:background}
Before diving straight into designing program synthesis calculi, we first need
to formally define our target languages. We take
this chapter as an opportunity to do so, and to examine more closely some
of the properties of these linear and graded systems. 

Since \citet{girard1987linear}'s original work on Linear Logic,
the development of type systems which convey additional information about the
program's structure has evolved into a distinct paradigm, culminating in recent
years with the notion of \textit{graded types}. Approaches to graded type
systems run the gamut, incorporating a wide range of effect and coeffect
systems, however, they can typically be distilled into two categories, with
distinct lineages: 
\begin{itemize}
  \item Systems where a graded modal type operator introduces and eliminates
        graded modalities above some existing type system. This is the default
        approach of Granule, where the underlying type system is linear, and
        grade modalities are introduced and eliminated via the $\Box$ modal type
        operator.
  \item Systems where grades permeate the program, and are introduced via
        annotations on function arrows. This is the approach taken by Linear
        Haskell~\citep{DBLP:journals/pacmpl/BernardyBNJS18}, where grades (or
        ``multiplicities'') are specified using the \granin{\%} operator. 
\end{itemize}  
These two different styles to graded types mirror the dual development of effect
systems and graded monadic systems in the literature. In the latter case, the
two were eventually found to be equivalent, while the same treatment for the
former remains ongoing work. 

\section{Terminology}
Throughout this thesis we will tend towards using a \textit{types-and-programs}
terminology rather than \textit{propositions-and-proofs}. Via the Curry-Howard
correspondence, one can switch smoothly to viewing our approach to program
synthesis as proof search in logic.

The functional programming languages we discuss are presented as typed
calculi given by sets of \textit{types}, \textit{terms} (programs), and \textit{typing
 rules} that relate a term to its type. The most well-known typed
calculus is the simply-typed $\lambda$-calculus (STLC), which corresponds to
intuitionistic logic. We assume familiarity with STLC, and 
couch our explanation of linear and graded types in this context.

A \textit{judgment} defines the typing relation between a type and a term based on a
\textit{context}. In STLC, judgments have the
form: $\Gamma \vdash t : A$, stating that under some context of
\textit{assumptions} $\Gamma$ the program term $t$ can be assigned the type $A$.
An assumption is a name with an associated type, written $x : A$ and
corresponds to an in-scope variable in a program.

A term can be related to a type if we can derive a valid judgment through the
application of typing rules. The application of these rules forms a tree
structure known as a \textit{typing derivation}.

\section{Linear and Substructural Logics}
Linear logic was introduced as a way of being more descriptive
about the properties of a derivation in intuitionistic logic. In type systems
such as STLC, the properties of
\textit{weakening}, \textit{contraction}, and \textit{exchange} are assumed
implicitly. These are typing rules which are \textit{structural} as they
determine how the context may be used rather than being directed by the syntax.
Weakening is a rule which allows terms that are not needed in a typing
derivation to be discarded. Contraction works as a dual to weakening, allowing
an assumption in the context to be used more than once. Finally, exchange allows
assumptions in a context to arbitrarily re-ordered. The rules themselves are provided
by Figure~\ref{fig:substructural}.

\begin{figure}[H]
  \begin{gather*}
  \begin{array}{c}
    \inferrule*[right=Weakening]{\Gamma \vdash t : B}{\Gamma, x : A \vdash t : B}
    \;\;\;\;
    \inferrule*[right=Contraction]{\Gamma, x : A, y : A \vdash t : B}{\Gamma, x : A \vdash t : B}
    \\[0.9em]
    \inferrule*[right=Exchange]{\Gamma_{1}, y : B, x : A, \Gamma_{2} \vdash t : C} {\Gamma_{1}, x : A, y : B, \Gamma_{2} \vdash t : C}
    \end{array}
  \end{gather*}
  \caption{Substructural rules for weakening, contraction, and exchange}
  \label{fig:substructural}
\end{figure}

Linear logic is thus known as a \textit{substructural} logic because it lacks
the weakening and contraction rules, while permitting exchange. The disallowance
of these rules means that in order to construct a typing derivation, each
assumption must be used exactly once: arbitrarily copying or discarding values
is disallowed, excluding a vast number of programs from being typeable. 

As one can imagine, the different combinations of permitted structural rules
yields various other substructural logics. Affine logic permits
exchange and weakening, but disallows contraction, resulting in system where
values may be used \emph{at most}  once. Relevant logic only disallows
weakening (\emph{at least} once), while Ordered logic disallows all
three (values must be used exactly once and in order).

\subsection{The Linear $\lambda$-Calculus}
\label{sec:linear-lambda-calc}
By only permitting the exchange structural rule, we can integrate
linear logic into STLC, yielding a \emph{linear}
$\lambda-$calculus. This provides us with a foundation for programming with
substructural logics, which we will later refine with graded types. 

The types of the linear $\lambda$-calculus are given by the grammar: 
\begin{align*}
  \hspace{-0.9em}[[ A ]] , [[ B ]] & ::=
         [[ A ]] \multimap [[ B ]]
  {\small{\tag{types}}}
\end{align*}
Like STLC, we have one type: the function type. Here, however, our function type
is a \emph{linear} function arrow (denoted by $\multimap$).\footnote{Although
Granule code uses $\rightarrow$ syntax rather than $\multimap$ for linear
functions for the sake of familiarity with standard functional languages}.

The syntax of terms is the same as STLC, given by:

\begin{align*}
  \hspace{-0.8em} [[ t ]] ::= \;
         & [[ x ]]
    \mid [[ \x . t ]]
    \mid [[ t1 t2 ]]
  {\small{\tag{terms}}}
\end{align*}

Typing judgments are of the form $[[ G |- t : A ]]$, where $[[ G ]]$ ranges over
contexts of assumptions:
\begin{equation*}
  [[ G ]] ::= \emptyset
  \mid [[ G , x : A ]]
\tag{contexts}
\end{equation*}
Thus, a context may be empty $\emptyset$, extended with a linear assumption $[[
x : A ]]$. Throughout, comma denotes disjoint context concatenation.

\begin{figure}[H]
\begin{gather*}
    \begin{array}{c}
\inferrule*[right = Var]
  {\;}
  {[[ x : A |- x : A ]]}
\\[1.25em]
\inferrule*[right = Abs]
{[[ G , x : A |- t : B ]]}
{[[ G |- \x . t : A -o B ]]}
\;\;\;\;
% \\[0.75em]
\inferrule*[right = App]
{[[ G1 |- t1 : A -o B ]] \;\;\;
 [[ G2 |- t2 : A ]] }
{[[ G1 + G2 |- t1 t2 : B ]]}
\end{array}
\end{gather*}
\caption{Typing rules for the linear $\lambda$-calculus}
\label{fig:lin-lambda-calc}
\end{figure}
Figure~\ref{fig:lin-lambda-calc} defines the typing rules. Linear variables are
typed in a singleton context (\textsc{Var}). Abstraction (\textsc{Abs}) binds a
fresh linear variable which is used to type the premise. Application
(\textsc{App}) combines the usages across both premises through the use of
\textit{context addition}~\eqref{def:contextAdd}. Context addition provides an analogue to
contraction, combining contexts that have come from typing multiple sub-terms in
a rule. Context addition, written $[[ G1 + G2]]$, is undefined if $[[ G1 ]]$ and
$[[ G2 ]]$ overlap in their assumptions, i.e. a linear assumption may not appear in both 
sides of the addition. 
\begin{definition}[Linear context addition]\label{def:contextAddLin}
  \begin{align*}
      \setlength{\arraycolsep}{0.1em}
      \begin{array}{rl}
        [[ G + . ]] & = [[ G ]] \\ 
        [[ . + G ]] & = [[ G ]] \\
      [[ (G, x : A) + G' ]] & = [[ (G + G'), x : A ]] \quad \text{iff} \,\; x
      \not\in | [[ G' ]] | \\
      [[ G + (G', x : A) ]] & = [[ (G + G'), x : A ]] \quad \text{iff} \,\; x \not\in | [[ G]] | 
      \end{array}
  \end{align*}
\end{definition}

This leaves us with a very simple resourceful typing calculus, which serves as
the building block for further refinement.

\section{From Linearity to Grades}

Now that we have seen the linear $\lambda$-calculus itself, we are ready to
generalise the notion of data as a resource inside a program, and formally
define a graded type system. We now present two calculi, each based on the
differing view of graded types mentioned at the top of this chapter. The first
directly follows from the calculus in~\ref{sec:linear-lambda-calc}, merely
extending it with a \emph{graded modal type}. The second reflects the other
approach to graded type systems, where we do away with the underlying linear
structure. 

\subsection{The Graded Linear $\lambda$-calculus}
\label{sec:linear-base}
We now define a core type system, based on the linear $\lambda$-calculus of
section~\ref{sec:linear-lambda-calc}, extended with a graded modal type. This
calculus is equivalent to the core calculus of Granule,
\textsc{GrMini}~\citep{DBLP:journals/pacmpl/OrchardLE19}. Granule's full type
system extends this graded linear core with polymorphism, algebraic data types,
indexed types, pattern matching, and recursion. We refer to the system in this
section as the \textit{graded linear $\lambda$-calculus}, reflecting the
underlying linear structure of the system.

This system forms the basis of the target language for our synthesis tool in
Chapter~\ref{chapter:core}, although we extend it with some basic types for 
increased expressivity.

The types of the graded linear $\lambda$-calculus are given by:
\begin{align*}
\hspace{-0.9em}[[ A ]] , [[ B ]] & ::=
       [[ A ]] \multimap [[ B ]]
  \mid [[ [] r A ]]
{\small{\tag{types}}}
\end{align*}
where the type $\Box_{r} A$ is an indexed family of type operators where $r$ is
a \textit{grade} ranging over the elements of a pre-ordered semiring
$({\mathcal{R}}, {*}, {1}, {+}, {0}, {\sqsubseteq})$ parametrising the calculus
(where $\ast$ and $+$ are monotonic with respect to the pre-order
$\sqsubseteq$). 
The syntax of terms provides the elimination and introduction
forms:
\begin{align*}
\hspace{-0.8em} [[ t ]] ::= \;
       & [[ x ]]
  \mid [[ \x . t ]]
  \mid [[ t1 t2 ]]
  \mid [[ [t] ]]
  \mid [[ let [ x ] = t1 in t2 ]]
{\small{\tag{terms}}}
\end{align*}
In addition the the terms of the linear $\lambda$-calculus, we also have the
construct $[[ [t] ]]$ which introduces a graded modal type $[[ [] r A
]]$ by `promoting' a term $t$ to the graded modality, and it's dual $[[ let [x] = t1
in t2 ]]$ eliminates a graded modal value $[[ t1 ]]$, binding a graded variable $x$
in scope of $[[ t2 ]]$. The typing rules relate these terms to types.

As before, typing judgments are of the form $[[ G |- t : A ]]$, where $[[ G ]]$ ranges over contexts:
\begin{equation*}
  [[ G ]] ::= \emptyset
  \mid [[ G , x : A ]]
  \mid [[ G , x : [ A ] r ]]
\tag{contexts}
\end{equation*}
Thus, a context may also be extended with a graded assumption $[[x : [A] r]]$.
For linear assumptions, structural rules of weakening and contraction are
disallowed. Graded assumptions may be used non-linearly according to the
constraints provided by their grade, the semiring element $r$. 

Various operations on contexts are used to capture non-linear data flow via
grading. As with the linear $\lambda$-calculus, context
addition~\eqref{def:contextAdd} combines the contexts used to provide multiple
sub-terms. However, our new definition includes an extra case for dealing with
graded assumptions appearing in both contexts, which are combined
via the semiring $+$ of their grades.

\begin{definition}[Graded linear context addition]\label{def:contextAdd}

\begin{gather*}
    \setlength{\arraycolsep}{0.1em}
    \begin{array}{rl}
        [[ G + . ]] & = [[ G ]] \\ 
        [[ . + G ]] & = [[ G ]] \\
    [[ (G, x : A) + G' ]] & = [[ (G + G'), x : A ]] \quad \text{iff} \,\; x
    \not\in | [[ G' ]] | \\
    [[ G + (G', x : A) ]] & = [[ (G + G'), x : A ]] \quad \text{iff} \,\; x \not\in | [[ G]] | \\
    [[ (G, x : [ A ] r) + (G', x : [ A ] s) ]] & = [[ (G + G'), x : [ A ] (r + s) ]]
    \end{array}
  \end{gather*}

Note that this is a declarative specification of context addition. Graded
assumptions may appear in any position in $\Gamma$ and $\Gamma'$ as witnessed by
the algorithmic specification where for all $[[ G1 ]], [[ G2 ]]$
  \emph{context addition} is defined
as follows by ordered cases matching inductively on the structure of
$[[ G2 ]]$, where $[[G1 + G2]] = $
\begin{align*}
\left\{\begin{matrix}
    \begin{array}{ll}
    [[G1]] &
     [[G2]] = \emptyset
             \\
      (([[G1']], [[G1'']]) + [[G2']]), [[x : [A] (r + s)]] \; &
[[ G2]] = [[G2', x : [A] s]] \wedge [[G1]] = [[ G1',x : [A] r]],[[G1'']]  \\
 ([[G1]] + [[G2']]), [[x : A]] & [[G2]] = [[G2', x : A]]\ \wedge\  [[x
                                  : A]] \notin [[ G1 ]]
    \end{array}
  \end{matrix}\right.
\end{align*}
\end{definition}

\begin{figure}[H]
\hspace{-0.5em}
\begin{align*}
\hspace{-0.5em}
  \begin{array}{c}
  \inferrule*[right = Var]
  {\;}
  {[[ x : A |- x : A ]]}
\;\;
  \inferrule*[right = Abs]
  {[[ G , x : A |- t : B ]]}
  {[[ G |- \x . t : A -o B ]]}
\\[1.25em]
  \inferrule*[right = App]
  {[[ G1 |- t1 : A -o B ]] \;\;\;
   [[ G2 |- t2 : A ]] }
  {[[ G1 + G2 |- t1 t2 : B ]]}
\\[1.25em]
 \inferrule*[right = Weak]
  {[[ G |- t : A ]]}
  {[[ G , {[ D , 0 ]} |- t : A ]]}
\;\;\;
\inferrule*[right = Der]
  {[[ G , x : A |- t : B ]]}
  {[[ G , x : [ A ] 1 |- t : B]]}
\\[1.25em]
\inferrule*[right = Approx]
{[[ {G, x : [A] r}, G' |- t : A ]] \quad r \sqsubseteq s }
{[[ {G, x : [A] s}, G' |- t : A ]]}
\\[1.25em]
\inferrule*[right = Pr]
  {[[ [ G ] |- t : A ]]}
  {[[ r * {[ G ]} |- [t] : [] r A ]]}
\;\;\;
\inferrule*[right = Let$\Box$]
  {[[ G1 |- t1 : [] r A ]] \;\;\;
   [[ G2, x : [ A ] r |- t2 : B ]] }
    {[[ G1 + G2 |- let [x] = t1 in t2 : B ]]}
\end{array}
\end{align*}
\vspace{-1.25em}
  \caption{Typing rules of the graded linear $\lambda$-calculus}
\label{fig:typing}
 \end{figure}


Figure~\ref{fig:typing} gives the typing rules. The $\textsc{Weak}$ rule
captures weakening of assumptions graded by $0$ (where $[[ [ D , 0 ] ]]$ denotes
a context containing only graded assumptions graded by $0$). Context addition
and \textsc{Weak} together therefore provide the rules of substructural rules of
contraction and weakening. Dereliction ($\textsc{Der}$), allows a linear
assumption to be converted to a graded assumption with grade $1$. Grade
approximation is captured by the $\textsc{Approx}$ rule, which allows a grade
$s$ to be converted to another grade $r$, providing that $r$
\textit{approximates} $s$, where the relation $\sqsubseteq$ is the pre-order
provided with the semiring. This relation is occasionally lifted pointwise to
contexts: we write $[[ G <<= G' ]]$ to mean that $[[ G' ]]$ overapproximates $[[
G ]]$ meaning that for all $[[ (x : [A] r) ]] \in [[ G ]]$ then $[[ (x : [A] r')
]] \in [[ G' ]]$ and $[[ r <<= r' ]]$.

Introduction and elimination of the graded modality
is provided by the $\textsc{Pr}$ and $\textsc{Let}$ rules respectively. The
$\textsc{Pr}$ rule propagates the grade $r$ to the assumptions through
\emph{scalar multiplication} of $[[G]]$ by $r$ where every assumption in $[[ G
]]$ must already be graded (written $[[ [ G ] ]]$ in the rule\footnote{$[[ [ G ]
]]$ here can be thought of as a partial operation on contexts, equivalent to the
identity when $[[ G ]]$ consists solely of graded assumptions, and undefined if it does not.}), given by Definition~\ref{def:scalar}.
%
%
\begin{definition}[Scalar context multiplication]
  \label{def:scalar}
 A context which consists solely of graded assumptions can be multiplied by a
 semiring grade $r \in \mathcal{R}$
\begin{align*}
   [[ r * . ]] = \emptyset
    \qquad\qquad
    [[ r * (G , x : [ A ] s) ]] = [[ (r * G), x : [ A ] (r * s) ]]
\end{align*}
\end{definition}

The $\textsc{Let}$ rule eliminates a graded modal value $[[ [] r A ]]$
into a graded assumption $[[ x : [ A ] r ]]$ with a matching
grade in the scope of the \textbf{let} body. This is also referred to as
``unboxing''.

We give an example of graded modalities using a graded modality indexed
by the semiring of natural numbers.

%SKI
\begin{example}
\label{ex:s-comb}
  The natural number semiring with discrete ordering $(\mathbb{N}, \ast, 1, +,
  0, \equiv)$ provides a graded modality that counts exactly how many times
  non-linear values are used. As an example, the \emph{S} combinator from
  the SKI system of combinatory logic is typed and defined:
% then2 : forall {a b c : Type} . (a -> (b -> c)) -> (a -> b) -> (a
% [2] -> c)
\begin{align*}
s & : [[ (A -o (B -o C)) -o {(A -o B) -o ({[] 2 A} -o C)} ]] \\
s & = [[ \x . {\y . {\z' . {let [ z ] = z' in {(x z) (y z)}}}} ]]
\end{align*}
The graded modal value $z'$ captures the `capability' for a value
of type $A$ to be used twice. This capability is made available by eliminating
$\Box$ (via \textbf{let}) to the variable $z$, which has
grade $2$ in the scope of the body.
\end{example}

\subsection{The Fully Graded $\lambda$-calculus}
\label{sec:graded-base}
We now define a core calculus for a fully graded type system, where grades
permeate the entire program, drawing from the coeffect calculus of
\citet{petricek2014coeffects}, Quantitative Type Theory (QTT) by
\citet{McBride2016} and refined further by \citet{quantitative-type-theory}
(although we omit dependent types from our language), the calculus of
\citet{DBLP:journals/pacmpl/AbelB20}, and other graded dependent type
theories~\citep{quantitative-type-theory,DBLP:conf/esop/MoonEO21}. Similar
systems also form the basis of the core of the linear types extension to
Haskell~\citep{DBLP:journals/pacmpl/BernardyBNJS18}. We
refer to this system as the \textit{fully graded $\lambda$-calculus}.

The syntax of types is given by:
\begin{align*}
\hspace{-0.9em}[[ A ]] , [[ B ]] & ::=
       [[ A ^ r -> B ]]
  \mid [[ [] r A ]]
{\small{\tag{\textit{types}}}}
\end{align*}
where the function arrow $[[ A ^ r -> B ]]$ annotates the input type with a
\emph{grade} $[[ r ]]$ which is again drawn from a pre-ordered semiring
$(\mathcal{R}, {\ast}, {1}, {+}, {0}, \sqsubseteq)$ parametrising the calculus.
The graded necessity modality $[[ [] r A ]]$ is similarly annotated by the grade
$[[ r ]]$ being an element of the semiring. 

The syntax of terms is given as:
%
\begin{align*}
\hspace{-0.8em} [[ t ]] ::= \;
       & [[ x ]]
  \mid [[ \x ^ c . t ]]
  \mid [[ t1 t2 ]]
  \mid [[ [t] ]]
  \mid [[ let [ x ] = t1 in t2 ]] 
  % \mid [[ case t of p1 -> t1 ; * ; pn -> tn  ]]
{\small{\tag{\textit{terms} }}}
\end{align*}
%
Terms comprise the $\lambda$-calculus, extended with the \textit{promotion}
construct [t] as seen in Section~\ref{sec:linear-base}. Typing judgements have
the same form as Section~\ref{sec:linear-base}, however, variable contexts are
instead given by: 
\begin{equation*}
  [[ D ]], [[ G ]] ::= \emptyset
  \mid [[ G , x : [ A ] r ]]
\tag{\textit{contexts}}
\end{equation*}
That is, a context may be empty $\emptyset$ or extended with a \textit{graded}
assumption $ [[ x : [A] r ]]$, which must be used in a way which adheres to the
constraints of the grade $[[ r ]]$. As before, structural exchange is permitted,
allowing a context to be arbitrarily reordered. 


\begin{figure}[H]
\hspace{-0.5em}
\begin{align*}
\hspace{-0.5em}
\begin{array}{c}
\GRANULEdruleTyVar{}
\;\;\;
\GRANULEdruleTyAbs{}
\\[1.25em]
\GRANULEdruleTyApp{}
\\[1.25em]
\GRANULEdruleTyApprox{}
\;\;\;
\GRANULEdruleTyPr{}
\\[1.25em]
\inferrule*[right = Let$\Box$]
  {[[ G1 |- t1 : [] r A ]] \;\;\;
   [[ G2, x : [ A ] r |- t2 : B ]] }
    {[[ G1 + G2 |- let [x] = t1 in t2 : B ]]}
\end{array}
\end{align*}
\vspace{-0.5em}
\caption{Typing rules for the fully graded $\lambda$-calculus}
\label{fig:graded-typing}
\vspace{-0.5em}
 \end{figure}

Figure~\ref{fig:graded-typing} gives the full typing rules, which explains the meaning of
the syntax with reference to their static semantics.

Variables (rule \textsc{Var}) are typed in a context where the variable $x$ has
grade $1$ denoting its single usage here. All other variable assumptions are
given the grade of the $0$ semiring element (providing \emph{weakening}), using
\textit{scalar multiplication} of contexts by a grade, re-using
Definition~\ref{def:scalar} from Section~\ref{sec:linear-base}.

Abstraction (\textsc{Abs}) captures the assumption's grade $[[ r ]]$ onto the
function arrow in the conclusion, that is, abstraction binds a variable $[[x]]$
which may be used in the body $[[t]]$ according to grade $[[ r ]]$. Application
again (\textsc{App}) makes use of context addition to combine the contexts used to
type the two sub-terms in the premises of the application rule:

\begin{definition}[Graded context addition]\label{def:contextAddGraded}
For all $[[ G1 ]], [[ G2 ]]$ \emph{graded context addition} is defined
as follows by ordered cases matching inductively on the structure of
$[[ G2 ]]$, where $[[G1 + G2]] = $
\begin{gather*}
\left\{\begin{matrix}
    \begin{array}{ll}
    [[G1]] &
    [[G2]] = \emptyset
             \\
      (([[G1']], [[G1'']]) + [[G2']]), [[x : [A] (r + s)]] \; &
[[ G2]] = [[ G2', x : [A] s]] \wedge [[G1]] = [[ G1',x : [A] r]],[[G1'']] \\
 [[ (G1 + G2'), x : [A] s ]] & [[ G2 ]] = [[ G2' , x : [A] s ]] \wedge [[ x ]] \not\in \mathsf{dom}([[ G1 ]])
\end{array}
  \end{matrix}\right.
\end{gather*}
\end{definition}
Note that~\ref{def:contextAddGraded} differs only from
~\ref{def:contextAdd}, in that the former need not consider linear
assumptions.

Explicit introduction of graded modalities is achieved via the rule for
promotion (\textsc{Pr}). This rule is almost identical to that
of~\ref{sec:linear-base} with the only difference being here $[[ G ]]$ is known
to always contain only graded assumptions. Explicit unboxing
(\textsc{Let$\Box$}), and approximation (\textsc{Approx}) are likewise identical
to the calculus of~\ref{sec:linear-base}.   


\section{Two Typing Calculi}
Having outlined the two lineages of graded type systems, we are left with the
question: what approach should we use as the basis of a target language for a
program synthesis tool? Both systems embed properties for reasoning about
program structure into the language, however, they differ in how this
information is expressed, as shown by the variance in typing and syntax between
Sections ~\ref{sec:linear-base} and ~\ref{sec:graded-base}. 

Rather than focus entirely on one approach, we opt to instead build synthesis
tools which target both systems. As we have seen, systems based on both
approaches are in frequent use today, and both pose their unique challenges in
designing a synthesis tool, which makes favouring a particular approach
difficult to justify. Furthermore, the target programming language Granule of
our implementations includes both approaches.~\footnote{As of Granule v0.9.3.0}

By this point we are in a strong position to tackle the problem of program
synthesis, beginning with a simple introduction to the core issues at the heart
of resourceful program synthesis in the next chapter, using our graded linear
$\lambda$-calculus. 

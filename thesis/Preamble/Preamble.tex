\usepackage{listings}
\lstdefinelanguage{Granule}{%
  mathescape=true,
  morecomment=[l]{--},
%  backgroundcolor = \color{white},
  % morestring=[s]{"}{"},
  % stringstyle=\itshape, %\color{OliveGreen!90!Black},%\color{orange!60!black},
  moredelim=[s][\itshape]{`}{`},
  % moredelim=[s][\color{coeffectColor}]{[}{]},
  showspaces=false,
  xleftmargin=2.5em,
  commentstyle=\itshape\color{black!60},
  % identifierstyle=\color{violet!80!black},
  basicstyle=\ttfamily\small,%\sffamily\small,%
  flexiblecolumns=true,
  columns=[l]flexible,
  columns=fullflexible,
  keepspaces=true,
  % basewidth={0.55em,0.9em},
  literate=%
  % {[0]}{[{\textcolor{coeffectColor}{0}}]}1
  % {[1]}{[{\textcolor{coeffectColor}{1}}]}1
  % {[2]}{[{\textcolor{coeffectColor}{2}}]}1
  % {[3]}{[{\textcolor{coeffectColor}{3}}]}1
  % {[4]}{[{\textcolor{coeffectColor}{4}}]}1
  % {[5]}{[{\textcolor{coeffectColor}{5}}]}1
  % {[6]}{[{\textcolor{coeffectColor}{6}}]}1
  % {[r]}{[{\textcolor{coeffectColor}{r}}]}1
  % {[s]}{[{\textcolor{coeffectColor}{s}}]}1
  {<}{\textcolor{effectColor}{<}}1
  {>}{\textcolor{effectColor}{>}}1
  {[}{\textcolor{coeffectColor}{[}}1
  {]}{\textcolor{coeffectColor}{]}}1
  {[r' : R']}{[{\textcolor{coeffectColor}{r' : R'}}]}1
  {[([}{\textcolor{coeffectColor}{[[}}2  % I don't think this is valid, consider [([x],[y])] % but need this as a hack for OTT.
  {])]}{\textcolor{coeffectColor}{]]}}2
  {forall}{$\forall$}1
  {Inf}{$\infty$}1
  {->}{$\rightarrow$}1
  {-o}{$\multimap$}1
  {=>}{$\Rightarrow$}1
  {<-}{\textcolor{effectColor}{$\leftarrow$}}1
  {/\\}{$\sqcap$}1
  {\\/}{$\sqcup$}1
  {<=}{$\leqslant$}1
  {>=}{$\geqslant$}1
  {\\}{$\lambda$}1
  {_1}{$\mathtt{_1}$}1
  {_2}{$\mathtt{_2}$}1
  {_3}{$\mathtt{_3}$}1
  {_4}{$\mathtt{_4}$}1
  {_L}{$\mathtt{_{L}}$}1
  {_LH}{$\mathtt{_{LH}}$}1
  {_Gr}{$\mathtt{_{Gr}}$}1
  {_p}{$\mathtt{_{p}}$}1
  {_q}{$\mathtt{_{q}}$}1
  {-o}{$\multimap$}1
  {\\times}{$\times$}1
  {--BLANK}{}1,
  % % Main keywords
  keywordstyle = \color{blue!40!black},%\color{WildStrawberry!90!Black},
  keywords = {data, type, let, in, case, of, if, then, else, where, import, Type, Semiring, Protocol},
  % % morekeywords = {∀,|,:,=,\{,\},->,←,.,\,,(,),;},
  % % % Type Constructors
  % % keywordstyle = [2]\color{red!40!black},%\color{YellowOrange!80!Maroon},
  % % keywords = [2]{Int, Bool, Vec, Type, Coeffect, Effect, Char, String, Maybe, List, N, Handle, Nat, Level},
  % % % morekeywords = [2]{()},
  % % % Data Constructors
  % % keywordstyle = [7]\color{purple!40!black},%Mahogany!70!WildStrawberry},
  % % keywords = [7]{Some, None, Nil, NilL, Cons, ConsL, ReadMode, S, Z},
  % % % Coeffects
  % keywordstyle = [3]\color{coeffectColor},
  % keywords     = [3]{Private, Public},
  % morekeywords = [3]{..,+,*,Inf},
  % % % Effects
  keywordstyle = [4]\bfseries\color{effectColor},
  keywords     = [4]{pure},%{IO,
                          %Open,Read,IOExcept,Close,Write,ReadWrite},
  numbers=none,
  numberstyle=\tiny\color{gray}
  % morekeywords = [4]{<,>},
  % % % universals
  % % keywords = [6]{a,b,t,s},
  % % keywordstyle = [6]\color{black}\textit,
}

\lstnewenvironment{granule}
{\lstset{language=Granule}}{}
%% $

\lstnewenvironment{granuleInterface}
{\lstset{language=Granule,numbers=none}}{}

% inline Granule
\newcommand{\granin}[1]{\lstinline[language=Granule]{#1}}

%%%%%% HASKELL
\definecolor{multiplicity}{rgb}{0,0.3,0.08}

\lstdefinelanguage{Haskell}{%
  mathescape=true,
%  backgroundcolor = \color{white},
  morecomment=[l]{--},
  comment=[l]{\{-},
  moredelim=[s][\itshape]{`}{`},
  showspaces=false,
  commentstyle=\itshape\color{black!60},
  basicstyle=\ttfamily\footnotesize,%\sffamily\small,%
  flexiblecolumns=true,
  columns=[l]flexible,
  columns=fullflexible,
  keepspaces=true,
  xleftmargin=2.5em,
  literate=%
   {\%r}{\textcolor{multiplicity}{\%r}}1
   {\%'Many}{\textcolor{multiplicity}{\%'Many}}1
   {\%1}{\textcolor{multiplicity}{\%1}}1,
  % % Main keywords
  keywordstyle = \color{blue!40!black},%\color{WildStrawberry!90!Black},
  keywords = {data, type, let, in, case, of, if, then, else, where,
  import, class, instance},
  % % morekeywords = {∀,|,:,=,\{,\},->,←,.,\,,(,),;},
  % % % Type Constructors
  % % keywordstyle = [2]\color{red!40!black},%\color{YellowOrange!80!Maroon},
  % % % Data Constructors
  % % keywordstyle = [7]\color{purple!40!black},%Mahogany!70!WildStrawberry},
  % % keywords = [7]{Some, None, Nil, NilL, Cons, ConsL, ReadMode, S, Z},
  numbers=none,
  numberstyle=\tiny\color{gray}
  % morekeywords = [4]{<,>},
  % % % universals
  % % keywords = [6]{a,b,t,s},
  % % keywordstyle = [6]\color{black}\textit,
}

\lstnewenvironment{haskell}
{\lstset{language=Haskell}}{}
%% $

% inline Haskell
\newcommand{\haskin}[1]{\lstinline[language=Haskell]{#1}}

%%%%%% IDRIS (but I just copied haskell and changed the name, fix later!!)

\lstdefinelanguage{Idris}{%
%  backgroundcolor = \color{white},
  mathescape=true,
  morecomment=[l]{--},
  comment=[l]{\{-},
  moredelim=[s][\itshape]{`}{`},
  showspaces=false,
  commentstyle=\itshape\color{black!60},
  basicstyle=\ttfamily\footnotesize,%\sffamily\small,%
  flexiblecolumns=true,
  columns=[l]flexible,
  columns=fullflexible,
  keepspaces=true,
  xleftmargin=2.5em,
  literate=%
   {\%r}{\textcolor{multiplicity}{\%r}}1
   {\%'Many}{\textcolor{multiplicity}{\%'Many}}1
   {\%1}{\textcolor{multiplicity}{\%1}}1,
  % % Main keywords
  keywordstyle = \color{blue!40!black},%\color{WildStrawberry!90!Black},
  keywords = {data, type, let, in, case, of, if, then, else, where,
  import, class, instance},
  % % morekeywords = {∀,|,:,=,\{,\},->,←,.,\,,(,),;},
  % % % Type Constructors
  % % keywordstyle = [2]\color{red!40!black},%\color{YellowOrange!80!Maroon},
  % % % Data Constructors
  % % keywordstyle = [7]\color{purple!40!black},%Mahogany!70!WildStrawberry},
  % % keywords = [7]{Some, None, Nil, NilL, Cons, ConsL, ReadMode, S, Z},
  numbers=none,
  numberstyle=\tiny\color{gray}
  % morekeywords = [4]{<,>},
  % % % universals
  % % keywords = [6]{a,b,t,s},
  % % keywordstyle = [6]\color{black}\textit,
}

\lstnewenvironment{idris}
{\lstset{language=Idris}}{}
%% $

% inline Idris
\newcommand{\idrin}[1]{\lstinline[language=Idris]{#1}}

\usepackage[most]{tcolorbox}

\makeatletter
\newtcblisting[auto counter]{haskellp}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  top=-0.5em,
  left=0em,
  bottom=-0.5em,
  bottomrule=0.5pt,
  boxsep=0em,
  after skip=1em,
  before skip=1em,
  listing options={language={haskell}},
  listing only,
  colback=white,
  sharp corners,
  overlay={\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Haskell};
           %\node[inner sep=2pt,xshift=+2cm,fill=white] (B) at (frame.north west) {#2};
  },
  #1,
}
\makeatother

\makeatletter
\newtcblisting[auto counter]{haskellf}[1][]{%
  top=0em,
  left=0em,
  bottom-0.5em,
  bottomrule=0.5pt,
  boxsep=0em,
  after skip=1em,
  before skip=0.5em,
  listing options={language={haskell}},
  listing only,
  colback=white,
  #1,
}
\makeatother

\makeatletter
\newtcblisting[auto counter]{granulep}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  bottomrule=0.5pt,
  top=-0.5em,
  left=-0.5em,
  bottom=-0.5em,
  boxsep=0em,
  after skip=1em,
  before skip=0.5em,
  listing options={language={granule}},
  listing only,
  colback=white,
  sharp corners,
  overlay={%\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Granule};
           \node[inner sep=2pt,xshift=-1cm,fill=white] (B) at (frame.south east) {Granule};
  },
  #1,
}
\makeatother


\makeatletter
\newtcblisting[auto counter]{granulepill}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  bottomrule=0.5pt,
  top=-0.5em,
  left=0em,
  bottom=-0.5em,
  boxsep=0em,
  after skip=1em,
  before skip=0.5em,
  listing options={language={granule}},
  listing only,
  colback=white,
  sharp corners,
  overlay={%\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Granule};
           \node[inner sep=2pt,xshift=-2cm,fill=white] (B) at
           (frame.south east) {Ill-typed Granule};
  },
  #1,
}
\makeatother


\makeatletter
\newtcblisting[auto counter]{idrisp}[1][]{%
  enhanced jigsaw,
  colframe=black!30,
  boxrule=0.5pt,
  toprule=0.5pt,
  bottomrule=0.5pt,
  top=-0.5em,
  left=0em,
  bottom=0em,
  boxsep=0em,
  after skip=1em,
  before skip=1em,
  listing options={language={idris}},
  listing only,
  colback=white,
  sharp corners,
  overlay={%\node[inner sep=4pt,xshift=-2cm,fill=white] (A) at (frame.south east) {Granule};
           \node[inner sep=2pt,xshift=-2cm,fill=white] (B) at (frame.south east) {Idris 2};
  },
  #1,
}
\makeatother

% \definecolor{periwinkle}{rgb}{0.8, 0.8, 1.0}
% \newcommand{\highlight}[1]{%
% {\setlength{\fboxsep}{0pt}\colorbox{SkyBlue!50}{$\displaystyle#1$}}}


\newcommand{\rulehighlight}[1]{%
{\setlength{\fboxsep}{0pt}\colorbox{yellow!50}{$\displaystyle#1$}}}

\newcommand{\newhighlight}[1]{%
{\setlength{\fboxsep}{0pt}\colorbox{SkyBlue!50}{$\displaystyle#1$}}}
% {\setlength{\fboxsep}{0pt}\colorbox{Periwinkle!50}{$\displaystyle#1$}}}
% {\setlength{\fboxsep}{0pt}\colorbox{yellow!50}{$\displaystyle#1$}}}

% \newcommand{\newnewhighlight}[1]{%
% {\setlength{\fboxsep}{0pt}\colorbox{yellow!50}{$\displaystyle#1$}}}

% \newcommand{\anotherhighlight}[1]{%
% {\setlength{\fboxsep}{0pt}\colorbox{Periwinkle!50}{$\displaystyle#1$}}}


% SUBTRACTIVE RULES
\newcommand*{\subLinVar}{
                             \inferrule*[right=\subLinVarName]
                             {\quad}{[[G, x : A |- A =>- x ; G]]}
  }

  \newcommand*{\subGrVar}{
      \inferrule*[right=\subGrVarName]
  {[[ exists s . r >= {s + 1} ]]}{[[G, x : [A] r |- A =>- x ; G , x : [A] s]]}
    }

  \newcommand*{\subAbs}{
      \inferrule*[right=\subAbsName]
  {[[G, x : A |- B =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G |- A -o B =>- \x. t ; D ]]}
    }
  \newcommand*{\subApp}{
  \inferrule*[right=\subAppName]
  {[[G, x2 : B |- C =>- t1 ; D1]] \qquad [[ x2 notin D1 ]] \qquad [[D1 |- A =>- t2 ; D2]]}{[[G, x1 : A -o B
      |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
    }
  \newcommand*{\subDer}{
      \inferrule*[right=\subDerName]
{[[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G, x : [A] r |- B =>- [pat x/y] t ; D, x : [A] s' ]]}
    }
  \newcommand*{\subBox}{
  \inferrule*[right=\subBoxName]
  {[[G |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; G - r * (G - D)]]}
    }
  \newcommand*{\subBoxAlt}{
  \inferrule*[right=R${\square'^{-}}$]
  {[[G / r |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; r * D ]]}
    }
  \newcommand*{\subUnbox}{
  \inferrule*[right=\subUnboxName]
    {[[ G, x2 : [A] r |- B =>- t ; D, x2 : [A] s ]] \\ 0 \sqsubseteq [[ s]]}{[[G, x1 : [] r A |- B =>- let [x2] = x1 in t ; D ]]}
    }
  \newcommand*{\subPairIntro}{
    \inferrule*[right=\subPairIntroName]
    {[[G |- A =>- t1 ; D1]] \\ [[ D1 |- B =>- t2 ; D2 ]]}{[[G |- Tup A B =>- pair t1 t2 ; D2]]}
    }
  \newcommand*{\subPairElim}{
    \inferrule*[right=\subPairElimName]
    {[[ G, x1 : A, x2 : B |- C =>- t2 ; D]] \\ [[ x1 notin D ]] \\ [[ x2 notin D ]]}
    {[[ G, x3 : Tup A B |- C =>- letpair x1 x2 = x3 in t2 ; D ]]}
    }
  \newcommand*{\subSumIntroL}{
    \inferrule*[right=\subSumIntroLname]
    {[[G |- A =>- t ; D]]}
    {[[G |- Sum A B =>- inl t ; D]]}
    }
  \newcommand*{\subSumIntroR}{
    \inferrule*[right=\subSumIntroRname]
    {[[G |- B =>- t ; D]]}
    {[[G |- Sum A B =>- inr t ; D]]}
    }
  \newcommand*{\subSumElim}{
    \inferrule*[right=\subSumElimName]
      {[[G, x2 : A |- C =>- t1 ; D1]] \quad\,
       [[G, x3 : B |- C =>- t2 ; D2]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
{\Gamma, x_1 : [[ Sum A B ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ | \ \Delta_1 \sqcap \Delta_2}
    }
  \newcommand*{\subUnitIntro}{
    \inferrule*[right=\subUnitIntroName]
    {\quad}
    {[[G |- Unit =>- () ; G]]}
    }
  \newcommand*{\subUnitElim}{
    \inferrule*[right=\subUnitElimName]
    {[[G |- C =>- t ; D]]}
    {[[G, x : Unit |- C =>- let () = x in t ; D]]}
    }

% ADDITIVE RULES
\newcommand*{\addLinVar}{
    \inferrule*[right=LinVar$^{+}$]
    {\quad}
    {[[G, x : A |- A =>+ x ; x : A]]}
  }

  \newcommand*{\addGrVar}{
    \inferrule*[right=GrVar$^{+}$]
    {\quad}
      {[[ G, x : [A] r |- A =>+ x ; x :[A] 1 ]] }
    }

  \newcommand*{\addAbs}{
    \inferrule*[right=\addAbsName]
    {[[G, x : A |- B =>+ t ; D, x : A]]}{[[G |- A -o B =>+ \x . t ; D]]}
    }
  \newcommand*{\addApp}{
    \inferrule*[right=\addAppName]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
    }
\newcommand*{\addPruneAppHighlight}{
\inferrule*[right=\addPruningAppName]
  {\Gamma, x_2 : B \vdash C \Rightarrow^{\pm} t_1 \mid \Delta_1, x_2 : B \\ \rulehighlight{\Gamma - \Delta_1} \vdash A \Rightarrow^{\pm} t_2 \mid \Delta_2}
  {\Gamma, x_1 : A \multimap B \vdash C \Rightarrow^{\pm} [ (x_1\ t_2) / x_2 ] \mid (\Delta_1 + \Delta_2), x_1 : A \multimap B }
}
\newcommand*{\addPruneApp}{
\inferrule*[right=\addPruningAppName]
  {\Gamma, x_2 : B \vdash C \Rightarrow^{\pm} t_1 \mid \Delta_1, x_2 : B \\ \Gamma - \Delta_1 \vdash \Rightarrow^{\pm} t_2 \mid \Delta_2}
  {\Gamma, x_1 : A \multimap B \vdash C \Rightarrow^{\pm} [ (x_1\ t_2) / x_2 ] \mid (\Delta_1 + \Delta_2), x_1 : A \multimap B }
  }
  \newcommand*{\addDer}{
\inferrule*[right=\addDerName]
{ [[ G, x : [A]s, y : A |- B =>+ t ; D, y : A ]] }
{ [[ G, x : [A]s |- B =>+ [pat x / y] t ; D + x : [A]1 ]] }
    }
  \newcommand*{\addBox}{
    \inferrule*[right=\addBoxName]
    {[[G |- A =>+ t ; D]]}{[[G |- [] r A =>+ [t] ; r * D ]]}
    }
  \newcommand*{\addUnbox}{
    \inferrule*[right=\addUnboxName]
    {[[ G, x2 : [A] r |- B =>+ t ; D ]] \\ \textit{if}\ [[x2 : [A] s]] \in
      [[D]]\ \textit{then}\ s \sqsubseteq r \ \textit{else}\  0 \sqsubseteq r}{[[G, x1 : [] r A |- B =>+
      let [x2] = x1 in t ; (D \ x2 ), x1 : [] r A ]]}
    }
  \newcommand*{\addPairIntro}{
    \inferrule*[right=\addPairIntroName]
    {[[G |- A =>+ t1 ; D1]] \\ [[G |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
    }
  \newcommand*{\addPrunePairIntroHighlight}{
    \inferrule*[right=\addPruningPairIntroName]
    { \Gamma \vdash A \Rightarrow^{\pm} t_1 \mid \Delta_1 \\  \rulehighlight{\Gamma - \Delta_1} \vdash B \Rightarrow^{\pm} t_2 \mid \Delta_2}
    { \Gamma \vdash A \otimes B \Rightarrow^{\pm} (t_1, t_2) \mid \Delta_1 + \Delta_2}
    }
  \newcommand*{\addPrunePairIntro}{
    \inferrule*[right=\addPruningPairIntroName]
    { \Gamma \vdash A \Rightarrow^{\pm} t_1 \mid \Delta_1 \\ \Gamma - \Delta_1 \vdash B \Rightarrow^{\pm} t_2 \mid \Delta_2}
    { \Gamma \vdash A \otimes B \Rightarrow^{\pm} (t_1, t_2) \mid \Delta_1 + \Delta_2}
    }
  \newcommand*{\addPairElim}{
    \inferrule*[right=\addPairElimName]
    {[[ G, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}
    {[[ G, x3 : Tup A B |- C =>+ letpair x1 x2 = x3 in t2 ; D, x3 : Tup A B ]]}
    }
  \newcommand*{\addSumIntroL}{
    \inferrule*[right=\addSumIntroLName]
    {[[G |- A =>+ t ; D]]}
    {[[G |- Sum A B =>+ inl t ; D]]}
    }
  \newcommand*{\addSumIntroR}{
    \inferrule*[right=\addSumIntroRName]
    {[[G |- B =>+ t ; D]]}
    {[[G |- Sum A B =>+ inr t ; D]]}
    }
  \newcommand*{\addSumElim}{
    \inferrule*[right=\addSumElimName]
    {[[G, x2 : A |- C =>+ t1 ; D1, x2 : A]] \\ [[G, x3 : B |- C =>+ t2 ; D2,
      x3 : B ]]}
{\Gamma, x_1 : [[ Sum A B ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ |\ \Delta_1 \sqcup \Delta_2, [[ x1 : Sum A B ]]}
    }
  \newcommand*{\addUnitIntro}{
    \inferrule*[right=\addUnitIntroName]
    {\quad}
    {[[G |- Unit =>+ () ; .]]}
    }
  \newcommand*{\addUnitElim}{
    \inferrule*[right=\addUnitElimName]
    {[[G |- C =>+ t ; D]]}
    {[[G, x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
    }


% FOCUSED SUBTRACTIVE RULES
\newcommand*{\fSubAbsRule}{
    \inferrule*[right=\fSubAbsName,Lab=RightAsync]
    {[[G ; O, x : A |- C async =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G ; O |- {A -o B} async =>- \ x . t ; D]]}
}
\newcommand*{\fSubAbsRuleNoLabel}{
    \inferrule*[right=\fSubAbsName]
    {[[G ; O, x : A |- C async =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G ; O |- {A -o B} async =>- \ x . t ; D]]}
}
\newcommand*{\fSubRAsyncTransitionRule}{
  \inferrule*[right=\fSubRAsyncTransitionName]
  {[[ G ; O async |- C =>- t ; D ]] \\ [[ C ]] \text{ not } \textsc{Right Async}}{[[G ; O |-
  C async =>- t ; D]]}
}
\newcommand*{\fSubPairElimRule}{
    \inferrule*[right=\fSubPairElimName,lab=LeftAsync]
    {[[G ; {O, x1 : A, x2 : B} async |- C =>- t2 ; D ]] \\ [[ x1 notin D ]] \\ [[
  x2 notin D ]]}{[[G ; {O, x3 : Tup A B} async |- C =>- letpair x1 x2
    = x3 in t2 ; D]]}
}
\newcommand*{\fSubPairElimRuleNoLabel}{
    \inferrule*[right=\fSubPairElimName]
    {[[G ; {O, x1 : A, x2 : B} async |- C =>- t2 ; D ]] \\ [[ x1 notin D ]] \\ [[
  x2 notin D ]]}{[[G ; {O, x3 : Tup A B} async |- C =>- letpair x1 x2
    = x3 in t2 ; D]]}
}
\newcommand*{\fSubSumElimRule}{
    \inferrule*[right=\fSubSumElimName]
    {[[G ; {O, x2 : A} async |- C =>- t1 ; D1]] \quad\, [[ G ; {O, x3 : B} async |- C =>- t2 ; D2
      ]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
{\Gamma ; [[ {O, x1 :  Sum A B} async ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ | \ \Delta_1 \sqcap \Delta_2}
    % {[[G ; {O, x1 : A + B} async |- C =>- case x2 of inl x2 -> t1 | inr x3 -> t2 ; D1 ++- D2]]}
}
\newcommand*{\fSubUnboxRule}{
    \inferrule*[right=\fSubUnboxName]
    {[[G ; {O, x2 : [A] r} async |- B =>- t ; D, x2 : [A] s ]] \\ 0 \sqsubseteq [[ s]]}{[[G; {O, x1 : []
                                                      r A} async |- B =>- let [x2] = x1
                                                      in t ; D]]}
}
\newcommand*{\fSubUnitElimRule}{
    \inferrule*[right=\fSubUnitElimName]
    {[[G ; .|- C =>- t ; D]]}
    {[[G ; x : Unit |- C =>- let () = x in t ; D]]}
}
\newcommand*{\fSubDerRule}{
\inferrule*[right=\fSubDerName]
{[[ G ; {x : [A] s, y : A } sync |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G ; {x : [A] r} sync |- B =>- [pat x/y] t ; D, x : [A] s' ]]}
}
\newcommand*{\fSubLAsyncTransitionRule}{
  \inferrule*[right=\fSubLAsyncTransitionName]
  {[[G, x : A ; O async |- C =>- t ; D ]] \\ A \text{ not } \textsc{Left Async}}{[[G ; {O, x
  : A} async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusRRule}{
\inferrule*[right=\fSubFocusRName,lab=Focus]
  {[[G ; . |- C sync =>- t ; D]] \\ C \text{ not atomic}}{[[ G ; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusRRuleNoLabel}{
\inferrule*[right=\fSubFocusRName]
  {[[G ; . |- C sync =>- t ; D]] \\ C \text{ not atomic}}{[[ G ; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusLRule}{
\inferrule*[right=\fSubFocusLName]
  {[[G ; {x : A} sync |- C =>- t ; D]]}{[[ G, x : A; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubPairIntroRule}{
    \inferrule*[right=\fSubPairIntroName,lab=RightSync]
    {[[G ; . |- A sync =>- t1 ; D1]] \\ [[D1 ; . |- B sync =>- t2 ; D2 ]]}{[[G ; .
  |- {Tup A B} sync
    =>- pair t1 t2 ; D2]]}
}
\newcommand*{\fSubPairIntroRuleNoLabel}{
    \inferrule*[right=\fSubPairIntroName]
    {[[G ; . |- A sync =>- t1 ; D1]] \\ [[D1 ; . |- B sync =>- t2 ; D2 ]]}{[[G ; .
  |- {Tup A B} sync
    =>- pair t1 t2 ; D2]]}
}
\newcommand*{\fSubSumIntroRuleL}{
    \inferrule*[right=\fAddSumIntroNameL]
    {[[G ; . |- A sync =>- t ; D]]}{[[ G ; . |- {Sum A B} sync =>- inl t ; D ]]}
}
\newcommand*{\fSubSumIntroRuleR}{
    \inferrule*[right=\fAddSumIntroNameR]
    {[[G ; . |- B sync =>- t ; D]]}{[[ G ; . |- {Sum A B} sync =>- inr t ; D ]]}
}
\newcommand*{\fSubBoxRule}{
    \inferrule*[right=\fSubBoxName]
    {[[G; . |- A sync =>- t ; D]]}{[[G ; . |- { [] r A} sync =>- t ; G - r * (G - D)]]}
}
\newcommand*{\fSubUnitIntroRule}{
    \inferrule*[right=\fSubUnitIntroName]
    {\quad}
    {[[G ; . |- Unit sync =>- () ; G]]}
}
\newcommand*{\fSubRSyncTransitionRule}{
  \inferrule*[right=\fSubRSyncTransitionName]
  {[[ G ; . |-  A async =>- t ; D]]}{ [[ G ; . |- A sync =>- t ; D ]]}
}
\newcommand*{\fSubAppRule}{
    \inferrule*[right=\fSubAppName,lab=LeftSync]
    {[[ G ; {x2 : B} sync |- C =>- t1 ; D1 ]] \qquad [[ x2 notin D1 ]] \qquad  [[D1 ; . |- A sync =>- t2 ; D2]]}{[[G ; {x1 :
    A -o B} sync |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
}
\newcommand*{\fSubAppRuleNoLabel}{
    \inferrule*[right=\fSubAppName]
    {[[ G ; {x2 : B} sync |- C =>- t1 ; D1 ]] \qquad [[ x2 notin D1 ]] \qquad  [[D1 ; . |- A sync =>- t2 ; D2]]}{[[G ; {x1 :
    A -o B} sync |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
}
\newcommand*{\fSubLinVarRule}{
    \inferrule*[right=\fSubLinVarName]
    {\quad}{[[G ; {x : A} sync |- A =>- x ; G]]}
}
\newcommand*{\fSubGrVarRule}{
    \inferrule*[right=\fSubGrVarName]
    {[[ exists s . r <= {s + 1} ]]}{[[G ; {x : [A] r} sync |- A =>- x ; G, x : [A] s]]}
}
\newcommand*{\fSubLSyncTransitionRule}{
  \inferrule*[right=\fSubLSyncTransitionName]
  {[[G ; {x : A} async |- C =>- t ; D]] \\ A \text{ not atomic and not } \textsc{Left Sync}}{[[G ; {x : A} sync |- C =>- t ; D]]}
}

% FOCUSED ADDITIVE RULES
\newcommand*{\fAddAbsRule}{
    \inferrule*[right=\fAddAbsName, lab=RightAsync]
    {[[G ; O, x : A |- B async =>+ t ; D, x : A]]}{[[ G ; O |- {A -o B} async =>+
  \ x . t ; D]]}
}
\newcommand*{\fAddAbsRuleNoLabel}{
    \inferrule*[right=\fAddAbsName]
    {[[G ; O, x : A |- B async =>+ t ; D, x : A]]}{[[ G ; O |- {A -o B} async =>+
  \ x . t ; D]]}
}
\newcommand*{\fAddRAsyncTransitionRule}{
  \inferrule*[right=\fAddRAsyncTransitionName]
  {[[ G ; O async |- C =>+ t ; D ]] \\ [[ C ]] \text{ not } \textsc{Right Async}}{[[G ; O |-
  C async =>+ t ; D]]}
}
\newcommand*{\fAddPairElimRule}{
    \inferrule*[right=\fAddPairElimName,lab=LeftAsync]
    {[[G ; O, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}{[[G ; O, x3 : Tup A B |- C =>+ letpair x1 x2
  = x3 in t2 ; D, x3 : Tup A B ]]}
}
\newcommand*{\fAddPairElimRuleNoLabel}{
    \inferrule*[right=\fAddPairElimName]
    {[[G ; O, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}{[[G ; O, x3 : Tup A B |- C =>+ letpair x1 x2
  = x3 in t2 ; D, x3 : Tup A B ]]}
}
\newcommand*{\fAddSumElimRule}{
    \inferrule*[right=\fAddSumElimName]
    {[[G ; {O, x2 : A} async |- C =>+ t1 ; D1, x2 : A]] \\ [[ G ; {O, x3 : B} async |- C =>+ t2 ;
    D2, x3 : B
    ]]}
  {[[ G ]] ; [[ {O, x1 : Sum A B} async ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ |\ \Delta_1 \sqcup \Delta_2, [[ x1 : Sum A B ]]}
}
\newcommand*{\fAddUnboxRule}{
    \inferrule*[right=\fAddUnboxName]
    {[[G ; {O, {x2 : [A] r async}} |- B =>+ t ; D]] \\ \textit{if}\ [[x2 : [A] s]]
                                                               \in [[D]]\ \textit{then}\ [[s]]
                                                               \sqsubseteq [[ r]]\ \textit{else}\  0
   \sqsubseteq [[ r ]]}
  {[[G ; O, x1 : [] r A |- B =>+ let [x2] = x1 in t ; (D \ x2), x1 : [] r A]]}
}
\newcommand*{\fAddUnitElimRule}{
    \inferrule*[right=\fAddUnitElimName]
    {[[G ; . |- C =>+ t ; D]]}
    {[[G ; x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
}
\newcommand*{\fAddDerRule}{
  \inferrule*[right=\fAddDerName]
  { [[ G ; {x : [A]s, y : A} sync |- B =>+ t ; D, y : A ]] }
  { [[ G ; x : [A]s sync |- B =>+ [pat x / y] t ; D + x : [A] 1 ]] }
}
\newcommand*{\fAddLAsyncTransitionRule}{
  \inferrule*[right=\fAddLAsyncTransitionName]
  {[[G, x : A ; O async |- C =>+ t ; D ]] \\ A \text{ not } \textsc{Left Async}}{[[G ; {O, x
  : A} async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusRRule}{
\inferrule*[right=\fAddFocusRName,lab=Focus]
  {[[G ; . |- C sync =>+ t ; D]] \\ C \text{ not atomic}}{[[ G ; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusRRuleNoLabel}{
\inferrule*[right=\fAddFocusRName]
  {[[G ; . |- C sync =>+ t ; D]] \\ C \text{ not atomic}}{[[ G ; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusLRule}{
\inferrule*[right=\fAddFocusLName]
  {[[G ; {x : A} sync |- C =>+ t ; D]]}{[[ G, x : A; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddPairIntroRule}{
    \inferrule*[right=\fAddPairIntroName,lab=RightSync]
    {[[G ; . |- A sync =>+ t1 ; D1]] \\ [[G ; . |- B sync =>+ t2 ; D2 ]]}{[[G
  ; . |- {Tup A B} sync
    =>+ pair t1 t2 ; D1 + D2]]}
}
\newcommand*{\fAddPairIntroRuleNoLabel}{
    \inferrule*[right=\fAddPairIntroName]
    {[[G ; . |- A sync =>+ t1 ; D1]] \\ [[G ; . |- B sync =>+ t2 ; D2 ]]}{[[G
  ; . |- {Tup A B} sync
    =>+ pair t1 t2 ; D1 + D2]]}
}
\newcommand*{\fAddSumIntroRuleL}{
    \inferrule*[right=\fAddSumIntroNameL]
    {[[G ; . |- A sync =>+ t ; D]]}{[[ G ; . |- {Sum A B} sync =>+ inl t ; D ]]}
}
\newcommand*{\fAddSumIntroRuleR}{
    \inferrule*[right=\fAddSumIntroNameR]
    {[[G ; . |- B sync =>+ t ; D]]}{[[ G ; . |- {Sum A B} sync =>+ inr t ; D ]]}
}
\newcommand*{\fAddBoxRule}{
    \inferrule*[right=\fAddBoxName]
    {[[G; . |- A sync =>+ t ; D]]}{[[G ; . |- { [] r A} sync =>+ [t] ; r * D]]}
}
\newcommand*{\fAddUnitIntroRule}{
    \inferrule*[right=\fAddUnitIntroName]
    {\quad}
    {[[G ; . |- Unit =>+ () ; .]]}
}
\newcommand*{\fAddRSyncTransitionRule}{
  \inferrule*[right=\fAddRSyncTransitionName]
  {[[ G ; . |-  A async =>+ t ; D]]}{ [[ G ; . |- A sync =>+ t ; D ]]}
}
\newcommand*{\fAddAppRule}{
    \inferrule*[right=\fAddAppName,lab=LeftSync]
    {[[ G ; {x2 : B} sync |- C =>+ t1 ; D1, x2 : B]] \\ [[G ; . |- A sync =>+ t2
  ; D2]]}{[[G ; { x1 :
  A -o B } sync |- C =>+ [(x1 t2) / x2] t1 ; (D1 + D2), x1: A -o B ]]}
}
\newcommand*{\fAddAppRuleNoLabel}{
    \inferrule*[right=\fAddAppName]
    {[[ G ; {x2 : B} sync |- C =>+ t1 ; D1, x2 : B]] \\ [[G ; . |- A sync =>+ t2
  ; D2]]}{[[G ; { x1 :
  A -o B } sync |- C =>+ [(x1 t2) / x2] t1 ; (D1 + D2), x1: A -o B ]]}
}
\newcommand*{\fAddLinVarRule}{
    \inferrule*[right=\fAddLinVarName]
  {\quad}{[[G ; x : A |- A =>+ x ; x : A]]}
}
\newcommand*{\fAddGrVarRule}{
    \inferrule*[right=\fAddGrVarName]
    {\quad}{[[G ; x : [A] r |- A =>+ x ; x : [A] 1]]}
}
\newcommand*{\fAddLSyncTransitionRule}{
  \inferrule*[right=\fAddLSyncTransitionName]
  {[[G ; {x : A} async |- C =>+ t ; D]] \\ A \text{ not atomic and not } \textsc{Left Sync
  }}{[[G ; {x : A} sync |- C =>+ t ; D]]}
}

% ADDITIVE PRUNING FOCUS RULES

\newcommand*{\fAddAltAppRule}{
    \inferrule*[right=\fAddAltAppName]
  {\Gamma;  x_2 : B \Downarrow\ \vdash C \Rightarrow^{\pm} t_1 \mid \Delta_1, x_2 : B \\ \Gamma - \Delta_1 ; \emptyset \vdash A \Downarrow\ \Rightarrow^{\pm} t_2 \mid \Delta_2}
  {\Gamma; x_1 : A \multimap B \Downarrow\ \vdash C \Rightarrow^{\pm} [ (x_1\ t_2) / x_2 ] \mid (\Delta_1 + \Delta_2), x_1 : A \multimap B }
}

\newcommand*{\fAddAltPairIntroRule}{
    \inferrule*[right=\fAddAltPairIntroName]
    { \Gamma ; \emptyset \vdash A \Downarrow \ \Rightarrow^{\pm} t_1 \mid \Delta_1 \\ \Gamma - \Delta_1 \vdash B \Downarrow \ \Rightarrow^{\pm} t_2 \mid \Delta_2}
    { \Gamma ; \emptyset \vdash A \otimes B \Downarrow \ \Rightarrow^{\pm} (t_1, t_2) \mid \Delta_1 + \Delta_2}
    }


% GRADED BASE SYNTHESIS RULES
\newcommand*{\fsynVar}{\GRANULEdruleVarF{}}
\newcommand*{\fsynAbs}{\GRANULEdruleAbsF{}}
\newcommand*{\fsynUnbox}{\GRANULEdruleUnboxF{}}
\newcommand*{\fsynApp}{\GRANULEdruleAppF{}}
\newcommand*{\fsynCon}{\GRANULEdruleConF{}}
\newcommand*{\fsynCase}{\GRANULEdruleCaseF{}}
\newcommand*{\fsynBox}{\GRANULEdruleBoxF{}}

\newcommand*{\fsynRAsyncTrans}{
  \inferrule*[right=\fsynRAsyncTransName]
  {[[ G ; O async |- B => t ; D ]] \\ [[ B ]] \text{ not right async}}{[[G ; O |-
  B async => t ; D]]}
}
%
\newcommand*{\fsynLAsyncTrans}{
  \inferrule*[right=\fsynLAsyncTransName]
  {[[G, x : A ; O async |- B => t ; D ]] \\ \text{A not left async}}{[[G ; {O, x
  : A} async |- B => t ; D]]}
}
%
\newcommand*{\fsynFocusR}{
\inferrule*[right=\fsynFocusRName,lab=Focus]
{[[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ G ; . async |- B =>+ t ; D]]}
}
%
\newcommand*{\fsynFocusRNoLabel}{
\inferrule*[right=\fsynFocusRName]
{[[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ G ; . async |- B =>+ t ; D]]}
}
%
\newcommand*{\fsynFocusL}{
\inferrule*[right=\fsynFocusLName]
  {[[G ; {x : A} sync |- B => t ; D]]}{[[ G, x : A; . async |- B => t ; D]]}
}
%
\newcommand*{\fsynRSyncTrans}{
  \inferrule*[right=\fsynRSyncTransName]
  {[[ G ; . |-  A async => t ; D]]}{ [[ G ; . |- A sync => t ; D ]]}
}
%
\newcommand*{\fsynLSyncTrans}{
  \inferrule*[right=\fsynLSyncTransName]
  {[[G ; {x : A} async |- B => t ; D]] \\ \text{ A not atomic and not left sync
  }}{[[G ; {x : A} sync |- B => t ; D]]}
}

% \newcommand*{\fsynCaseSub}{\GRANULEdruleCaseSub{}}
% \newcommand*{\fsynCase}{\GRANULEdruleCase{}}
% \newcommand*{\synCaseAltAlt}{\GRANULEdruleCaseAltAlt{}}
% SYNTAX AND TYPES
\newcommand{\derLet}[3]{\textbf{let}\ #1 \leftarrow #2\ \textbf{in}\ #3}
\newcommand{\derCase}[2]{\mathbf{case}\ #1\ \mathbf{of}\ #2}
\newcommand{\derCaseBranch}[2]{#1 \rightarrow #2}

\newcommand{\derCaseOne}[3]
  {\derCase{#1}{\derCaseBranch{#2}{#3}}}

\newcommand{\derCaseTwo}[5]
  {\derCase{#1}{\begin{array}[t]{l}\derCaseBranch{#2}{#3};\\ \derCaseBranch{#4}{#5}\end{array}}}


\newcommand{\derCaseTwoMultiLine}[5]
  {\begin{array}[t]{l}
   \derCase{#1}{\\ \begin{array}[t]{l}\derCaseBranch{#2}{#3};\\
                     \derCaseBranch{#4}{#5}\end{array}}
  \end{array}}


\newcommand{\derCaseTwoShort}[5]
  {\derCase{#1}{\begin{array}[t]{l}\derCaseBranch{#2}{#3};\;\; \derCaseBranch{#4}{#5}\end{array}}}

\newcommand{\derLetRec}[3]
 {\mathbf{letrec}\ #1 = #2\ \mathbf{in}\ #3}

% \newcommand{\synUnbox}[3]
%  {\mathbf{let}\ [#1] = #2\ \mathbf{in}\ #3}

\newcommand{\tcF}{\mathsf{F}}

% DERIVING

\newcommand{\deriv}[2]{\llbracket{#2}\rrbracket_{\mathsf{#1}}}

% STRUCTURAL for the paper / work

\newcommand{\paragrapho}[1]{\medskip\noindent \textbf{#1}$\;\;$}
\newcommand{\grminip}{\textsc{GrMini}$^P$}

% PROOFS

\newcommand{\pr}[1]{\{\textit{#1}\}}

\newcommand*{\kVar}{\GRANULEdrulekindVar{}}
\newcommand*{\kArrow}{\GRANULEdrulekindArrow{}}
\newcommand*{\kApp}{\GRANULEdrulekindApp{}}
\newcommand*{\kUnit}{\GRANULEdrulekindUnit{}}
\newcommand*{\kBox}{\GRANULEdrulekindBox{}}
\newcommand*{\kProd}{\GRANULEdrulekindProd{}}
\newcommand*{\kSum}{\GRANULEdrulekindSum{}}
\newcommand*{\kMu}{\GRANULEdrulekindMu{}}
% \newcommand*{\kMuL}{\GRANULEdrulekindMuL{}}
\newcommand*{\kRec}{\GRANULEdrulekindRec{}}

% Typing rules (monomorphic)
% \newcommand*{\tyVar}{\GRANULEdruleTyVar{}}
% \newcommand*{\tyAbs}{\GRANULEdruleTyAbs{}}
% \newcommand*{\tyApp}{\GRANULEdruleTyApp{}}
% \newcommand*{\tyApprox}{\GRANULEdruleTyApprox{}}
% \newcommand*{\tyPr}{\GRANULEdruleTyPr{}}
% \newcommand*{\tyCon}{\GRANULEdruleTyCon{}}
% \newcommand*{\tyCase}{\GRANULEdruleTyCase{}}

% Typing rules (polymoprhic)
\newcommand*{\tyVarP}{\GRANULEdruleTyVarP{}}
\newcommand*{\tyTopP}{\GRANULEdruleTyTopLevelP{}}
\newcommand*{\tyDefP}{\GRANULEdruleTyDefP{}}
\newcommand*{\tyAbsP}{\GRANULEdruleTyAbsP{}}
\newcommand*{\tyAppP}{\GRANULEdruleTyAppP{}}
\newcommand*{\tyApproxP}{\GRANULEdruleTyApproxP{}}
\newcommand*{\tyPrP}{\GRANULEdruleTyPrP{}}
\newcommand*{\tyConP}{\GRANULEdruleTyConP{}}
\newcommand*{\tyCaseP}{\GRANULEdruleTyCaseP{}}
\newcommand*{\tyMuRP}{\GRANULEdruleTyMuRP{}}
\newcommand*{\tyMuLP}{\GRANULEdruleTyMuLP{}}

\newcommand*{\patWildP}{\GRANULEdrulePatWildP{}}
\newcommand*{\patVarP}{\GRANULEdrulePatVarP{}}
\newcommand*{\patBoxP}{\GRANULEdrulePatBoxP{}}
\newcommand*{\patConP}{\GRANULEdrulePatConP{}}

% Synthesis rules (monomorphic)
\newcommand*{\synVar}{\GRANULEdruleVar{}}
\newcommand*{\synAbs}{\GRANULEdruleAbs{}}
\newcommand*{\synApp}{\GRANULEdruleApp{}}
\newcommand*{\synCon}{\GRANULEdruleCon{}}
\newcommand*{\synConAlt}{\GRANULEdruleConAlt{}}
\newcommand*{\synCase}{\GRANULEdruleCase{}}
\newcommand*{\synCaseAlt}{\GRANULEdruleCaseAlt{}}
\newcommand*{\synCaseAltAlt}{\GRANULEdruleCaseAltAlt{}}
\newcommand*{\synBox}{\GRANULEdruleBox{}}
\newcommand*{\synUnbox}{\GRANULEdruleUnbox{}}
\newcommand*{\synCaseSub}{\GRANULEdruleCaseSub{}}

% Synthesis rules (polymorphic)
\newcommand*{\synVarP}{\GRANULEdruleSynVarP{}}
\newcommand*{\synDefP}{\GRANULEdruleSynDefP{}}
\newcommand*{\synTopP}{\GRANULEdruleSynTopLevelP{}}
\newcommand*{\synAbsP}{\GRANULEdruleSynAbsP{}}
\newcommand*{\synAppP}{\GRANULEdruleSynAppP{}}
\newcommand*{\synConP}{\GRANULEdruleSynConP{}}
\newcommand*{\synCaseP}{\GRANULEdruleSynCaseP{}}
\newcommand*{\synBoxP}{\GRANULEdruleSynBoxP{}}
\newcommand*{\synUnboxP}{\GRANULEdruleSynUnboxP{}}
% \newcommand*{\fsynRAsyncTransName}{$\Uparrow_{\textsc{R}}$}
% \newcommand*{\fsynLAsyncTransName}{$\Uparrow_{\textsc{L}}$}
% \newcommand*{\fsynFocusRName}{$\textsc{Foc}_{\textsc{R}}$}
% \newcommand*{\fsynFocusLName}{$\textsc{Foc}_{\textsc{L}}$}
% \newcommand*{\fsynRSyncTransName}{$\Downarrow_{\textsc{R}}$}
% \newcommand*{\fsynLSyncTransName}{$\Downarrow_{\textsc{L}}$}
% \newcommand*{\fsynVar}{\GRANULEdruleVarF{}}
% \newcommand*{\fsynAbs}{\GRANULEdruleAbsF{}}
% \newcommand*{\fsynUnbox}{\GRANULEdruleUnboxF{}}
% \newcommand*{\fsynApp}{\GRANULEdruleAppF{}}
% \newcommand*{\fsynCon}{\GRANULEdruleConF{}}
% \newcommand*{\fsynCase}{\GRANULEdruleCaseF{}}
% \newcommand*{\fsynBox}{\GRANULEdruleBoxF{}}


% \newcommand*{\fsynRAsyncTransPName}{$\Uparrow_{\textsc{R}}$}
% \newcommand*{\fsynLAsyncTransPName}{$\Uparrow_{\textsc{L}}$}
% \newcommand*{\fsynFocusRPName}{$\textsc{Foc}_{\textsc{R}}$}
% \newcommand*{\fsynFocusLPName}{$\textsc{Foc}_{\textsc{L}}$}
% \newcommand*{\fsynRSyncTransPName}{$\Downarrow_{\textsc{R}}$}
% \newcommand*{\fsynLSyncTransPName}{$\Downarrow_{\textsc{L}}$}
% \newcommand*{\fsynVarP}{\GRANULEdruleVarFP{}}
% \newcommand*{\fsynAbsP}{\GRANULEdruleAbsFP{}}
% \newcommand*{\fsynTopP}{\GRANULEdruleTopLevelFP{}}
% \newcommand*{\fsynUnboxP}{\GRANULEdruleUnboxFP{}}
% \newcommand*{\fsynAppP}{\GRANULEdruleAppFP{}}
% \newcommand*{\fsynDefP}{\GRANULEdruleDefFP{}}
% \newcommand*{\fsynCon}{\GRANULEdruleConF{}}
% \newcommand*{\fsynCaseP}{\GRANULEdruleCaseFP{}}
% \newcommand*{\fsynBox}{\GRANULEdruleBoxF{}}

\newcommand*{\synMuR}{ \inferrule*[right=$\mu_\textsc{R}$]
  {\Gamma \vdash [[ A ]] [ \mu X . A / X] \Rightarrow t \mid\ \Delta} {\Gamma \vdash \mu X . A \Rightarrow t \mid\ \Delta}}
\newcommand*{\synMuL}{ \inferrule*[right=$\mu_\textsc{L}$]
  { [[G]], x :_r [[ A]] [\mu X . [[ A ]] / X ] \vdash [[ B ]] \Rightarrow [[ t ]] \mid\ [[ D]]} {[[ G ]], x :_r \mu X . [[ A ]] \vdash [[ B ]] \Rightarrow [[ t]] \mid\ [[D]]}}

\newcommand*{\synMuRP}{ \inferrule*[right=$\mu_\textsc{R}$]
  {D ; \Sigma ; \Gamma \vdash [[ A ]] [ \mu X . A / X] \Rightarrow t \mid\ \Delta} { D ; \Sigma; \Gamma \vdash \mu X . A \Rightarrow t \mid\ \Delta}}
\newcommand*{\synMuLP}{ \inferrule*[right=$\mu_\textsc{L}$]
  { D ; \Sigma; [[G]], x :_r [[ A]] [\mu X . [[ A ]] / X ] \vdash [[ B ]] \Rightarrow [[ t ]] \mid\ [[ D]]} { D ; \Sigma ; [[ G ]], x :_r \mu X . [[ A ]] \vdash [[ B ]] \Rightarrow [[ t]] \mid\ [[D]]}}

\newcommand*{\fsynMuR}{ \inferrule*[right=$\mu_\textsc{R}$]
  {\Gamma ; \emptyset \vdash [[ A ]] [ \mu X . A / X] \Downarrow\ \Rightarrow t \mid\ \Delta} {\Gamma ; \emptyset \vdash \mu X . A \Downarrow\ \Rightarrow t \mid\ \Delta}}
\newcommand*{\fsynMuL}{ \inferrule*[right=$\mu_\textsc{L}$]
  { [[G]] ; [[ O ]], x :_r [[ A]] [\mu X . [[ A ]] / X ] \Uparrow\ \vdash [[ B ]] \Rightarrow [[ t ]] \mid\ [[ D]]} {[[ G ]]; [[O]], x :_r \mu X . [[ A ]] \Uparrow\ \vdash [[ B ]] \Rightarrow [[ t]] \mid\ [[D]]}}

\newcommand*{\fsynMuRP}{ \inferrule*[right=$\mu_\textsc{R}$]
  {[[Defs]]; \Sigma; \Gamma ; \emptyset \vdash [[ A ]] [ \mu X . A / X] \Downarrow\ \Rightarrow t \mid\ \Delta} { [[Defs ]] ; \Sigma ; \Gamma ; \emptyset \vdash \mu X . A \Downarrow\ \Rightarrow t \mid\ \Delta}}
\newcommand*{\fsynMuLP}{ \inferrule*[right=$\mu_\textsc{L}$]
  { [[ Defs ]]; \Sigma ; [[G]] ; [[ O ]], x :_r [[ A]] [\mu X . [[ A ]] / X ] \Uparrow\ \vdash [[ B ]] \Rightarrow [[ t ]] \mid\ [[ D]]} { [[ Defs ]] ; \Sigma ; [[ G ]]; [[O]], x :_r \mu X . [[ A ]] \Uparrow\ \vdash [[ B ]] \Rightarrow [[ t]] \mid\ [[D]]}}



% ------------ Polymorphic focusing rules

\newcommand*{\fsynRAsyncTransP}{
  \inferrule*[right=\fsynRAsyncTransName]
  {[[ Defs ; Sig ; G ; O async |- B => t ; D ]] \\ [[ B ]] \text{ not right async}}{[[ Defs ; Sig ; G ; O |- B async => t ; D]]}
}
%
\newcommand*{\fsynLAsyncTransP}{
  \inferrule*[right=\fsynLAsyncTransName]
  {[[ Defs ; Sig ; G, x : [A] r ; O async |- B => t ; D ]] \\ \text{A not left async}}{[[ Defs ; Sig ; G ; {O, x : [A] r} async |- B => t ; D]]}
}
%
\newcommand*{\fsynFocusRP}{
\inferrule*[right=\fsynFocusRName]
{ [[ Defs ]] ; [[ Sig ]] [[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ Defs ; Sig ; G ; . async |- B => t ; D]]}
}
%
\newcommand*{\fsynFocusRNoLabelP}{
\inferrule*[right=\fsynFocusRName]
{ [[ Defs ]] ; [[ Sig ]] ; [[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ Defs ; Sig ; G ; . async |- B => t ; D]]}
}
%
\newcommand*{\fsynFocusLP}{
\inferrule*[right=\fsynFocusLName]
  {[[ Defs ; Sig ; G ; {x : [A] r} sync |- B => t ; D]]}{[[ Defs ; Sig ; G, x : [A] r; . async |- B => t ; D]]}
}
%
\newcommand*{\fsynRSyncTransP}{
  \inferrule*[right=\fsynRSyncTransName]
  {[[ Defs ; Sig ; G ; . |-  A async => t ; D]]}{ [[ Defs ]] ; [[ Sig ]] ; \Gamma ; \emptyset \vdash [[ A]] \Downarrow [[t ]] \mid\ [[ D]]}
}
%
\newcommand*{\fsynLSyncTransP}{
  \inferrule*[right=\fsynLSyncTransName]
  {[[ Defs ; Sig ; G ; {x : [A] r} async |- B => t ; D]] \\ \text{ A not atomic and not left sync }}{[[ Defs ; Sig ; G ; {x : [A] r} sync |- B => t ; D]]}
}

\newcommand*{\fsynConP}{
              \inferrule*[Right=$\textsc{Con}_{\textsc{R}}$]
              { [[ ( Con Forall : B'1 - q1 .*. B'n - qn -> {K {A' Many}}) elem Defines ]]  \\\\
              [[ Sig |- inst {B1 - q1 .*. Bn - qn -> {K {A Many}}} {B'1 - q1 .*. B'n - qn -> {K {A' Many}}} ]]
              \\\\
               [[ Defs ]] ; [[ Sig ]] ; [[ G ]] ; \emptyset \vdash [[ Bi ]] \Downarrow\ \Rightarrow [[ ti ]] \mid\ [[ Di ]]}
              { [[ Defs ]] ; [[ Sig ]] ; [[  G ]] ; \emptyset \vdash [[{K {A Many}}]] \Downarrow\ \Rightarrow [[Con t1 ... tn]] \mid\ [[  {D1 + ... + Dn} ]]}
}
\newcommand*{\fsynBoxP}{
              \inferrule*[Right=$\Box_{\textsc{R}}$]
              { [[ Defs ]] ; [[ Sig ]] ; [[ G ]] ; \emptyset \vdash [[ A ]] \Downarrow\ \Rightarrow [[ t ]] \mid\ [[D]]}
              { [[ Defs ]] ; [[ Sig ]] ; [[ G ]] ; \emptyset \vdash [[ {[] r A} ]] \Downarrow\ \Rightarrow [[ [t] ]] \mid\ [[ r * D ]]}
}
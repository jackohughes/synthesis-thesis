
%%% LINEAR BASE NAMES AND RULES %%%
% Subtractive Rule Names
\newcommand{\subLinVarName}{\textsc{LinVar$^{-}$}}
\newcommand{\subGrVarName}{\textsc{GrVar$^{-}$}}
\newcommand{\subAbsName}{$\multimap^{-}_{R}$}
\newcommand{\subAppName}{$\multimap^{-}_{L}$}
\newcommand{\subBoxName}{$\square^{-}_{R}$}
\newcommand{\subUnboxName}{$\square^{-}_{L}$}
\newcommand{\subPairIntroName}{$\otimes^{-}_{R}$}
\newcommand{\subPairElimName}{$\otimes^{-}_{L}$}
\newcommand{\subSumIntroLname}{$\oplus1^{-}_{R}$}
\newcommand{\subSumIntroRname}{$\oplus2^{-}_{R}$}
\newcommand{\subSumElimName}{$\oplus^{-}_{L}$}
\newcommand{\subUnitIntroName}{1$^{-}_{R}$}
\newcommand{\subUnitElimName}{1$^{-}_{L}$}
\newcommand{\subDerName}{\textsc{der$^{-}$}}

% Additive Rule Names
\newcommand{\addLinVarName}{\textsc{LinVar$^{+}$}}
\newcommand{\addGrVarName}{\textsc{GrVar$^{+}$}}
\newcommand{\addDerName}{\textsc{der$^{+}$}}
\newcommand{\addAbsName}{$\multimap^{+}_{R}$}
\newcommand{\addAppName}{$\multimap^{+}_{L}$}
\newcommand{\addPruningAppName}{$\multimap'^{+}_{L}$}
\newcommand{\addBoxName}{$\square^{+}_{R}$}
\newcommand{\addUnboxName}{$\square^{+}_{L}$}
\newcommand{\addPairIntroName}{$\otimes^{+}_{R}$}
\newcommand{\addPruningPairIntroName}{$\otimes'^{+}_{R}$}
\newcommand{\addPairElimName}{$\otimes^{+}_{L}$}
\newcommand{\addSumIntroLName}{$\oplus1_{R}^{+}$}
\newcommand{\addSumIntroRName}{$\oplus2_{R}^{+}$}
\newcommand{\addSumElimName}{$\oplus^{+}_{L}$}
\newcommand{\addUnitIntroName}{1$^{+}_{R}$}
\newcommand{\addUnitElimName}{1$^{+}_{L}$}

% Focusing Subtractive Rule Names
\newcommand*{\fSubAbsName}{$\multimap^{-}_{R}$}
\newcommand*{\fSubRAsyncTransitionName}{$\Uparrow^{-}_{R}$}
\newcommand*{\fSubPairElimName}{$\otimes^{-}_{L}$}
\newcommand*{\fSubSumElimName}{$\oplus^{-}_{L}$}
\newcommand*{\fSubUnboxName}{$\square^{-}_{L}$}
\newcommand*{\fSubUnitElimName}{1$^{-}_{L}$}
\newcommand*{\fSubDerName}{der$^{-}$}
\newcommand*{\fSubLAsyncTransitionName}{$\Uparrow^{-}_{L}$}
\newcommand*{\fSubFocusRName}{focus$^{-}_{R}$}
\newcommand*{\fSubFocusLName}{focus$^{-}_{L}$}
\newcommand*{\fSubPairIntroName}{$\otimes^{-}_{R}$}
\newcommand*{\fSubSumIntroNameL}{$\oplus1_{R}^{-}$}
\newcommand*{\fSubSumIntroNameR}{$\oplus2_{R}^{-}$}
\newcommand*{\fSubBoxName}{$\square^{-}_{R}$}
\newcommand*{\fSubUnitIntroName}{1$^{-}_{R}$}
\newcommand*{\fSubRSyncTransitionName}{$\Downarrow^{-}_{R}$}
\newcommand*{\fSubAppName}{$\multimap^{-}_{L}$}
\newcommand*{\fSubLinVarName}{LinVar$^{-}$}
\newcommand*{\fSubGrVarName}{GrVar$^{-}$}
\newcommand*{\fSubLSyncTransitionName}{$\Downarrow^{-}_{L}$}

% Focusing Additive Rule Names
\newcommand*{\fAddAbsName}{$\multimap^{+}_{R}$}
\newcommand*{\fAddRAsyncTransitionName}{$\Uparrow^{+}_{R}$}
\newcommand*{\fAddPairElimName}{$\otimes^{+}_{L}$}
\newcommand*{\fAddSumElimName}{$\oplus^{+}_{L}$}
\newcommand*{\fAddUnboxName}{$\square^{+}_{L}$}
\newcommand*{\fAddUnitElimName}{1$^{+}_{L}$}
\newcommand*{\fAddDerName}{der$^{+}$}
\newcommand*{\fAddLAsyncTransitionName}{$\Uparrow^{+}_{L}$}
\newcommand*{\fAddFocusRName}{focus$^{+}_{R}$}
\newcommand*{\fAddFocusLName}{focus$^{+}_{L}$}
\newcommand*{\fAddPairIntroName}{$\otimes^{+}_{R}$}
\newcommand*{\fAddSumIntroNameL}{$\oplus1_{L}^{+}$}
\newcommand*{\fAddSumIntroNameR}{$\oplus2_{L}^{+}$}
\newcommand*{\fAddBoxName}{$\square^{+}_{R}$}
\newcommand*{\fAddUnitIntroName}{1$^{+}_{R}$}
\newcommand*{\fAddRSyncTransitionName}{$\Downarrow^{+}_{R}$}
\newcommand*{\fAddAppName}{$\multimap^{+}_{L}$}
\newcommand*{\fAddLinVarName}{LinVar$^{+}$}
\newcommand*{\fAddGrVarName}{GrVar$^{+}$}
\newcommand*{\fAddLSyncTransitionName}{$\Downarrow^{+}_{L}$}

% SUBTRACTIVE RULES
\newcommand*{\subLinVar}{
                             \inferrule*[right=\subLinVarName]
                             {\quad}{[[G, x : A |- A =>- x ; G]]}
  }

  \newcommand*{\subGrVar}{
      \inferrule*[right=\subGrVarName]
  {[[ exists s . r <= {s + 1} ]]}{[[G, x : [A] r |- A =>- x ; G , x : [A] s]]}
    }

  \newcommand*{\subAbs}{
      \inferrule*[right=\subAbsName]
  {[[G, x : A |- B =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G |- A -o B =>- \x. t ; D ]]}
    }
  \newcommand*{\subApp}{
  \inferrule*[right=\subAppName]
  {[[G, x2 : B |- C =>- t1 ; D1]] \qquad [[ x2 notin D1 ]] \qquad [[D1 |- A =>- t2 ; D2]]}{[[G, x1 : A -o B
      |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
    }
  \newcommand*{\subDer}{
      \inferrule*[right=\subDerName]
{[[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G, x : [A] r |- B =>- [x/y] t ; D, x : [A] s' ]]}
    }
  \newcommand*{\subBox}{
  \inferrule*[right=\subBoxName]
  {[[G |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; G - r * (G - D)]]}
    }
  \newcommand*{\subBoxAlt}{
  \inferrule*[right=R${\square'^{-}}$]
  {[[G / r |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; r * D ]]}
    }
  \newcommand*{\subUnbox}{
  \inferrule*[right=\subUnboxName]
    {[[ G, x2 : [A] r |- B =>- t ; D, x2 : [A] s ]] \\ 0 \sqsubseteq [[ s]]}{[[G, x1 : [] r A |- B =>- let [x2] = x1 in t ; D ]]}
    }
  \newcommand*{\subPairIntro}{
    \inferrule*[right=\subPairIntroName]
    {[[G |- A =>- t1 ; D1]] \\ [[ D1 |- B =>- t2 ; D2 ]]}{[[G |- Tup A B =>- pair t1 t2 ; D2]]}
    }
  \newcommand*{\subPairElim}{
    \inferrule*[right=\subPairElimName]
    {[[ G, x1 : A, x2 : B |- C =>- t2 ; D]] \\ [[ x1 notin D ]] \\ [[ x2 notin D ]]}
    {[[ G, x3 : Tup A B |- C =>- letpair x1 x2 = x3 in t2 ; D ]]}
    }
  \newcommand*{\subSumIntroL}{
    \inferrule*[right=\subSumIntroLname]
    {[[G |- A =>- t ; D]]}
    {[[G |- Sum A B =>- inl t ; D]]}
    }
  \newcommand*{\subSumIntroR}{
    \inferrule*[right=\subSumIntroRname]
    {[[G |- B =>- t ; D]]}
    {[[G |- Sum A B =>- inr t ; D]]}
    }
  \newcommand*{\subSumElim}{
    \inferrule*[right=\subSumElimName]
      {[[G, x2 : A |- C =>- t1 ; D1]] \quad\,
       [[G, x3 : B |- C =>- t2 ; D2]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
{\Gamma, x_1 : [[ Sum A B ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ | \ \Delta_1 \sqcap \Delta_2}
    }
  \newcommand*{\subUnitIntro}{
    \inferrule*[right=\subUnitIntroName]
    {\quad}
    {[[G |- Unit =>- () ; G]]}
    }
  \newcommand*{\subUnitElim}{
    \inferrule*[right=\subUnitElimName]
    {[[G |- C =>- t ; D]]}
    {[[G, x : Unit |- C =>- let () = x in t ; D]]}
    }

% ADDITIVE RULES
\newcommand*{\addLinVar}{
    \inferrule*[right=LinVar$^{+}$]
    {\quad}
    {[[G, x : A |- A =>+ x ; x : A]]}
  }

  \newcommand*{\addGrVar}{
    \inferrule*[right=GrVar$^{+}$]
    {\quad}
      {[[ G, x : [A] r |- A =>+ x ; x :[A] 1 ]] }
    }

  \newcommand*{\addAbs}{
    \inferrule*[right=\addAbsName]
    {[[G, x : A |- B =>+ t ; D, x : A]]}{[[G |- A -o B =>+ \x . t ; D]]}
    }
  \newcommand*{\addApp}{
    \inferrule*[right=\addAppName]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
    }
\newcommand*{\addPruneApp}{
\inferrule*[right=\addPruningAppName]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G - D1 |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
}
  \newcommand*{\addDer}{
\inferrule*[right=\addDerName]
{ [[ G, x : [A]s, y : A |- B =>+ t ; D, y : A ]] }
{ [[ G, x : [A]s |- B =>+ [x / y] t ; D + x : [A]1 ]] }
    }
  \newcommand*{\addBox}{
    \inferrule*[right=\addBoxName]
    {[[G |- A =>+ t ; D]]}{[[G |- [] r A =>+ [t] ; r * D ]]}
    }
  \newcommand*{\addUnbox}{
    \inferrule*[right=\addUnboxName]
    {[[ G, x2 : [A] r |- B =>+ t ; D ]] \\ \textit{if}\ [[x2 : [A] s]] \in
      [[D]]\ \textit{then}\ s \sqsubseteq r \ \textit{else}\  0 \sqsubseteq r}{[[G, x1 : [] r A |- B =>+
      let [x2] = x1 in t ; (D \ x2 ), x1 : [] r A ]]}
    }
  \newcommand*{\addPairIntro}{
    \inferrule*[right=\addPairIntroName]
    {[[G |- A =>+ t1 ; D1]] \\ [[G |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
    }
  \newcommand*{\addPrunePairIntro}{
    \inferrule*[right=\addPruningPairIntroName]
    {[[G |- A =>+ t1 ; D1]] \\ [[G - D1 |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
    }
  \newcommand*{\addPairElim}{
    \inferrule*[right=\addPairElimName]
    {[[ G, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}
    {[[ G, x3 : Tup A B |- C =>+ letpair x1 x2 = x3 in t2 ; D, x3 : Tup A B ]]}
    }
  \newcommand*{\addSumIntroL}{
    \inferrule*[right=\addSumIntroLName]
    {[[G |- A =>+ t ; D]]}
    {[[G |- Sum A B =>+ inl t ; D]]}
    }
  \newcommand*{\addSumIntroR}{
    \inferrule*[right=\addSumIntroRName]
    {[[G |- B =>+ t ; D]]}
    {[[G |- Sum A B =>+ inr t ; D]]}
    }
  \newcommand*{\addSumElim}{
    \inferrule*[right=\addSumElimName]
    {[[G, x2 : A |- C =>+ t1 ; D1, x2 : A]] \\ [[G, x3 : B |- C =>+ t2 ; D2,
      x3 : B ]]}
{\Gamma, x_1 : [[ Sum A B ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ |\ \Delta_1 \sqcup \Delta_2, [[ x1 : Sum A B ]]}
    }
  \newcommand*{\addUnitIntro}{
    \inferrule*[right=\addUnitIntroName]
    {\quad}
    {[[G |- Unit =>+ () ; .]]}
    }
  \newcommand*{\addUnitElim}{
    \inferrule*[right=\addUnitElimName]
    {[[G |- C =>+ t ; D]]}
    {[[G, x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
    }


% FOCUSED SUBTRACTIVE RULES
\newcommand*{\fSubAbsRule}{
    \inferrule*[right=\fSubAbsName,Lab=RightAsync]
    {[[G ; O, x : A |- B async =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G ; O |- {A -o B} async =>- \ x . t ; D]]}
}
\newcommand*{\fSubAbsRuleNoLabel}{
    \inferrule*[right=\fSubAbsName]
    {[[G ; O, x : A |- B async =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G ; O |- {A -o B} async =>- \ x . t ; D]]}
}
\newcommand*{\fSubRAsyncTransitionRule}{
  \inferrule*[right=\fSubRAsyncTransitionName]
  {[[ G ; O async |- C =>- t ; D ]] \\ [[ C ]] \text{ not right async}}{[[G ; O |-
  C async =>- t ; D]]}
}
\newcommand*{\fSubPairElimRule}{
    \inferrule*[right=\fSubPairElimName,lab=LeftAsync]
    {[[G ; {O, x1 : A, x2 : B} async |- C =>- t2 ; D ]] \\ [[ x1 notin D ]] \\ [[
  x2 notin D ]]}{[[G ; {O, x3 : Tup A B} async |- C =>- letpair x1 x2
    = x3 in t2 ; D]]}
}
\newcommand*{\fSubPairElimRuleNoLabel}{
    \inferrule*[right=\fSubPairElimName]
    {[[G ; {O, x1 : A, x2 : B} async |- C =>- t2 ; D ]] \\ [[ x1 notin D ]] \\ [[
  x2 notin D ]]}{[[G ; {O, x3 : Tup A B} async |- C =>- letpair x1 x2
    = x3 in t2 ; D]]}
}
\newcommand*{\fSubSumElimRule}{
    \inferrule*[right=\fSubSumElimName]
    {[[G ; {O, x2 : A} async |- C =>- t1 ; D1]] \quad\, [[ G ; {O, x3 : B} async |- C =>- t2 ; D2
      ]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
{\Gamma ; [[ {O, x1 :  Sum A B} async ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ | \ \Delta_1 \sqcap \Delta_2}
    % {[[G ; {O, x1 : A + B} async |- C =>- case x2 of inl x2 -> t1 | inr x3 -> t2 ; D1 ++- D2]]}
}
\newcommand*{\fSubUnboxRule}{
    \inferrule*[right=\fSubUnboxName]
    {[[G ; {O, x2 : [A] r} async |- B =>- t ; D, x2 : [A] s ]] \\ 0 \sqsubseteq [[ s]]}{[[G; {O, x1 : []
                                                      r A} async |- B =>- let [x2] = x1
                                                      in t ; D]]}
}
\newcommand*{\fSubUnitElimRule}{
    \inferrule*[right=\fSubUnitElimName]
    {[[G ; .|- C =>- t ; D]]}
    {[[G ; x : Unit |- C =>- let () = x in t ; D]]}
}
\newcommand*{\fSubDerRule}{
\inferrule*[right=\fSubDerName]
{[[ G ; {x : [A] s, y : A } async |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G ; {x : [A] r} async |- B =>- [x/y] t ; D, x : [A] s' ]]}
}
\newcommand*{\fSubLAsyncTransitionRule}{
  \inferrule*[right=\fSubLAsyncTransitionName]
  {[[G, x : A ; O async |- C =>- t ; D ]] \\ \text{ A not left async}}{[[G ; {O, x
  : A} async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusRRule}{
\inferrule*[right=\fSubFocusRName,lab=Focus]
  {[[G ; . |- C sync =>- t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusRRuleNoLabel}{
\inferrule*[right=\fSubFocusRName]
  {[[G ; . |- C sync =>- t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubFocusLRule}{
\inferrule*[right=\fSubFocusLName]
  {[[G ; {x : A} sync |- C =>- t ; D]]}{[[ G, x : A; . async |- C =>- t ; D]]}
}
\newcommand*{\fSubPairIntroRule}{
    \inferrule*[right=\fSubPairIntroName,lab=RightSync]
    {[[G ; . |- A sync =>- t1 ; D1]] \\ [[D1 ; . |- B sync =>- t2 ; D2 ]]}{[[G ; .
  |- {Tup A B} sync
    =>- pair t1 t2 ; D2]]}
}
\newcommand*{\fSubPairIntroRuleNoLabel}{
    \inferrule*[right=\fSubPairIntroName]
    {[[G ; . |- A sync =>- t1 ; D1]] \\ [[D1 ; . |- B sync =>- t2 ; D2 ]]}{[[G ; .
  |- {Tup A B} sync
    =>- pair t1 t2 ; D2]]}
}
\newcommand*{\fSubSumIntroRuleL}{
    \inferrule*[right=\fAddSumIntroNameL]
    {[[G ; . |- A sync =>- t ; D]]}{[[ G ; . |- {Sum A B} sync =>- inl t ; D ]]}
}
\newcommand*{\fSubSumIntroRuleR}{
    \inferrule*[right=\fAddSumIntroNameR]
    {[[G ; . |- B sync =>- t ; D]]}{[[ G ; . |- {Sum A B} sync =>- inr t ; D ]]}
}
\newcommand*{\fSubBoxRule}{
    \inferrule*[right=\fSubBoxName]
    {[[G; . |- A async =>- t ; D]]}{[[G ; . |- { [] r A} sync =>- t ; G - r * (G - D)]]}
}
\newcommand*{\fSubUnitIntroRule}{
    \inferrule*[right=\fSubUnitIntroName]
    {\quad}
    {[[G |- Unit =>- () ; G]]}
}
\newcommand*{\fSubRSyncTransitionRule}{
  \inferrule*[right=\fSubRSyncTransitionName]
  {[[ G ; . |-  A async =>- t ; D]]}{ [[ G ; . |- A sync =>- t ; D ]]}
}
\newcommand*{\fSubAppRule}{
    \inferrule*[right=\fSubAppName,lab=LeftSync]
    {[[ G ; {x2 : B} sync |- C =>- t1 ; D1 ]] \qquad [[ x2 notin D1 ]] \qquad  [[D1 ; . |- A sync =>- t2 ; D2]]}{[[G ; {x1 :
    A -o B} sync |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
}
\newcommand*{\fSubAppRuleNoLabel}{
    \inferrule*[right=\fSubAppName]
    {[[ G ; {x2 : B} sync |- C =>- t1 ; D1 ]] \qquad [[ x2 notin D1 ]] \qquad  [[D1 ; . |- A sync =>- t2 ; D2]]}{[[G ; {x1 :
    A -o B} sync |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
}
\newcommand*{\fSubLinVarRule}{
    \inferrule*[right=\fSubLinVarName]
    {\quad}{[[G ; {x : A} sync |- A =>- x ; G]]}
}
\newcommand*{\fSubGrVarRule}{
    \inferrule*[right=\fSubGrVarName]
    {[[ exists s . r <= {s + 1} ]]}{[[G ; {x : [A] r} sync |- A =>- x ; G, x : [A] s]]}
}
\newcommand*{\fSubLSyncTransitionRule}{
  \inferrule*[right=\fSubLSyncTransitionName]
  {[[G ; {x : A} async |- C =>- t ; D]] \\ \text{ A not atomic and not left sync}}{[[G ; {x : A} sync |- C =>- t ; D]]}
}

% FOCUSED ADDITIVE RULES
\newcommand*{\fAddAbsRule}{
    \inferrule*[right=\fAddAbsName, lab=RightAsync]
    {[[G ; O, x : A |- B async =>+ t ; D, x : A]]}{[[ G ; O |- {A -o B} async =>+
  \ x . t ; D]]}
}
\newcommand*{\fAddAbsRuleNoLabel}{
    \inferrule*[right=\fAddAbsName]
    {[[G ; O, x : A |- B async =>+ t ; D, x : A]]}{[[ G ; O |- {A -o B} async =>+
  \ x . t ; D]]}
}
\newcommand*{\fAddRAsyncTransitionRule}{
  \inferrule*[right=\fAddRAsyncTransitionName]
  {[[ G ; O async |- C =>+ t ; D ]] \\ [[ C ]] \text{ not right async}}{[[G ; O |-
  C async =>+ t ; D]]}
}
\newcommand*{\fAddPairElimRule}{
    \inferrule*[right=\fAddPairElimName,lab=LeftAsync]
    {[[G ; O, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}{[[G ; O, x3 : Tup A B |- C =>+ letpair x1 x2
  = x3 in t2 ; D, x3 : Tup A B ]]}
}
\newcommand*{\fAddPairElimRuleNoLabel}{
    \inferrule*[right=\fAddPairElimName]
    {[[G ; O, x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}{[[G ; O, x3 : Tup A B |- C =>+ letpair x1 x2
  = x3 in t2 ; D, x3 : Tup A B ]]}
}
\newcommand*{\fAddSumElimRule}{
    \inferrule*[right=\fAddSumElimName]
    {[[G ; {O, x2 : A} async |- C =>+ t1 ; D1, x2 : A]] \\ [[ G ; {O, x3 : B} async |- C =>+ t2 ;
    D2, x3 : B
    ]]}
  {[[ G ]] ; [[ {O, x1 : Sum A B} async ]] \vdash C \Rightarrow^- \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} \ |\ \Delta_1 \sqcup \Delta_2, [[ x1 : Sum A B ]]}
}
\newcommand*{\fAddUnboxRule}{
    \inferrule*[right=\fAddUnboxName]
    {[[G ; {O, {x2 : [A] r async}} |- B =>+ t ; D]] \\ \textit{if}\ [[x2 : [A] s]]
                                                               \in [[D]]\ \textit{then}\ [[s]]
                                                               \sqsubseteq [[ r]]\ \textit{else}\  0
   \sqsubseteq [[ r ]]}
  {[[G ; O, x1 : [] r A |- B =>+ let [x2] = x1 in t ; (D \ x2), x1 : [] r A]]}
}
\newcommand*{\fAddUnitElimRule}{
    \inferrule*[right=\fAddUnitElimName]
    {[[G ; . |- C =>+ t ; D]]}
    {[[G ; x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
}
\newcommand*{\fAddDerRule}{
  \inferrule*[right=\fAddDerName]
  { [[ G ; {x : [A]s, y : A} async |- B =>+ t ; D, y : A ]] }
  { [[ G ; x : [A]s async |- B =>+ [x / y] t ; D + x : [A] 1 ]] }
}
\newcommand*{\fAddLAsyncTransitionRule}{
  \inferrule*[right=\fAddLAsyncTransitionName]
  {[[G, x : A ; O async |- C =>+ t ; D ]] \\ \text{ A not left async}}{[[G ; {O, x
  : A} async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusRRule}{
\inferrule*[right=\fAddFocusRName,lab=Focus]
  {[[G ; . |- C sync =>+ t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusRRuleNoLabel}{
\inferrule*[right=\fAddFocusRName]
  {[[G ; . |- C sync =>+ t ; D]] \\ \text{ C not atomic}}{[[ G ; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddFocusLRule}{
\inferrule*[right=\fAddFocusLName]
  {[[G ; {x : A} sync |- C =>+ t ; D]]}{[[ G, x : A; . async |- C =>+ t ; D]]}
}
\newcommand*{\fAddPairIntroRule}{
    \inferrule*[right=\fAddPairIntroName,lab=RightSync]
    {[[G ; . |- A sync =>+ t1 ; D1]] \\ [[G ; . |- B sync =>+ t2 ; D2 ]]}{[[G
  ; . |- {Tup A B} sync
    =>+ pair t1 t2 ; D1 + D2]]}
}
\newcommand*{\fAddPairIntroRuleNoLabel}{
    \inferrule*[right=\fAddPairIntroName]
    {[[G ; . |- A sync =>+ t1 ; D1]] \\ [[G ; . |- B sync =>+ t2 ; D2 ]]}{[[G
  ; . |- {Tup A B} sync
    =>+ pair t1 t2 ; D1 + D2]]}
}
\newcommand*{\fAddSumIntroRuleL}{
    \inferrule*[right=\fAddSumIntroNameL]
    {[[G ; . |- A sync =>+ t ; D]]}{[[ G ; . |- {Sum A B} sync =>+ inl t ; D ]]}
}
\newcommand*{\fAddSumIntroRuleR}{
    \inferrule*[right=\fAddSumIntroNameR]
    {[[G ; . |- B sync =>+ t ; D]]}{[[ G ; . |- {Sum A B} sync =>+ inr t ; D ]]}
}
\newcommand*{\fAddBoxRule}{
    \inferrule*[right=\fAddBoxName]
    {[[G; . |- A async =>+ t ; D]]}{[[G ; . |- { [] r A} sync =>+ [t] ; r * D]]}
}
\newcommand*{\fAddUnitIntroRule}{
    \inferrule*[right=\fAddUnitIntroName]
    {\quad}
    {[[G ; . |- Unit =>+ () ; .]]}
}
\newcommand*{\fAddRSyncTransitionRule}{
  \inferrule*[right=\fAddRSyncTransitionName]
  {[[ G ; . |-  A async =>+ t ; D]]}{ [[ G ; . |- A sync =>+ t ; D ]]}
}
\newcommand*{\fAddAppRule}{
    \inferrule*[right=\fAddAppName,lab=LeftSync]
    {[[ G ; {x2 : B} sync |- C =>+ t1 ; D1, x2 : B]] \\ [[G ; . |- A sync =>+ t2
  ; D2]]}{[[G ; { x1 :
  A -o B } sync |- C =>+ [(x1 t2) / x2] t1 ; (D1 + D2), x1: A -o B ]]}
}
\newcommand*{\fAddAppRuleNoLabel}{
    \inferrule*[right=\fAddAppName]
    {[[ G ; {x2 : B} sync |- C =>+ t1 ; D1, x2 : B]] \\ [[G ; . |- A sync =>+ t2
  ; D2]]}{[[G ; { x1 :
  A -o B } sync |- C =>+ [(x1 t2) / x2] t1 ; (D1 + D2), x1: A -o B ]]}
}
\newcommand*{\fAddLinVarRule}{
    \inferrule*[right=\fAddLinVarName]
  {\quad}{[[G ; x : A |- A =>+ x ; x : A]]}
}
\newcommand*{\fAddGrVarRule}{
    \inferrule*[right=\fAddGrVarName]
    {\quad}{[[G ; x : [A] r |- A =>+ x ; x : [A] 1]]}
}
\newcommand*{\fAddLSyncTransitionRule}{
  \inferrule*[right=\fAddLSyncTransitionName]
  {[[G ; {x : A} async |- C =>+ t ; D]] \\ \text{ A not atomic and not left sync
  }}{[[G ; {x : A} sync |- C =>+ t ; D]]}
}

% ADDITIVE PRUNING FOCUS RULES

\newcommand*{\fAddAltAppName}{$\multimap'^{+}_{L}$}
\newcommand*{\fAddAltPairIntroName}{$\otimes'^{+}_{R}$}

\newcommand*{\fAddAltAppRule}{
    \inferrule*[right=\fAddAltAppName]
    {[[G ; x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G - D1 ; . |- A =>+ t2 ; D2
      ]]}{[[G ; x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
}
\newcommand*{\fAddAltPairIntroRule}{
    \inferrule*[right=\fAddAltPairIntroName]
    {[[G ; . |- A =>+ t1 ; D1]] \\ [[G - D1 ; . |- B =>+ t2 ; D2]]}
    {[[G ; . |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
}






%%% GRADED BASE NAMES AND RULES %%%

% Typing renames
\renewcommand{\GRANULEdruleTyVarName}{$\textsc{Var}$}
\renewcommand{\GRANULEdruleTyAbsName}{$\textsc{Abs}$}
\renewcommand{\GRANULEdruleTyAppName}{$\textsc{App}$}
\renewcommand{\GRANULEdruleTyConName}{$\textsc{Con}$}
\renewcommand{\GRANULEdruleTyCaseName}{$\textsc{Case}$}
\renewcommand{\GRANULEdruleTyPrName}{$\textsc{Pr}$}
\renewcommand{\GRANULEdruleTyApproxName}{$\textsc{Approx}$}

% Pattern typing renames
\renewcommand{\GRANULEdrulePatWildName}{$\textsc{PWild}$}
\renewcommand{\GRANULEdrulePatVarName}{$\textsc{PVar}$}
\renewcommand{\GRANULEdrulePatBoxName}{$\textsc{PBox}$}
\renewcommand{\GRANULEdrulePatConName}{$\textsc{PCon}$}

% Synthesis rule names

% Focusing synhtesis rule names
\newcommand*{\fsynRAsyncTransName}{$\Uparrow_{\textsc{R}}$}
\newcommand*{\fsynLAsyncTransName}{$\Uparrow_{\textsc{L}}$}
\newcommand*{\fsynFocusRName}{$\textsc{Foc}_{\textsc{R}}$}
\newcommand*{\fsynFocusLName}{$\textsc{Foc}_{\textsc{L}}$}
\newcommand*{\fsynRSyncTransName}{$\Downarrow_{\textsc{R}}$}
\newcommand*{\fsynLSyncTransName}{$\Downarrow_{\textsc{L}}$}

% GRADED BASE TYPING RULES
\newcommand*{\tyVar}{\GRANULEdruleTyVar{}}
\newcommand*{\tyAbs}{\GRANULEdruleTyAbs{}}
\newcommand*{\tyApp}{\GRANULEdruleTyApp{}}
\newcommand*{\tyApprox}{\GRANULEdruleTyApprox{}}
\newcommand*{\tyPr}{\GRANULEdruleTyPr{}}
\newcommand*{\tyCon}{\GRANULEdruleTyCon{}}
\newcommand*{\tyCase}{\GRANULEdruleTyCase{}}


% GRADED BASE SYNTHESIS RULES
\newcommand*{\synVar}{\GRANULEdruleVar{}}
\newcommand*{\synAbs}{\GRANULEdruleAbs{}}
\newcommand*{\synApp}{\GRANULEdruleApp{}}
\newcommand*{\synCon}{\GRANULEdruleCon{}}
\newcommand*{\synConAlt}{\GRANULEdruleConAlt{}}
\newcommand*{\synCase}{\GRANULEdruleCase{}}
\newcommand*{\synCaseAlt}{\GRANULEdruleCaseAlt{}}
\newcommand*{\synCaseAltAlt}{\GRANULEdruleCaseAltAlt{}}
\newcommand*{\synBox}{\GRANULEdruleBox{}}
\newcommand*{\synUnbox}{\GRANULEdruleUnbox{}}
\newcommand*{\synCaseSub}{\GRANULEdruleCaseSub{}}


\newcommand*{\fsynVar}{\GRANULEdruleVarF{}}
\newcommand*{\fsynAbs}{\GRANULEdruleAbsF{}}
\newcommand*{\fsynUnbox}{\GRANULEdruleUnboxF{}}
\newcommand*{\fsynApp}{\GRANULEdruleAppF{}}
\newcommand*{\fsynCon}{\GRANULEdruleConF{}}
\newcommand*{\fsynCase}{\GRANULEdruleCaseF{}}
\newcommand*{\fsynBox}{\GRANULEdruleBoxF{}}

\newcommand*{\fsynRAsyncTrans}{
  \inferrule*[right=\fsynRAsyncTransName]
  {[[ G ; O async |- B => t ; D ]] \\ [[ B ]] \text{ not right async}}{[[G ; O |-
  B async => t ; D]]}
}
%
\newcommand*{\fsynLAsyncTrans}{
  \inferrule*[right=\fsynLAsyncTransName]
  {[[G, x : A ; O async |- B => t ; D ]] \\ \text{A not left async}}{[[G ; {O, x
  : A} async |- B => t ; D]]}
}
%
\newcommand*{\fsynFocusR}{
\inferrule*[right=\fsynFocusRName,lab=Focus]
{[[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ G ; . async |- B =>+ t ; D]]}
}
%
\newcommand*{\fsynFocusRNoLabel}{
\inferrule*[right=\fsynFocusRName]
{[[G ]] ; \emptyset \vdash [[ B ]] \Downarrow\ \Rightarrow [[t]] \mid\ [[D]]
  \\ \text{B not atomic}}{[[ G ; . async |- B =>+ t ; D]]}
}
%
\newcommand*{\fsynFocusL}{
\inferrule*[right=\fsynFocusLName]
  {[[G ; {x : A} sync |- B => t ; D]]}{[[ G, x : A; . async |- B => t ; D]]}
}
%
\newcommand*{\fsynRSyncTrans}{
  \inferrule*[right=\fsynRSyncTransName]
  {[[ G ; . |-  A async => t ; D]]}{ [[ G ; . |- A sync => t ; D ]]}
}
%
\newcommand*{\fsynLSyncTrans}{
  \inferrule*[right=\fsynLSyncTransName]
  {[[G ; {x : A} async |- B => t ; D]] \\ \text{ A not atomic and not left sync
  }}{[[G ; {x : A} sync |- B => t ; D]]}
}

% \newcommand*{\fsynCaseSub}{\GRANULEdruleCaseSub{}}
% \newcommand*{\fsynCase}{\GRANULEdruleCase{}}
% \newcommand*{\synCaseAltAlt}{\GRANULEdruleCaseAltAlt{}}

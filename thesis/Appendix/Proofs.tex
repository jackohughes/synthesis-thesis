\chapter{Proofs}
\label{appendix:proofs}
\section{Proofs for the Linear-Base Calculi}
\label{sec:linear-proofs}
This section gives the proofs of Lemma~\ref{lemma:subSynthSound} and
Lemma~\ref{lemma:addSynthSound}, along with soundness results for the
additive pruning variant.

We first state and prove some intermediate results about context manipulations
which are needed for the main lemmas.

\begin{definition}[Context approximation]
For contexts $[[ G1 ]]$, $[[ G2 ]]$ then:
%
\begin{align*}
\begin{array}{c}
\dfrac{}{[[ . <<= . ]]}
\qquad
\dfrac{[[ G1 ]] \sqsubseteq [[ G2 ]]}
      {[[ G1, x : A ]] \sqsubseteq [[ G2, x : A ]]}
\qquad \\[1.5em]
\dfrac{[[ G1 ]] \sqsubseteq [[ G2 ]] \qquad [[ r ]] \sqsubseteq [[ s ]]}
      {[[ G1, x : [A] r ]] \sqsubseteq [[ G2, x : [A] s ]]}
\qquad
\dfrac{ [[ G1 ]] \sqsubseteq [[ G2 ]] \qquad 0 \sqsubseteq [[ s ]]}
      { [[ G1 ]] \sqsubseteq [[  {G2, x : [A] s} ]]}
\end{array}
\end{align*}
%
This is actioned in type checking by iterative application of $\textsc{Approx}$.
\end{definition}

\begin{restatable}[$[[G + (G' - G'')]] \sqsubseteq [[(G + G') - G'']]$]{lemma}{contextLemma1}
  \label{lemma:contextLemma1}
\end{restatable}

\begin{proof}
  Induction over the structure of both $[[G']]$ and $[[G'']]$. The possible forms of
  $[[G']]$ and $[[G'']]$ are considered in turn:
  \begin{enumerate}
    \item $[[G']]$ = $\emptyset$ and $[[G'']]$ = $\emptyset$\\
      We have:
      \begin{align*}
        ([[G]] + \emptyset) - \emptyset = [[G]] + (\emptyset - \emptyset)
      \end{align*}
      From definitions~\ref{def:contextAdd} and~\ref{def:contextSub}, we know that
      on the left hand side:
      \begin{align*}
        ([[G]] + \emptyset) - \emptyset &= [[G]] + \emptyset \\
                                &= [[G]]
      \end{align*}
      and on the right-hand side:
      \begin{align*}
        [[G]] + (\emptyset - \emptyset) &= [[G]] + \emptyset \\
                                &= [[G]]
      \end{align*}
      making both the left and right hand sides equivalent:
      \begin{align*}
        [[G]] = [[G]]
      \end{align*}
    \item $[[G']]$ = $[[ G', x : A ]]$ and $[[G'']]$ = $\emptyset$\\
      We have
      \begin{align*}
        ([[G]] + [[G', x : A]]) - \emptyset = [[G]] + ([[G, x : A]] - \emptyset)
      \end{align*}
      From definitions~\ref{def:contextAdd} and~\ref{def:contextSub}, we know that
      on the left hand side we have:
      \begin{align*}
        ([[G]] + [[G', x : A]]) - \emptyset &= ([[G]], [[G']]), [[x : A]] - \emptyset \\
                                        &= ([[G]], [[G']]), [[x : A]]
      \end{align*}
      and on the right hand side:
      \begin{align*}
        [[G]] + ([[G, x : A]] - \emptyset) &= [[G]] + [[G', x : A]]\\
                                       &= ([[G]], [[G']], [[x : A]])
      \end{align*}
      making both the left and right hand sides equal:
      \begin{align*}
        ([[G]],[[G']]), [[x : A]] = ([[G]],[[G']]), [[x : A]]
      \end{align*}


    \item $[[G']]$ = $[[ G', x : A ]]$ and $[[G'']]$ = $[[G'', x : A]]$\\
      We have
      \begin{align*}
        ([[G]] + [[G', x : A]]) - [[G'', x : A]] = [[G]] + ([[G', x : A]] -
        [[G'', x : A]])
      \end{align*}
      From definitions~\ref{def:contextAdd} and~\ref{def:contextSub}, we know that
      on the left hand side we have:
      \begin{align*}
        ([[G]] + [[G', x : A]]) - [[G'', x : A]] &= ([[G]],[[G']]), [[x : A]] -
                                                   [[G'', x : A]] \\
                                                 &= [[G]], [[G']] - [[G'']]
      \end{align*}
      and on the right hand side:
      \begin{align*}
        [[G]] + ([[G', x : A]] - [[G'', x : A]]) &= [[G]] + ([[G']] - [[G'']]) \\
                                                &= [[G]], [[G']] - [[G'']]
      \end{align*}
      making both the left and right hand sides equivalent:
      \begin{align*}
        [[G]], [[G']] - [[G'']] = [[G]], [[G']] - [[G'']]
      \end{align*}

    \item $[[G']]$ = $[[ G', x : [A] r ]]$ and $[[G'']]$ = $\emptyset$\\
      We have
      \begin{align*}
        ([[G]] + [[G', x : [A] r]]) - \emptyset = [[G]] + ([[x : [A] r]] - \emptyset)
      \end{align*}
      From definitions~\ref{def:contextAdd} and~\ref{def:contextSub}, we know that
      on the left hand side we have:
      \begin{align*}
        ([[G]] + [[G', x : [A] r]]) - \emptyset &= ([[G]] + [[G', x : [A] r ]]) \\
                                            &= ([[G]], [[G']]), [[x : [A] r]]
      \end{align*}
      and on the right hand side:
      \begin{align*}
        [[G]] + ([[G', x : [A] r]] - \emptyset) &= [[G]] + ([[G', x : [A] r]])
                                            &= ([[G]],[[G']]),[[x : [A] r]]
      \end{align*}
      making both the left and right hand sides equivalent:
      \begin{align*}
        ([[G]],[[G']]),[[x : [A] r]] = ([[G]],[[G']]),[[x : [A] r]]
      \end{align*}


    \item $[[G']]$ = $[[ G', x : [A] r ]]$ and $[[G'']]$ = $[[G'', x :
      [A] s]]$\\

      Thus we have (for the LHS of the inequality term):
      %
       \begin{align*}
        [[G]] + ([[G', x : [A] r]] - [[G'', x : [A] s]])
      \end{align*}
      %
    which by context subtraction yields:
      \begin{align*}
       [[G]] + ([[G', x :[A] r]] - [[G'', x : [A] s]]) &= [[G]] + ([[G']] -
                                                         [[G'']]), [[x : [A] q']]
      \end{align*}
      where:
      \begin{align*}
        \exists q' . [[r]] \sqsupseteq [[q']] + [[s]]
\quad \maximal{q'}{\hat{q'}}{r}{\hat{q'}+s} \qquad (2)
      \end{align*}
       %
       And for the LHS of the inequality, from
       definitions~\ref{def:contextAdd} and~\ref{def:contextSub}
       we have:
      \begin{align*}
        ([[G]] + [[G', x : [A] r]]) - [[G'', x : [A] s]] &
= ([[G]] + [[G']]), [[x : [A] r]] - [[G'', x  : [A] s]] \\
  &= (([[G]] + [[G']]) -  [[G'']]), [[ x : [A]  r ]] - [[ x : [A]  s ]] \\
  &= (([[G]] + [[G']]) -  [[G'']]), [[x : [A] q]]
      \end{align*}
      where:
      \begin{align*}
        \exists q . [[r]] \sqsupseteq [[q]] + [[s]]
\quad \maximal{q}{\hat{q}}{r}{\hat{q}+s} \qquad (1)
      \end{align*}
    %
    %Applying maximality (1) to $q'$ yields that $[[q' <= q]]$
    Applying $\exists q . [[r]] \sqsupseteq [[q]] + [[s]]$ to
    maximality (2) (at $\hat{q'} = q$) then yields that $q \sqsubseteq q'$.

    Therefore, applying induction, we derive:
    %
     \begin{align*}
      \dfrac{[[(G + (G' - G''))]] \sqsubseteq [[((G + G') - G'') ]] \qquad [[ q ]] \sqsubseteq [[ q' ]]}
             {[[ {(G + (G' - G'')), x : [A] q}]] \sqsubseteq [[{((G + G') - G''), x : [A] q'} ]]}
     \end{align*}
    %
    satisfying the lemma statement.
    %\dnote{if partial order then $[[ q ]] = [[ q' ]]$, but we can be weaker
    %  and weaken Lemma 4 to be a context approximation.}
    %  making both the left and right hand sides equivalent:

  \end{enumerate}
\end{proof}

\begin{restatable}[$[[(G - G') + G']] \sqsubseteq [[G]]$]{lemma}{contextLemma2}
  \label{lemma:contextLemma2}
\end{restatable}
\begin{proof}
 The proof follows by induction over the structure of $[[G']]$. The possible
 forms of $[[G']]$ are considered in turn:
 \begin{enumerate}
     \item $[[G']]$ = $\emptyset$\\
     We have:
     \begin{align*}
       ([[G]] - \emptyset) + \emptyset = [[G]]
     \end{align*}
     From definition~\ref{def:contextSub}, we know that:
     \begin{align*}
       [[G]] - \emptyset = [[G]]
     \end{align*}
     and from definition~\ref{def:contextAdd}, we know:
     \begin{align*}
       [[G]] + \emptyset = [[G]]
     \end{align*}
     giving us:
     \begin{align*}
       [[G]] = [[G]]
     \end{align*}


     \item $[[G']]$ = $[[G'', x : A]]$\\
     and let $[[ G ]] = [[ G', x : A ]]$.

     \begin{align*}
       ([[G', x : A]] - [[G'', x : A]]) + [[G'', x : A]] = [[G]]
     \end{align*}
     From definition~\ref{def:contextAdd}, we know that:
     \begin{align*}
       ([[G', x : A]] - [[G'', x : A]]) + [[G'', x : A]]
       & =  (([[G' - G'']]) + [[G'']]), [[x : A]] \\
 \textit{induction}  & = [[ G', x : A ]] \\
                     & = [[ G ]]
     \end{align*}
     thus satisfying the lemma statement by equality.

     \item $[[G']]$ = $[[G'', x : [A] r]]$\\
       and let $[[ G ]] = [[ G', x : [A] s ]]$.

     We have:
     \begin{align*}
       ([[G', x : [A] s]] - [[G'', x : [A] r]]) + [[G'', x : [A] r ]]
     \end{align*}
     From definition~\ref{def:contextSub}, we know that:
     %

       \begin{align*}
      & ([[G', x : [A] s ]] - [[G'', x : [A] r ]]) + [[G'', x : [A] r]] \\
    =\ & [[(G' - G''), x : [A] q ]] + [[G'', x : [A] r]] \\
    =\ & [[((G' - G'') + G''), x : [A] {q + r} ]]
       \end{align*}

     %
     where $[[ s >= q + r ]]$ and $\maximal{q}{q'}{s}{q' + r}$.

     Then by induction we derive the ordering:
     %
     \begin{align*}
       \dfrac{[[ ((G' - G'') + G'') ]] \sqsubseteq [[ G' ]] \qquad [[ q + r ]]  \sqsubseteq [[ s ]]}
            {[[ {((G' - G'') + G''), x : [A] {q + r}} ]] \sqsubseteq [[ {G', x : [A]s} ]]}
     \end{align*}
     %
     which satifies the lemma statement.
 \end{enumerate}
\end{proof}

\begin{lemma}[Context negation]
\label{lemma:context-neg}
For all contexts $[[ G ]]$:
\begin{align*}
\emptyset \sqsubseteq [[ G - G ]]
\end{align*}
\end{lemma}

\begin{proof}
By induction on the structure of $[[ G ]]$:
%
\begin{itemize}
\item $[[ G ]] = \emptyset$ Trivial.

\item $[[ G ]] = [[ G', x : A ]]$ then
$[[ (G' , x : A) - (G', x : A) ]] = [[ G' - G' ]]$ so proceed by
induction.

\item $[[ G ]] = [[ G', x : [A] r ]]$ then
$\exists q. $
$[[ (G' , x : [A]r) - (G', x : [A]r) ]] = [[ (G - G'), x : [A]q ]]$

such that $[[ r ]] \sqsupseteq [[ q + r ]]$ and
$\maximal{q}{q'}{r}{q'+r}$.

Instantiating maximality with $q' = 0$ and reflexivity then we have
$0 \sqsubseteq [[ q ]]$. From this, and the inductive hypothesis, we can construct:
%
\begin{align*}
\dfrac{ \emptyset \sqsubseteq [[ (G - G') ]] \quad 0 \sqsubseteq [[ q ]]}
{ \emptyset \sqsubseteq [[{(G - G'), x : [A] q}  ]] }
\end{align*}
%
\end{itemize}
%
\end{proof}

\begin{lemma}
\label{lemma:contexts-subsub}
For all contexts $[[ G1 ]]$, $[[ G2 ]]$, where
$[[ [ G2 ] ]]$ (i.e., $[[ G2 ]]$ is all graded)
then:
%
\begin{align*}
[[ G2 ]] \sqsubseteq [[ G1 - (G1 - G2) ]]
\end{align*}
\end{lemma}

\begin{proof}
By induction on the structure of $[[ G2 ]]$.

\begin{itemize}
\item $[[ G2 ]] = \sqsubseteq$

Then $[[ G1 - (G1 - .) ]] = [[ G1 - G1 ]]$.

By Lemma~\ref{lemma:context-neg}, then $ \emptyset \sqsubseteq [[ (G1 - G1) ]]$
satisfying this case.

\item $[[ G2 ]] = [[ G2', x : [A] s ]]$

By the premises $[[ G1 ]] \sqsubseteq [[ G2 ]]$ then we can
assume $[[ x ]] \in [[ G1 ]]$ and thus (by context
rearrangement) $[[ G1', x : [A] r]]$.

Thus we consider $[[ (G1', x : [A] r) - ((G1', x : [A] r) - (G2', x : [A] s)) ]]$.

\begin{align*}
  \; & [[ (G1', x : [A] r) - ((G1', x : [A] r) - (G2', x : [A] s)) ]] \\
= \; & [[ (G1', x : [A] r) - ((G1' - G2'), x : [A] q) ]] \\
= \; & [[ (G1' - (G1' - G2')), x : [A] q' ]]
\end{align*}
%
where (1) $[[ exists q . r >= q + s ]]$ with
(2) $(\maximal{q}{\hat{q}}{r}{\hat{q}+s})$

and (3) $[[ exists q' . r >= q' + q ]]$
with (4) $(\maximal{q'}{\hat{q'}}{r}{\hat{q'}+s})$.

Apply (1) to (4) by letting $\hat{q'} = {s}$
and by commutativity of $+$ then we get that
$[[q' >= s]]$.

By induction we have that
%
\begin{align*}
[[ G1' ]] \sqsubseteq [[  {G1' - (G1' - G2')} ]] \tag{ih}
\end{align*}
%
%
Thus we get that:
%
\begin{align*}
\dfrac{[[ s ]] \sqsubseteq [[ q' ]] \quad
[[ G1' ]] \sqsubseteq [[  {G1' - (G1' - G2')} ]]}
{ [[ {G1', x : [A] s} ]] \sqsubseteq [[  {(G1' - (G1' - G2')), x : [A] q'} ]] }
\end{align*}
%
\item $[[ G2 ]] = [[ G2', x : A]]$ Trivial as it violates the grading
  condition of the premise.
\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Soundness of the Subtractive Graded Linear Typing Calculus}
\label{proof:linear-sub-sound}
\subSynthSound*

\begin{proof}
Structural induction over the synthesis rules. Each of the possible synthesis
rules are considered in turn.

\begin{enumerate}[itemsep=1em]
  \item Case \subLinVarName \\
  In the case of linear variable synthesis, we have the derivation:
  \[
    \subLinVar{}
  \]
  %
  By the definition of context subtraction,
  $([[G, x : A]]) - [[ G ]] = [[ x : A]]$, thus we
  can construct the following typing derivation, matching the
  conclusion:
  \[
    \inferrule*[Right=\textsc{Var}]
    {\quad}
    {[[ x : A |- x : A ]]}
  \]

\item Case \subGrVarName{} \\
    Matching the form of the lemma, we have the derivation:
    \[
    \subGrVar{}
    \]
    %
    By the definition of context subtraction,
    $ [[ (G, x : [A]r) - (G, x : [A]s) ]] = [[ x : [A] q ]]$
    where (1) $[[ exists q . r >= q + s ]]$ and $\maximal{q}{q'}{r}{q' + s}$.

    Applying maximality (1) with $q = 1$ then we have that $1 \sqsubseteq [[ q ]]$ (*)

    Thus, from this we can construct the typing derivation, matching the conclusion:
    %
    \[
    \inferrule*[Right=\textsc{Approx}]
    {
      \inferrule*[Right=\textsc{Der}]
        {\inferrule*[Right=\textsc{Var}]
          {\quad}
          {[[ x : A |- x : A ]]}
        }
        {[[ x : [A] 1 |- x : A ]] \qquad 1 \sqsubseteq [[ q ]] \; (*)}
    }{
      [[ x : [A] q |- x : A ]]
    }
    \]

  \item Case \subAbsName \\
    We thus have the derivation:
    %
    \[
    \subAbs{}
    \]
    %
    By induction we then have that:
    %
    \[
      [[ (G, x : A) - D |- t : B ]]
    \]
    %
    Since $[[x notin D]]$ then by the definition of context
    subtraction we have that $[[ (G, x : A) - D ]] = [[ (G - D), x : A ]]$.
    From this, we can construct the following derivation, matching the
    conclusion:
    %
    \[
    \inferrule*[Right=Abs]
    {[[ (G - D) , x : A |- t : B]]}{[[ G - D |- \x. t : A -o B ]]}
    \]


  \item Case \subAppName \\
    %
    Matching the form of the lemma, the application derivation is:
    \[
      \subApp{}
    \]
    %
    By induction, we have that:
    %
      \begin{align*}
        [[ (G, x2 : B) - D1 |- t1 : C ]] \tag{ih1} \\
        [[ D1 - D2 |- t2 : A ]] \tag{ih2}
      \end{align*}
    %
    By the definition of context subtraction and since $[[ x2 notin D1
    ]]$ then (ih1) is equal to:
    %
      \begin{align*}
        [[ (G - D1), x2 : B |- t1 : C ]] \tag{ih1'}
      \end{align*}
    %
    We can thus construct the following typing derivation, making use of
    of the admissibility of linear substitution
    (Lemma~\ref{lemma:substitution}):
    %
    {\scriptsize{
    \[
    \hspace{-8em}
    \inferrule*[Right=\textsc{app}]
    {\inferrule*[right=\textsc{abs}, leftskip=5em]
       {[[(G - D1), x2 : B -o C |- t1 : C]]}
       {[[ G - D1 |- \x2. t1 : B -o C ]]} \\
    \inferrule*[right=\textsc{app}, rightskip=15em]
    {\inferrule*[right=\textsc{var}, leftskip=2em]
    {\quad}
    {[[x1 : A -o B |- x1 : A -o B ]]} \\ {[[  D1 - D2 |- t2 : A ]]}}  {[[(D1 -
    D2)]], [[x1 : A -o B |- x1 t2 : B]]}}
    {[[(G - D1) + (D1 - D2)]] ,[[x1 : A -o B |- [(x1 t2) / x2] t1 : C]]}
    \]
    }}

    From Lemma~\ref{lemma:contextLemma1}, we have that
    %
    \begin{align*}
      [[((G - D1) + (D1 - D2)), x1 : A -o B]] \sqsubseteq [[(((G - D1) + D1) - D2), x1 : A -o B]]
    \end{align*}
    %
    and from Lemma~\ref{lemma:contextLemma2}, that:
    %
    \begin{align*}
      [[(((G - D1) + D1) - D2), x1 : A -o B]] \sqsubseteq [[(G - D2), x1 : A -o B]]
    \end{align*}
    %
    %% JACK: this arguments needs strengthening, but it is true.
    %% easy to given a proof of output contexts being subsets of input
    which, since $[[ x1 ]]$ is not in $[[ D2 ]]$ (as $[[ x1 ]]$ is not
    in $[[ G ]]$)
    %%
    $[[(G - D2), x1 : A -o B]] = [[(G, x1 : A -o B) - D2]]$. Applying
    these inequalities with \textsc{Approx} then yields the lemma's
    conclusion $[[ {(G, x1 : A -o B) - D2} |- [(x1 t2) / x2] t1 : C ]]$.

  \item Case \subBoxName{} \\
    %
    The synthesis rule for boxing can be constructed as:
    %
    \[
      \subBox{}
    \]
    %
    By induction on the premise we get:
    %
    \begin{align*}
      [[ G - D |- t : A ]]
    \end{align*}
    %
    Since we apply scalar multipication ih the conclusion of the rule
    to $[[ G - D ]]$ then we know that all of $[[ G - D ]]$ must be
    graded assumptions.

    From this, we can construct the typing derivation:
    %
    \[
    \inferrule*[Right=\textsc{Pr}]
    {[[ [{G - D}] |- t : A]]}{[[r * [{G - D}] |- [t] : [] r A]]}
    \]
    Via Lemma~\ref{lemma:contexts-subsub}, we then have that
    $[[ (r * {G - D})]] \sqsubseteq [[(G - (G - (r * (G - D)))) ]]$ thus, we can
    derived:
    %
    \[
    \inferrule*[Right=\textsc{Approx}]
   {
    \inferrule*[Right=\textsc{Pr}]
    {[[ [{G - D}] |- t : A]]}{[[r * [{G - D}] |- [t] : [] r A]]
    \quad \text{Lem.~\ref{lemma:contexts-subsub}}}
   }{ [[ G - (G - (r * (G - D))) |- [t] : [] r A ]]}
    \]
    %
    Satisfying the goal of the lemma.

  \item Case \subUnboxName \\
    The synthesis rule for unboxing has the form:
    \[
    \subUnbox{}
    \]
    %
    By induction on the premise we have that:
    %
      \begin{align*}
        [[ (G, x2 : [A]r) - (D, x2 : [A]s)  |- t : B ]]
      \end{align*}
   %
   By the definition of context subtraction we get that $\exists q$ and:
   %
     \begin{align*}
       [[ (G, x2 : [A]r) - (D, x2 : [A]s) ]]
     = [[ (G - D), x2 : [A]q ]]
       \end{align*}
   %
    such that $r = q + s$

    We also have that $0 \sqsubseteq [[ s ]]$.

    By monotonicity with $[[ q ]] \sqsubseteq [[ q ]]$ (reflexivity)
    and $0 \sqsubseteq [[ s ]]$ then $[[ q ]] \sqsubseteq [[ q + s ]]$.

    By context subtraction we have $r = q + s$ therefore
    $[[ q ]] \sqsubseteq [[ r ]]$ (*).

    From this, we can construct the typing derivation:
    %
    \[
    \inferrule*[Right=\textsc{Let}]
    {\inferrule*[right=\textsc{Var}]
                    {\quad}{[[x1 : [] r A |- x1 : [] r A ]]}
           \\
      \inferrule*[right=\textsc{approx}]
         {[[ (G - D), x2 : [A]q  |- t : B ]] \quad (*)}
         {[[ (G - D), x2 : [A]r  |- t : B ]]}}
     {[[(G - D), x1 : [] r A |- let [x2] = x1 in t : B]]}
    \]
    %
    Which matches the goal.

  \item Case \subPairIntroName \\

    The synthesis rule for pair introduction has the form:
    %
    \[
      \subPairIntro{}
    \]
    %
    By induction we get:
    %
    \begin{align*}
      [[ G - D1 |- t1 : A ]] \tag{ih1} \\
      [[ D1 - D2 |- t2 : B ]] \tag{ih2}
    \end{align*}
    %
    From this, we can construct the typing derivation:
    %
    \[
    \inferrule*[Right=\textsc{Pair}]
    {[[ G - D1 |- t1 : A ]] \\ [[ D1 - D2 |- t2 : B ]]}
    {[[(G - D1) + (D1 - D2) |- pair t1 t2 : Tup A B ]]}
    \]
    %
    From Lemma~\ref{lemma:contextLemma1}, we have that:
    \begin{align*}
      [[(G - D1) + (D1 - D2)]] \sqsubseteq [[((G - D1) + D1) - D2]]
    \end{align*}
    %
    and from Lemma~\ref{lemma:contextLemma2}, that:
    %
    \begin{align*}
      [[((G - D1) + D1) - D2]] \sqsubseteq [[G - D2]]
    \end{align*}
    %
    From which we then apply \textsc{Approx} to the
    above derivation,
    yielding the goal $[[ G - D2 |- pair t1 t2 : Tup A B ]]$.

  \item Case \subPairElimName \\
    The synthesis rule for pair elimination has the form:
    \[
      \subPairElim
    \]
    %
    By induction we get:
    %
    \begin{align*}
      [[ (G, x1 : A, x2 : B) - D |- t2 : C ]]
    \end{align*}
    %
    since $[[ x1 notin D ]] \wedge [[ x2 notin D ]]$ then
    $[[ (G, x1 : A, x2 : B) - D ]] = [[ (G - D), x1 : A, x2 : B ]]$.

    From this, we can construct the following typing derivation,
    matching the conclusion:
    \[
    \inferrule*[Right=\textsc{Case}]
    {\inferrule*[right=\textsc{Var}] {\quad} {[[x3 : Tup A B |- x3
    : Tup A B]]} \\ [[ (G - D), x1 : A, x2 : B |- t2 : C]]}
    {[[(G - D), x3 : Tup A B |- letpair x1 x2 = x3 in t2 : C ]]}
    \]
    % JACK: tighten from context subset
    which matches the conclusion since $[[ (G - D), x3 : Tup A B ]] = [[
    (G, x3 : Tup A B) - D ]]$ since $[[ x3 notin D ]]$ by its
    disjointness from $[[ G ]]$.

  \item Case \subSumIntroLname and \subSumIntroRname \\
    The synthesis rules for sum introduction are straightforward. For
     \subSumIntroLname we have the rule:
    \[
       \subSumIntroL
    \]
    By induction we have:
    %
      \begin{align*}
        [[ G - D |- t : A ]] \tag{ih1}
       \end{align*}
    %
    from which we can construct the typing derivation, matching the
    conclusion:
    \[
    \inferrule*[Right=\subSumIntroLname]
    {[[G - D |- t : A]]}
    {[[G - D |- inl t : Sum A B]]}
    \]
    Matching the goal. And likewise for \subSumIntroRname.

  \item Case \subSumElimName
      The synthesis rule for sum elimination has the form:
      \[
        \subSumElim
      \]
      %
      By induction:
        \begin{align*}
          [[ (G, x2 : A) - D1 |- t1 : C ]] \tag{ih}
\\        [[ (G, x3 : B) - D2 |- t2 : C ]] \tag{ih}
        \end{align*}
      %
      From this we can construct the typing derivation, matching the conclusion:
      \[
      \inferrule*[Right=Case]
      {\inferrule*[right=Var,leftskip=10em]{\quad}{[[x1 : Sum A B |- t1 : Sum A B]]} \\ [[(G - D1), x2 : A |- t2
    : C]] \\ [[(G - D2), x3 : B |- t3 :
      C]]}{[[(G, x1 : Sum A B)]] - ([[D1]] \sqcap [[D2]]) \vdash  \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} : C}
      \]

      \item Case \subUnitIntroName

          \begin{align*}
            \subUnitIntro{}
           \end{align*}
         %
         By Lemma~\ref{lemma:context-neg} we have that $\emptyset \sqsubseteq [[{G - G} ]]$
         then we have:
         %
           \begin{align*}
             \inferrule*[right = \textsc{Approx}]
             {\inferrule*[right = $\mathsf{Unit}$]
             {\quad}{[[ . |- () : Unit ]]}}
             {[[ G - G |- () : Unit ]]}
           \end{align*}
         %
         Matching the goal

     \item Case \subUnitElimName
          \begin{align*}
            \subUnitElim{}
           \end{align*}
         %
         By induction we have:
           \begin{align*}
             [[ G - D |- t : C ]] \tag{ih}
            \end{align*}
         %
         Then we make the derivation:
         %
           \begin{align*}
             \inferrule*[right = Let$\mathsf{Unit}$]
             {\inferrule*[right = Var]{\quad}{[[ x : Unit |- x : Unit ]]}
             \\ [[ G - D |- t : C ]]}
             {[[ (G - D), x : Unit |- let () = x in t : C ]]}
           \end{align*}
         where the context is equal to $[[ (G, x : Unit) - D ]]$.

  \item Case \subDerName

      \begin{align*}
        \subDer
      \end{align*}
     %
     By induction:
     %
       \begin{align*}
         [[ (G, x : [A] s, y : A) - (D, x : [A] s') |- t : B ]] \tag{ih}
       \end{align*}
     %
     By the definition of context subtraction we have (since also $[[ y notin D ]]$)
       \begin{align*}
     &  [[ (G, x : [A] s, y : A) - (D, x : [A] s')  ]] \\
   =\ &  [[ (G - D), x : [A] q, y : A ]]
       \end{align*}
     where $[[ exists q . s >= q + s' ]]$ (1) and
     $\maximal{q}{\hat{q}}{s}{\hat{q} + s'}$ (2)

       The goal context is computed by:
       %
       \begin{align*}
      & [[ (G, x : [A]r) - (D, x : [A]s') ]] \\
    =\ & [[ (G - D), x : [A] q' ]]
       \end{align*}
       where $[[ r >= {q' + s'} ]]$ (3)
       and $\maximal{q'}{\hat{q'}}{r}{\hat{q'} + s'}$ (4)

       From the premise of \subDerName we have
       $[[ r >= (s + 1) ]]$.

       \begin{align*}
      \begin{array}{rll}
        \text{congruence of + and (1)} & \implies [[ {s + 1} >= {{q +
                                         s'} + 1} ]] & (5) \\
        \text{transitivity with \subDerName premise and (5)} & \implies
                 [[ r >= {{ q + s'} + 1} ]] & (6) \\
        \text{+ assoc./comm. on (6)} & \implies [[ r >= {{q + 1} +s'}
                                       ]] & (7) \\
       \text{apply (8) to (4) with $\hat{q'} = q + 1$} & \implies
                                                    [[ q' >= q + 1 ]]
                                                     & (8)
      \end{array}
       \end{align*}
       %
       Using this last result we derive:
       \begin{align*}
         \inferrule*[right = approx]
        {
         \inferrule*[right = contraction]
         {
         \inferrule*[right = Der]
         {[[ (G - D), x : [A] q, y : A |- t : B ]]}
         {[[ (G - D) , x : [ A ] q, y : [ A ]1 |- t : B]]}
         }
         {[[ (G - D) , x : [ A ] {q + 1} |- [pat x/y] t : B]]}
         \quad (8)}
        {[[ (G - D), x : [A] q' |- [pat x/y] t : B]]}
         \end{align*}
       Which matches the goal.

\end{enumerate}
\end{proof}


\subsection{Soundness of the Additive Graded Linear Typing Calculus}
\label{proof:linear-add-sound}
\addSynthSound*
\begin{proof}

  \begin{enumerate}
    \item Case \addLinVarName \\
  In the case of linear variable synthesis, we have the derivation:
  \[
    \addLinVar
  \]
  Therefore we can construct the following typing derivation, matching the conclusion:
  \[
    \inferrule*[Right=\textsc{var}]
    {\quad}
    {[[ x : A |- x : A ]]}
  \]
    \item Case \addGrVarName\\
    Matching the form of the lemma, we have the derivation:
    \[
      \addGrVar
    \]
    From this we can construct the typing derivation, matching the conclusion:
    \[
      \inferrule*[Right=\textsc{Der}]
        {\inferrule*[Right=\textsc{Var}]
          {\quad}
          {[[ x : A |- x : A ]]}
        }
        {[[ x : [A] 1 |- x : A ]]}
    \]
    \item Case \addAbsName\\
    We thus have the derivation:
    \[
      \addAbs
    \]
    %
    By induction on the premise we then have:
    \[
      [[ D, x : A |- t : B ]]
    \]
    From this, we can construct the typing derivation, matching the conclusion:
    \[
    \inferrule*[Right=\textsc{abs}]
    {[[ D, x : A |- t : B]]}{[[ D |- \x. t : A -o B ]]}
    \]
    \item Case \addAppName\\
    Matching the form of the lemma, the application derivation can be
    constructed as:
    \[
      \addApp
    \]
    %
    By induction on the premises we then have the following typing
    judgments:
    %
    \begin{align*}
      [[ D1, x2 : B |- t1 : C ]] \\
      [[ D2 |- t2 : A ]]
    \end{align*}
    %
    We can thus construct the following typing derivation, making use
    of the admissibility of linear substitution
    (Lemma~\ref{lemma:substitution}):
    \[
    \inferrule*[Right=(L.~\ref{lemma:substitution})]
    {\inferrule*[right=\textsc{app}, leftskip=2em]
    {\inferrule*[right=\textsc{var}]
    {\quad}
    {[[x1 : A -o B |- x1 : A -o B ]]} \\ {[[  D2 |- t2 : A ]]}}
  {[[D2, x1 : A -o B |- x1 t2 : B]]}
    \\ [[ D1, x2 : B |- t1 : C]]}
    {[[(D1 + D2), x1 : A -o B |- [(x1 t2) / x2] t1 : C]]}
    \]
    \item Case \addBoxName\\
    The synthesis rule for boxing can be constructed as:
    \[
      \addBox
    \]
    By induction we then have:
    %
    \[
      [[ D |- t : A ]]
    \]
    %
    In the conclusion of the above derivation we know that $[[ r * D
    ]]$ is defined, therefore it must be that all of $[[ D ]]$ are
    graded assumptions, i.e., we have that $[[ [ D ] ]]$ holds.
    We can thus construct the following typing derivation, matching the conclusion:
    \[
    \inferrule*[Right=\textsc{Pr}]
    {[[ [D] |- t : A]]}{[[ r * [D] |- [t] : [] r A]]}
    \]
    \item Case \addDerName\\
    From the dereliction rule we have:
    \[
      \addDer
    \]
    %
    By induction we get:
    %
      \begin{align*}
        [[ D, y : A |- t : B ]] \tag{ih}
      \end{align*}
    %
    Case on $x \in [[ D ]]$
    \begin{itemize}
      \item $x \in [[ D ]]$, i.e., $[[ D ]] = [[ D', x : [A] s' ]]$.

        Then by admissibility of contraction we can derive:
        %
        \begin{align*}
          \inferrule*{
            \inferrule*[Right=\textsc{Der}]
             {[[ D', x : [A] s', y : A |- t : B]]}{[[ D', x : [A] s', y : [A] 1 |- t : B ]]}
            }
            { [[ (D', x : [A] s') + x : [A] 1 |- [pat x/y] t : B ]] }
        \end{align*}
        %
        Satisfying the lemma statment.

     \item $x \not\in [[ D ]]$. Then
      again from the admissiblity of contraction, we derive the
      typing:
      %
        \begin{align*}
          \inferrule*{
            \inferrule*[Right=\textsc{Der}]
             {[[ D, y : A |- t : B]]}{[[ D, y : [A] 1 |- t : B ]]}
            }
            { [[ D + x : [A] 1 |- [pat x/y] t : B ]] }
        \end{align*}
        %
        which is well defined as $x \not\in [[ D ]]$ and gives the
        lemma conclusion.
        \end{itemize}

    \item Case \addUnboxName\\
    The synthesis rule for unboxing has the form:
    \[
      \addUnbox
    \]
    %
    By induction we have that:
    %
    \[
      [[ D |- t : B ]] \tag{ih}
    \]
    %
    Case on $[[x2 : [A] s]] \in [[ D ]]$
    \begin{itemize}
        \item $[[x2 : [A] s ]] \in [[ D ]]$, i.e., $[[ s]] \sqsubseteq [[ r ]]$. \\
        From this, we can construct the typing derivation, matching the conclusion:
          \[
            \inferrule*[Right=\textsc{let}$\square$]
            {\inferrule*[right=\textsc{var}]{\quad}{[[x1 : [] r A |-
                x1 : [] r A ]]} \\ [[D, x2 : [A] r |- t : B]]}{[[D, x1 : [] r A |-
              let [x2] = x1 in t : B]]}
          \]
        \item $[[x2 : [A] s ]] \notin [[ D ]]$, i.e., $0 \sqsubseteq [[ r ]]$. \\
        From this, we can construct the typing derivation, matching the conclusion:
          \[
            \inferrule*[right=\textsc{let}$\square$]
            {\inferrule*[right=\textsc{var}]{\quad}{[[x1 : [] r A |-
                x1 : [] r A ]]} \\ \inferrule*[right=\textsc{Approx}, rightskip=5em]{\inferrule*[right=Weak]{[[D |- t : B]]}{[[ D, x2 : [A] 0 |- t : B ]]} \\ 0 \sqsubseteq [[ r ]]}{[[D, x2 : [A] r |- t : B]]}}{[[D, x1 : [] r A |-
              let [x2] = x1 in t : B]]}
          \]
    \end{itemize}
  \item Case \addPairIntroName\\

    The synthesis rule for pair introduction has the form:

    \[
      \addPairIntro
    \]
    %
    By induction on the premises we have that:
    %
    \begin{align*}
      [[ D1 |- t1 : A ]] \tag{ih1}\\
      [[ D2 |- t2 : B ]] \tag{ih2}
    \end{align*}
    %
    From this, we can construct the typing derivation, matching the conclusion:
    %
    \[
    \inferrule*[Right=\textsc{pair}]
    {[[ D1 |- t1 : A ]] \\ [[ D2 |- t2 : B ]]}
    {[[ D1 + D2 |- pair t1 t2 : Tup A B ]]}
    \]

  \item Case \addPairElimName\\
    The synthesis rule for pair elimination has the form:
    \[
      \addPairElim
    \]
      By induction on the premises we have that:
    \begin{align*}
      [[ D1 |- t1 : A ]] \tag{ih1} \\
      [[ D2 |- t2 : B ]] \tag{ih2}
    \end{align*}
    From this, we can construct the typing derivation, matching the conclusion:
    \[
    \inferrule*[Right=\textsc{LetPair}]
    {\inferrule*[right=\textsc{Var}] {\quad} {[[x3 : Tup A B |- x3
    : Tup A B]]} \\ [[D, x1 : A, x2 : B |- t2 : C]]}
    {[[D, x3 : Tup A B |- letpair x1 x2 = x3 in t2 : C ]]}
    \]

  \item Case \addSumIntroLName and \addSumIntroRName\\
    The synthesis rules for sum introduction are straightforward. For
    \addSumIntroLName we have the rule:
    \[
      \addSumIntroL
    \]
    By induction on the premises we have that:
    \begin{align*}
      [[ D |- t : A ]] \tag{ih}
    \end{align*}
    From this, we can construct the typing derivation, matching the conclusion:
    \[
    \inferrule*[Right=\textsc{Inl}]
    {[[D |- t : A]]}
    {[[D |- inl t : Sum A B]]}
    \]
    Likewise, for the \addSumIntroRName we have the
    synthesis rule:
    \[
      \addSumIntroR
    \]
    By induction on the premises we have that:
    \begin{align*}
      [[ D |- t : B ]] \tag{ih}
    \end{align*}
    From this, we can construct the typing derivation, matching the conclusion:
    \[
    \inferrule*[Right=\textsc{Inr}]
    {[[D |- t : B]]}
    {[[D |- inl t : Sum A B]]}
    \]

    \item Case \addSumElimName\\
      The synthesis rule for sum elimination has the form:
      \[
      \addSumElim
      \]
    By induction on the premises we have that:
    \begin{align*}
      [[ D1, x2 : A |- t1 : C ]] \tag{ih1}\\
      [[ D2, x3 : B |- t2 : C ]] \tag{ih2}
    \end{align*}
      From this, we can construct the typing derivation, matching the
      conclusion:
      \[
      \inferrule*[Right=\textsc{Case}]
      {\inferrule*[right=\textsc{Var}, leftskip=5em]{\quad}{[[x1 : Sum A B |- x1 : Sum A B]]} \\ [[D1, x2 : A |- t1 : C]] \\ [[D2, x3 : B |- t2 :
      C]]}{([[ D1]] \sqcup [[ D2]] ), [[ x1 : Sum A B ]] \vdash \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} : C}
      \]

  \item Case \addUnitIntroName\\
    The synthesis rule for unit introduction has the form:
    \[
      \addUnitIntro
    \]
    From this, we can construct the typing derivation, matching the conclusion:
    \[
    \inferrule*[Right=$\mathsf{Unit}$]
    {\quad}
    {[[ . |- () : Unit ]]}
    \]

  \item Case \addUnitElimName\\
    The synthesis rule for unit elimination has the form:
    \[
      \addUnitElim
    \]
    By induction on the premises we have that:
    \begin{align*}
      [[ D |- t : C ]] \tag{ih}
    \end{align*}
    From this, we can construct the typing derivation, matching the
    conclusion:
    \[
    \inferrule*[Right=\textsc{Let}$\mathsf{Unit}$]
    { \inferrule*[Right=\textsc{Var}]{\quad}{[[ x : Unit |- x : Unit ]]} \\ [[D |- t : C]]}
    {[[D, x : Unit |- let () = x in t : C ]]}
    \]
    %

  \end{enumerate}
\end{proof}
\subsection{Soundness of the Additive Pruning Graded Linear Typing Calculus}
\label{sec:add-pruning-sound}
\addPruningSynthSound*
\begin{proof}
  The cases for the rules in the additive pruning synthesis calculus are equivalent to lemma \eqref{lemma:addSynthSound}, except for the cases of the \addPruningAppName and \addPruningPairIntroName rules which we consider here:
  \begin{enumerate}
    \item Case \addPruningAppName\\
    Matching the form of the lemma, the application derivation can be
    constructed as:
    \[
      \addPruneApp
    \]
    %
    By induction on the premises we then have the following typing
    judgments:
    %
    \begin{align*}
      [[ D1, x2 : B |- t1 : C ]] \\
      [[ D2 |- t2 : A ]]
    \end{align*}
    %
    We can thus construct the following typing derivation, making use
    of the admissibility of linear substitution
    (Lemma~\ref{lemma:substitution}):
    \[
    \inferrule*[Right=(L.~\ref{lemma:substitution})]
    {\inferrule*[right=\textsc{app}, leftskip=2em]
    {\inferrule*[right=\textsc{var}]
    {\quad}
    {[[x1 : A -o B |- x1 : A -o B ]]} \\ {[[  D2 |- t2 : A ]]}}
  {[[D2, x1 : A -o B |- x1 t2 : B]]}
    \\ [[ D1, x2 : B |- t1 : C]]}
    {[[(D1 + D2), x1 : A -o B |- [(x1 t2) / x2] t1 : C]]}
    \]

  \item Case \addPruningPairIntroName\\

    The synthesis rule for the pruning alternative for pair introduction has the form:

    \[
      \addPrunePairIntro
    \]
    By induction on the premises we have that:
    \begin{align*}
      [[ D1 |- t1 : A ]] \tag{ih1} \\
      [[ D2 |- t2 : B ]] \tag{ih2}
    \end{align*}

    From this, we can construct the typing derivation, matching the conclusion:

    \[
    \inferrule*[Right=\textsc{pair}]
    {[[ D1 |- t1 : A ]] \\ [[ D2 |- t2 : B ]]}
    {[[ D1 + D2 |- pair t1 t2 : Tup A B ]]}
    \]


  \end{enumerate}
\end{proof}

%\focusSoundSub*

\subsection{Soundness of Focusing for the Subtractive Linear Graded Synthesis Calculus}
\label{proof:focusSubSound}
\focusSoundSub*
\begin{proof}
  \begin{enumerate}
      \item Case 1. Right Async: \\
      \begin{enumerate}
        \item Case \subAbsName \\
          In the case of the right asynchronous rule for abstraction introduction, the synthesis rule has the form:
          \[
          \fSubAbsRuleNoLabel
          \]
          By induction on the first premise, we have that:
          \[
            [[ (G , O), x : A |- A =>- t ; D ]] \tag{ih}
          \]
          from case 1 of the lemma. From which, we can construct the following instantiation of the \subAbsName synthesis rule in the non-focusing calculus:
          \[
          \inferrule*[right=\subAbsName]
          {[[(G , O), x : A |- B =>- t ; D]] \quad\; [[ x notin D ]]}{[[ G , O |- A -o B =>- \x. t ; D ]]}
          \]
    \item Case \fSubRAsyncTransitionName \\
          In the case of the right asynchronous rule for transition to a left asynchronous judgement, the synthesis rule has the form:
          \[
            \fSubRAsyncTransitionRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ G , O |- C =>- t ; D ]]
          \]
          from case 2 of the lemma.
    \end{enumerate}
    \item Case 2. Left Async: \\
      \begin{enumerate}
        \item Case \subPairElimName \\
          In the case of the left asynchronous rule for pair elimination, the synthesis rule has the form:
          \[
          \fSubPairElimRuleNoLabel
          \]
          By induction on the first premise, we have that:
            \[
            [[(G , O), x1 : A, x2 : B |- C =>- t ; D]] \tag{ih}
            \]
          from From which, we can construct the following instantiation of the \subPairIntroName\ synthesis rule in the non-focusing calculus:
          \[
          \inferrule*[right=\subPairElimName]
          {[[(G , O), x1 : A, x2 : B |- C =>- t ; D]] \\ [[ x1 notin D ]] \\ [[x2 notin D]]}{[[G , (O, x3 : Tup A B) |- C =>- letpair x1 x2 = x3 in t ; D2]]}
          \]
        \item Case \subSumElimName \\
          In the case of the left asynchronous rule for sum elimination, the synthesis rule has the form:
          \[
          \fSubSumElimRule
          \]
          By induction on the first and second premises, we have that:
          \[
            [[(G , O), x2 : A |- C =>- t1 ; D1]] \tag{ih1}\\
          \]
          \[
            [[(G , O), x3 : B |- C =>- t2 ; D2]] \tag{ih2}
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \subSumElimName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=\subSumElimName]
      {[[(G , O), x2 : A |- C =>- t1 ; D1]] \quad\,
       [[(G , O), x3 : B |- C =>- t2 ; D2]] \quad\, [[ x2 notin D1 ]] \quad [[ x3 notin D2 ]]}
     {[[G , (O, x1 : Sum A B) ]] \vdash C \Rightarrow^{-}  \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2} [[ D1 ]] \sqcap [[ D2 ]]}
          \]
        \item Case \subUnitElimName \\
          In the case of the left asynchronous rule for unit elimination, the synthesis rule has the form:
          \[
          \fSubUnitElimRule
          \]
          By induction on the premise, we have that:
          \[
            [[G |- C =>- t ; D]] \tag{ih}
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \subUnitElimName\ synthesis rule in the non-focusing calculus matching the conclusion:
          \[
    \inferrule*[right=\subUnitElimName]
    {[[G |- C =>- t ; D]]}
    {[[G, x : Unit |- C =>- let () = x in t ; D]]}
          \]
        \item Case \subUnboxName \\
          In the case of the left asynchronous rule for graded modality elimination, the synthesis rule has the form:
          \[
          \fSubUnboxRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ (G , O), x2 : [A] r |- B =>- t ; D, x2 : [A] s]]  \tag{ih}\\
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \subUnboxName synthesis rule in the non-focusing calculus:
          \[
  \inferrule*[right=\subUnboxName]
    {[[ (G , O), x2 : [A] r |- B =>- t ; D, x2 : [A] s]]  \\ 0 \sqsubseteq [[s]]}{[[G , (O, x1 : [] r A) |- B =>- let [x2] = x1 in t ; D ]]}
          \]
%         \item Case \subDerName \\
%           In the case of the left asynchronous rule for dereliction, the synthesis rule has the form:
%           \[
%           \fSubDerRule
%           \]
%           By induction on the first premise, we have that:
%           \[
%             [[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]]  \tag{ih}\\
%           \]
%           from case 2 of the lemma. From which, we can construct the following instantiation of the \subDerName synthesis rule in the non-focusing calculus:
%           \[
%       \inferrule*[right=\subDerName]
% {[[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]] \\
% [[ y notin D ]] \\
% [[ exists s . r >= s + 1]]
% }
% {[[ G, x : [A] r |- B =>- [pat x/y] t ; D, x : [A] s' ]]}
%           \]

        \item Case \fSubLAsyncTransitionName \\
          In the case of the left asynchronous rule for transitioning an assumption from the focusing context $[[ O ]]$ to the non-focusing context $[[G]]$, the synthesis rule has the form:
          \[
            \fSubLAsyncTransitionRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ {G, x : A}, O |- C =>- t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
      \end{enumerate}
    \item Case 3. Right Sync: \\
      \begin{enumerate}
        \item Case \subPairIntroName \\
          In the case of the right synchronous rule for pair introduction, the synthesis rule has the form:
          \[
          \fSubPairIntroRuleNoLabel
          \]
          By induction on the first and second premises, we have that:
          \[
            [[G |- A =>- t1 ; D1]]  \tag{ih1}
          \]
          \[
            [[ D1 |- B =>- t2 ; D2 ]] \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiation of the \subPairIntroName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=\subPairIntroName]
    {[[G |- A =>- t1 ; D1]] \\ [[ D1 |- B =>- t2 ; D2 ]]}{[[G |- Tup A B =>- pair t1 t2 ; D2]]}
          \]
        \item Case \subSumIntroLname\ and \subSumIntroRname\\
          In the case of the right synchronous rules for sum introduction, the synthesis rules has the form:
          \[
          \fSubSumIntroRuleL
          \]
          \[
          \fSubSumIntroRuleR
          \]
          By induction on the premises of these rules, we have that:
          \[
            [[G |- A =>- t ; D]]  \tag{ih1}
          \]
          \[
            [[G |- B =>- t ; D]] \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiations of the \subSumIntroLname\ and \subSumIntroRname\ rule in the non-focusing calculus, respectively:
          \[
    \inferrule*[right=\subSumIntroLname]
    {[[G |- A =>- t ; D]]}
    {[[G |- Sum A B =>- inl t ; D]]}
          \]
          \[
    \inferrule*[right=\subSumIntroRname]
    {[[G |- B =>- t ; D]]}
    {[[G |- Sum A B =>- inr t ; D]]}
          \]
        \item Case \subUnitIntroName \\
          In the case of the right synchronous rule for unit introduction, the synthesis rule has the form:
          \[
          \fSubUnitIntroRule
          \]
          From which, we can construct the following instantiation of the \subUnitIntroName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=\subUnitIntroName]
    {\quad}
    {[[G , O |- Unit =>- () ; G]]}
          \]
        \item Case \subBoxName \\
          In the case of the right synchronous rule for graded modality introduction, the synthesis rule has the form:
          \[
          \fSubBoxRule
          \]
          By induction on the premise, we have that:
          \[
            [[G |- A =>- t ; D]] \tag{ih}
          \]
          from case 1 of the lemma. From which, we can construct the following instantiation of the \subBoxName synthesis rule in the non-focusing calculus:
          \[
  \inferrule*[right=\subBoxName]
  {[[G |- A =>- t ; D]]}{[[G |- [] r A =>- [t] ; G - r * (G - D)]]}
          \]
      \item Case \fSubRSyncTransitionName \\
          In the case of the right synchronous rule for transitioning back to an asynchronous judgement, the synthesis rule has the form:
          \[
            \fSubRSyncTransitionRule
          \]
          By induction on the premise, we have that:
          \[
            [[ G |- A =>- t ; D ]] \tag{ih}
          \]
          from case 1 of the lemma.
      \end{enumerate}
    \item Case 4. Left Sync \\
      \begin{enumerate}
          \item Case \subAppName \\
          In the case of the left synchronous rule for application, the synthesis rule has the form:
          \[
          \fSubAppRuleNoLabel
          \]
          By induction on the first premise, we have that:
          \[
            [[G, x2 : B |- C =>- t1 ; D1]] \tag{ih1}
          \]
          from case 4 of the lemma. By induction on the third premise, we have that:
          \[
            [[D1 |- A =>- t2 ; D2]] \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiation of the \subAppName synthesis rule in the non-focusing calculus:
          \[
  \inferrule*[right=\subAppName]
  {[[G, x2 : B |- C =>- t1 ; D1]] \qquad [[ x2 notin D1 ]] \qquad [[D1 |- A =>- t2 ; D2]]}{[[G, x1 : A -o B
      |- C =>- [(x1 t2) / x2] t1 ; D2 ]]}
          \]
        \item Case \subDerName \\
          In the case of the left asynchronous rule for dereliction, the synthesis rule has the form:
          \[
          \fSubDerRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]]  \tag{ih}\\
          \]
          from case 4 of the lemma. From which, we can construct the following instantiation of the \subDerName synthesis rule in the non-focusing calculus:
          \[
      \inferrule*[right=\subDerName]
{[[ G, x : [A] s, y : A |- B =>- t ; D, x : [A] s' ]] \\
[[ y notin D ]] \\
[[ exists s . r >= s + 1]]
}
{[[ G, x : [A] r |- B =>- [pat x/y] t ; D, x : [A] s' ]]}
          \]
          \item Case \subLinVarName \\
          In the case of the left synchronous rule for linear variable synthesis, the synthesis rule has the form:
          \[
          \fSubLinVarRule
          \]
          From which, we can construct the following instantiation of the \subLinVarName\  synthesis rule in the non-focusing calculus:
          \[
                             \inferrule*[right=\subLinVarName]
                             {\quad}{[[G, x : A |- A =>- x ; G]]}
          \]
          \item Case \subGrVarName \\
          In the case of the left synchronous rule for graded variable synthesis, the synthesis rule has the form:
          \[
          \fSubGrVarRule
          \]
          From which, we can construct the following instantiation of the \subGrVarName\  synthesis rule in the non-focusing calculus:
          \[
      \inferrule*[right=\subGrVarName]
  {[[ exists s . r <= {s + 1} ]]}{[[G, x : [A] r |- A =>- x ; G , x : [A] s]]}
          \]
      \item Case \fSubLSyncTransitionName \\
          In the case of the left synchronous rule for transitioning back to an asynchronous judgement, the synthesis rule has the form:
          \[
            \fSubLSyncTransitionRule
          \]
          By induction on the premise, we have that:
          \[
            [[ G, x : A |- C =>- t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
      \end{enumerate}
        \item Case 5. Focus Right: \fSubFocusRName \\
          In the case of the focusing rule for transitioning from a left asynchronous judgement to a right synchronous judgement, the synthesis rule has the form:
          \[
            \fSubFocusRRuleNoLabel
          \]
          By induction on the first premise, we have that:
          \[
            [[ G |- C =>- t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
        \item Case 6. Focus Left \fSubFocusLName \\
          In the case of the focusing rule for transitioning from a left asynchronous judgement to a left synchronous judgement, the synthesis rule has the form:
          \[
            \fSubFocusLRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ G, x : A |- C =>- t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
  \end{enumerate}
\end{proof}


\subsection{Soundness of Focusing for the Additive Linear Graded Synthesis Calculus}
\label{proof:focusAddSound}
\focusSoundAdd*
\begin{proof}
  \begin{enumerate}
      \item Case 1. Right Async: \\
      \begin{enumerate}
        \item Case \addAbsName \\
          In the case of the right asynchronous rule for abstraction introduction, the synthesis rule has the form:
          \[
          \fAddAbsRuleNoLabel
          \]
          By induction on the premise, we have that:
          \[
            [[(G , O), x : A |- B =>+ t ; D, x : A]]   \tag{ih}
          \]
          from case 1 of the lemma. From which, we can construct the following instantiation of the \addAbsName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\multimap_{\textsc{R}}^{+}$]
    {[[(G , O), x : A |- B =>+ t ; D, x : A]]}{[[G , O |- A -o B =>+ \x . t ; D]]}
          \]
          \item Case \fAddRAsyncTransitionName
          In the case of the right asynchronous rule for transition to a left asynchronous judgement, the synthesis rule has the form:
          \[
            \fAddRAsyncTransitionRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ G , O |- C =>+ t ; D ]]
          \]
          from case 2 of the lemma.
      \end{enumerate}
    \item Case 2. Left Async: \\
      \begin{enumerate}
        \item Case \addPairElimName \\
          In the case of the left asynchronous rule for pair elimination, the synthesis rule has the form:
          \[
          \fAddPairElimRuleNoLabel
          \]
          By induction on the premise, we have that:
          \[
            [[ (G , O), x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]   \tag{ih}
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \addPairElimName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\otimes_{\textsc{L}}^{+}$]
    {[[ (G , O), x1 : A, x2 : B |- C =>+ t2 ; D, x1 : A, x2 : B]]}
    {[[ G , (O, x3 : Tup A B) |- C =>+ letpair x1 x2 = x3 in t2 ; D, x3 : Tup A B ]]}
          \]
        \item Case \addSumElimName \\
          In the case of the left asynchronous rule for sum elimination, the synthesis rule has the form:
          \[
          \fAddSumElimRule
          \]
          By induction on the premises, we have that:
          \[
           [[(G , O), x2 : A |- C =>+ t1 ; D1, x2 : A]]   \tag{ih1}
          \]
          \[
           [[(G , O), x3 : B |- C =>+ t2 ; D2, x3 : B ]]   \tag{ih2}
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \addSumElimName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\oplus_{\textsc{L}}^{+}$]
    {[[(G , O), x2 : A |- C =>+ t1 ; D1, x2 : A]] \\ [[(G , O), x3 : B |- C =>+ t2 ; D2,
      x3 : B ]]}{[[G , (O, x1 : Sum A B) ]] \vdash C \Rightarrow^{+} \textbf{case} \ x_{1}\ \textbf{of}\ \textbf{inl}\ x_{2} \rightarrow t_{1};\ \textbf{inr}\ x_{3} \rightarrow t_{2}\ |\  ([[D1]] \sqcup [[D2]]), [[x1 : Sum A B]]}
          \]
        \item Case \addUnitElimName \\
          In the case of the left asynchronous rule for unit elimination, the synthesis rule has the form:
          \[
          \fAddUnitElimRule
          \]
          By induction on the premise, we have that:
          \[
           [[G |- C =>+ t ; D]]   \tag{ih}
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \addUnitElimName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\mathsf{Unit}_{\textsc{L}}^{+}$]
    {[[G |- C =>+ t ; D]]}
    {[[G, x : Unit |- C =>+ let () = x in t ; D, x : Unit]]}
          \]
        \item Case \addUnboxName \\
          In the case of the left asynchronous rule for graded modality elimination, the synthesis rule has the form:
          \[
          \fAddUnboxRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ (G , O), x2 : [A] r |- B =>+ t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma. From which, we can construct the following instantiation of the \addUnboxName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\square_{\textsc{L}}^{+}$]
    {[[ (G , O), x2 : [A] r |- B =>+ t ; D ]] \\ \textit{if}\ [[x2 : [A] s]] \in
      [[D]]\ \textit{then}\ [[s]] \sqsubseteq [[ r ]]\ \textit{else}\ 0 \sqsubseteq [[ r ]]}{[[G , (O, x1 : [] r A) |- B =>+
      let [x2] = x1 in t ; (D \ x2 ), x1 : [] r A ]]}
          \]
%         \item Case \addDerName \\
%           In the case of the left asynchronous rule for dereliction, the synthesis rule has the form:
%           \[
%           \fAddDerRule
%           \]
%           By induction on the premise, we have that:
%           \[
%            [[ G, x : [A] s, y : A |- B =>+ t ; D, y : A ]]   \tag{ih}
%           \]
%           from case 2 of the lemma. From which, we can construct the following instantiation of the \addDerName\ synthesis rule in the non-focusing calculus:
%           \[
% \inferrule*[right=der$^{+}$]
% { [[ G, x : [A]s, y : A |- B =>+ t ; D, y : A ]] }
% { [[ G, x : [A]s |- B =>+ {[pat x / y] t} ; D + x : [A]1 ]] }
%           \]
        \item Case \fAddLAsyncTransitionName \\
          In the case of the left asynchronous rule for transitioning an assumption from the focusing context $[[ O ]]$ to the non-focusing context $[[G]]$, the synthesis rule has the form:
          \[
            \fAddLAsyncTransitionRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ {G, x : A}, O |- C =>+ t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
      \end{enumerate}
    \item Case 3. Right Sync: \\
      \begin{enumerate}
        \item Case \addPairIntroName \\
          In the case of the right synchronous rule for pair introduction, the synthesis rule has the form:
          \[
          \fAddPairIntroRuleNoLabel
          \]
          By induction on the premises, we have that:
          \[
           [[G |- A =>+ t1 ; D1]]   \tag{ih1}
          \]
          \[
           [[G |- B =>+ t2 ; D2]]  \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiation of the \addPairIntroName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\otimes_{\textsc{R}}^{+}$]
    {[[G |- A =>+ t1 ; D1]] \\ [[G |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
          \]
        \item Case \addSumIntroLName\ and \addSumIntroRName\\
          In the case of the right synchronous rules for sum introduction, the synthesis rules have the form:
          \[
          \fAddSumIntroRuleL
          \]
          \[
          \fAddSumIntroRuleR
          \]
          By induction on the premises of the rules, we have that:
          \[
           [[G |- A =>+ t ; D]]   \tag{ih1}
          \]
          \[
           [[G |- B =>+ t ; D]]  \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiations of the \addSumIntroLName\ and \addSumIntroRName\ synthesis rules in the non-focusing calculus, respectively:
          \[
    \inferrule*[right=$\oplus_{\textsc{R}}{1}^{+}$]
    {[[G |- A =>+ t ; D]]}
    {[[G |- Sum A B =>+ inl t ; D]]}
          \]
          \[
    \inferrule*[right=R$\oplus_{\textsc{R}}{2}^{+}$]
    {[[G |- B =>+ t ; D]]}
    {[[G |- Sum A B =>+ inr t ; D]]}
          \]
        \item Case \addUnitIntroName \\
          In the case of the right synchronous rule for unit introduction, the synthesis rule has the form:
          \[
          \fAddUnitIntroRule
          \]
          From which, we can construct the following instantiation of the \addUnitIntroName\  synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\mathsf{Unit}_{\textsc{R}}^{+}$]
    {\quad}
    {[[G |- Unit =>+ () ; .]]}
          \]
        \item Case \addBoxName \\
          In the case of the right synchronous rule for graded modality introduction, the synthesis rule has the form:
          \[
          \fAddBoxRule
          \]
          By induction on the premise, we have that:
          \[
           [[G |- A =>+ t ; D]]   \tag{ih}
          \]
          from case 1 of the lemma. From which, we can construct the following instantiation of the \addBoxName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\square_{\textsc{R}}^{+}$]
    {[[G |- A =>+ t ; D]]}{[[G |- [] r A =>+ [t] ; r * D ]]}
          \]
      \item Case \fAddRSyncTransitionName \\
          In the case of the right synchronous rule for transitioning back to an asynchronous judgement, the synthesis rule has the form:
          \[
            \fAddRSyncTransitionRule
          \]
          By induction on the premise, we have that:
          \[
            [[ G |- A =>+ t ; D ]] \tag{ih}
          \]
          from case 1 of the lemma.
      \end{enumerate}
    \item Case 4. Left Sync \\
      \begin{enumerate}
          \item Case \addAppName \\
          In the case of the left synchronous rule for application, the synthesis rule has the form:
          \[
          \fAddAppRuleNoLabel
          \]
          By induction on the first premise, we have that:
          \[
            [[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \tag{ih1}
          \]
          from case 4 of the lemma. By induction on the second premise, we have that:
          \[
            [[G |- A =>+ t2 ; D2 ]] \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiation of the \addAppName synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=$\multimap_{\textsc{L}}^{+}$]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
          \]
        \item Case \addDerName \\
          In the case of the left asynchronous rule for dereliction, the synthesis rule has the form:
          \[
          \fAddDerRule
          \]
          By induction on the premise, we have that:
          \[
           [[ G, x : [A] s, y : A |- B =>+ t ; D, y : A ]]   \tag{ih}
          \]
          from case 4 of the lemma. From which, we can construct the following instantiation of the \addDerName\ synthesis rule in the non-focusing calculus:
          \[
\inferrule*[right=der$^{+}$]
{ [[ G, x : [A]s, y : A |- B =>+ t ; D, y : A ]] }
{ [[ G, x : [A]s |- B =>+ {[pat x / y] t} ; D + x : [A]1 ]] }
          \]

          \item Case \addLinVarName \\
          In the case of the left synchronous rule for linear variable synthesis, the synthesis rule has the form:
          \[
          \fAddLinVarRule
          \]
          From which, we can construct the following instantiation of the \addLinVarName\ in the non-focusing calculus:
          \[
    \inferrule*[right=LinVar$^{+}$]
    {\quad}
    {[[G, x : A |- A =>+ x ; x : A]]}
          \]
          \item Case \addGrVarName \\
          In the case of the left synchronous rule for graded variable synthesis, the synthesis rule has the form:
          \[
          \fAddGrVarRule
          \]
          From which, we can construct the following instantiation of the \addGrVarName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=GrVar$^{+}$]
    {\quad}
      {[[ G, x : [A] r |- A =>+ x ; x :[A] 1 ]] }
          \]
      \item Case \fAddLSyncTransitionName \\
          In the case of the left synchronous rule for transitioning back to an asynchronous judgement, the synthesis rule has the form:
          \[
            \fAddLSyncTransitionRule
          \]
          By induction on the premise, we have that:
          \[
            [[ G, x : A |- C =>+ t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
      \end{enumerate}
    \item Case 5. Focus Right: \fAddFocusRName \\
          In the case of the focusing rule for transitioning from a left asynchronous judgement to a right synchronous judgement, the synthesis rule has the form:
          \[
            \fAddFocusRRuleNoLabel
          \]
          By induction on the first premise, we have that:
          \[
            [[ G |- C =>+ t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.
    \item Case 6. Focus Left: \fAddFocusLName \\
          In the case of the focusing rule for transitioning from a left asynchronous judgement to a left synchronous judgement, the synthesis rule has the form:
          \[
            \fAddFocusLRule
          \]
          By induction on the first premise, we have that:
          \[
            [[ G, x : A |- C =>+ t ; D ]] \tag{ih}
          \]
          from case 2 of the lemma.

  \end{enumerate}
\end{proof}

\subsection{Soundness of Focusing for the Additive Pruning Linear Graded Synthesis Calculus}
\label{proof:focusAddPruningSound}
%\focusSoundAddPruning*
\focusSoundAddPruning*

\begin{proof}
  \begin{enumerate}
      \item Case: 1. Right Async: The proofs for right asynchronous rules are equivalent to those of lemma  \eqref{lemma:fAddSynthSound}\\
    \item Case 2. Left Async: The proofs for left asynchronous rules are equivalent to those of lemma \eqref{lemma:fAddSynthSound}\\
    \item Case 3. Right Sync: The proofs for right synchronous rules are equivalent to those of lemma \eqref{lemma:fAddSynthSound}, except for the case of the \addPruningPairIntroName rule:\\
      \begin{enumerate}
        \item Case \addPruningPairIntroName \\
          In the case of the right synchronous rule for pair introduction, the synthesis rule has the form:
          \[
          \fAddAltPairIntroRule
          \]
          By induction on the premises, we have that:
          \[
           [[G |- A =>+ t1 ; D1]]   \tag{ih1}
          \]
          \[
           [[G - D1 |- B =>+ t2 ; D2]]   \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiation of the \addPruningPairIntroName\ synthesis rule in the non-focusing calculus:
          \[
    \inferrule*[right=${\otimes_{\textsc{R}}^{\pm}}$]
    {[[G |- A =>+ t1 ; D1]] \\ [[G - D1 |- B =>+ t2 ; D2]]}
    {[[G |- Tup A B =>+ pair t1 t2 ; D1 + D2]]}
          \]
      \end{enumerate}
    \item Case 4. Left Sync: The proofs for left synchronous rules are equivalent to those of lemma  \eqref{lemma:fAddSynthSound}, except for the case of the \addPruningAppName\  rule:\\\\
      \begin{enumerate}
          \item Case \addPruningAppName \\
          In the case of the left synchronous rule for application, the synthesis rule has the form:
          \[
          \fAddAltAppRule
          \]
          By induction on the first premise, we have that:
          \[
            [[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \tag{ih1}
          \]
          from case 4 of the lemma. By induction on the second premise, we have that:
          \[
            [[G |- A =>+ t2 ; D2 ]] \tag{ih2}
          \]
          from case 3 of the lemma. From which, we can construct the following instantiation of the \addPruningAppName\ synthesis rule in the non-focusing calculus:
          \[
\inferrule*[right=$\multimap_{\textsc{L}}^{\pm}$]
    {[[G, x2 : B |- C =>+ t1 ; D1, x2 : B]] \\ [[G - D1 |- A =>+ t2 ; D2 ]]}{[[G, x1 : A -o B |- C =>+
    [(x1 t2) / x2] t1 ; (D1 + D2), x1 : A -o B]] }
          \]
      \end{enumerate}
    \item Case 5. Right Focus: \fAddFocusRName\ - The proof for right focusing rule is equivalent to that of lemma \eqref{lemma:fAddSynthSound}\\
    \item Case 6. Left Focus: \fAddFocusLName\ - The proof for left focusing rule is equivalent to that of lemma \eqref{lemma:fAddSynthSound}\\
  \end{enumerate}
\end{proof}

\section{Proofs for the Deriving Mechanism}
This section contains the proofs relating to Chapter~\ref{chapter:deriving}. We begin 
by presenting a typed equational theory for use in the proofs that \emph{push} and 
\emph{pull} are the inverse of each other (Section~\ref{sec:typed-eq}). The type soundness proofs 
of \emph{push} and \emph{pull} then follow in Section~\ref{proof:deriving-type-soundness}, followed by the aforementioned 
inverse proofs in Section~\ref{proof:inverse-proofs}.

\subsection{Typed Equational Theory}
\label{sec:typed-eq}

Figure~\ref{fig:equational} defines an equational theory for the linear base
Granule typing calculus used in Chapter~\ref{chapter:deriving}. The equational
theory is typed, and we provide the typed forms of the rules also. For those
rules which are type restricted, we include the full typed-equality judgment
here. The type-ability of these equations relies on previous work on the Granule
language which proves that pattern matching and substitution are well
typed~\cite{DBLP:journals/pacmpl/OrchardLE19}.

\begin{figure}[H]
  % \begin{itemize}
    % \item $\beta$: 
    \begin{align*}
    \beta: \;\; [[ ( \ x . t2 ) t1 ]] \ \equiv \ [[t2]] [ [[t1]] / [[ x ]] ]
    \end{align*}
    % \item $\eta$:
    \vspace{-3em}
    \begin{align*}
      \eta: \;\; [[ \ x . {t x} ]] \ \equiv \ [[t]] \quad  ( [[ x ]] \# [[ t ]] ) 
    \end{align*}
    % \item $\beta_\textsc{Let}$: 
    \vspace{-3em}
    \begin{align*}
      \beta\textsc{Let}: \;\; [[ letrec x = t1 in t2  ]] \equiv \ [[ t2 ]] [ [[ letrec x = t1 in t1 ]] / [[ x ]] ] 
    \end{align*}
    % \item $\textsc{Dist}_\textsc{Let}$: 
    \vspace{-3em}
    \begin{align*}
     \textsc{Dist}\textsc{Let}: \;\; [[ f (letrec x = t1 in t2)  ]] \equiv \ [[ letrec x = t1 in (f t2)  ]] 
    \end{align*}
    % \item $\beta_\textsc{Case}$: 
    \vspace{-3em}
    \begin{align*} 
       \beta\textsc{Case}: \;\; [[ case t of many pi ti ]] \ \equiv \ (t \rhd [[ pj ]] )[[ tj ]]  \  \quad (\textsf{minimal}(j))
    \end{align*}  
    % \item $\eta_\textsc{Case}$:
    \vspace{-3em}
    \begin{align*}
      \eta\textsc{Case}: \;\; [[ case t1 of many pi { [ pi / z ] t2  } ]] \ \equiv \ [[ [ t1 / z ] t2  ]]
    \end{align*}
    % \item $\textsc{Assoc}_\textsc{Case}$:
    \vspace{-3em}
    \begin{align*}
     & \textsc{AssocCase}: \;\; [[ case (case t of many pi ti) of many pi' ti' ]] \\ 
     & \qquad\qquad\qquad \equiv\ [[ case t of many pi (case ti of many pi' ti') ]]  
    \end{align*}
    % \item $\textsc{Dist}_\textsc{Case}$: 
    \vspace{-3em}
    \begin{align*}
     \textsc{DistCase}: \;\; [[ f (case t of many pi ti) ]] \equiv\ [[ case t of many pi (f ti) ]]
    \end{align*}
    % \item $\textsc{Assoc}_\Box$: 
    \vspace{-3em}
    \begin{align*}
    & \textsc{Assoc}\Box: \;\; [[ case [case t of many pi ti] of many [pi'] ti' ]] \\ 
    & \qquad\qquad\qquad \equiv\ [[ case [t] of many [pi] {case [ti] of many [pi'] ti'} ]] \quad ([[ lin  pi ]])
    \end{align*}
  % \end{itemize}
                                          
%    [[ f (case t of many pi ti) ]] \ &\equiv\ [[ case t of many pi (f ti) ]] & \ {\small{\textsc{CaseDistrib}}} \\
  % \end{align*}
%   \begin{align*}
%     \hspace{-10em}\begin{array}{c}
%       \setlength{\arraycolsep}{0.15em}
%   \begin{array}{rlr}
%     \\
%     [[ case t of many pi ti ]] \ &\equiv \ (t \rhd [[ pj ]] )[[ tj ]]  \ & \;\; (\textsf{minimal}(j)) \ \beta_{case} \\
%     [[ case t1 of many pi { [ pi / z ] t2  } ]] \ &\equiv \ [[ [ t1 / z ] t2  ]] & \ \eta_{case} \\
%     %[[ case t1 of p1 -> {t2 [ p1 / z ]} ; * ; pn -> {t2 [ pn / z ]} ]] \ &\equiv \ [[ t2 [ t1 / z ] ]] & \ \eta_{case} \\
% %    [[ case (case t of p1 -> t1; * ; pn -> tn ) of p1' -> t1'; * ; pn' -> tn' ]] &\equiv \ [[ case t of p1 -> (case t1 of p1' -> t1'); * ; pn -> (case tn of pn' -> tn') ]] & \ \textit{case assoc.} \\
%    [[ case (case t of many pi ti) of many pi' ti' ]] &\equiv\
%    [[ case t of many pi (case ti of many pi' ti') ]] &\ {\small{\GRANULEdruleEquivXXcaseAssocName{}}}\\
%    [[ f (case t of many pi ti) ]] \ &\equiv\ [[ case t of many pi (f ti) ]] & \ {\small{\textsc{CaseDistrib}}} \\
%    [[ case [case t of many pi ti] of many [pi'] ti' ]] &\equiv\
%    [[ case [t] of many [pi] {case [ti] of many [pi'] ti'} ]] & \;\; ([[ lin  pi ]]) \ {\small{\GRANULEdruleEquivXXcaseBoxAssocName{}}}\\
%    %
%   \end{array}
% \\ \\
% \GRANULEdruleEquivXXcaseGen{}
%     \end{array}
%    \end{align*}
 \caption{Equational theory for linear base Granule}
 \label{fig:equational}
\end{figure}

The $\beta$ and $\eta$ rules follow the standard rules from the
$\lambda$-calculus, where $\#$ is a \textit{freshness} predicate,
denoting that variable $x$ does not appear inside term $t$.

For recursive \textbf{letrec} bindings, the $\beta_{letrec}$ rule substitutes
any occurrence of the bound variable $x$ in $[[t2]]$ with $[[ letrec x
= t1 in t1 ]]$, ensuring that recursive uses of $x$ inside $[[t1]]$
can be substituted with $[[t1]]$ through subsequent $\beta_{letrec}$
reduction. The \textsc{LetRecDistrib} rule allows distributivity of
functions over \textbf{letrec} expressions, stating that if a function
$f$ can be applied to the entire \textbf{letrec} expression, then this
is equivalent to applying $f$ to just the body term $[[t2]]$.

Term elimination is via \textbf{case}, requiring rules for both $\beta$- and
$\eta$-equality on case expressions, as well as rules for associativity and
distributivity. In $\beta_{case}$, a term $t$ is matched against a pattern $[[
pj ]]$ in the context of the term $[[ tj ]]$ through the use of the partial
function $(t\ \rhd\ [[ pj ]])[[ tj ]] = t'$ which may substitute terms bound in
$[[ pj ]]$ into $[[ tj ]]$ to yield $t'$ if the match is successful. This
partial function is defined inductively:
%
{{
\begin{align*}
\setlength{\arraycolsep}{0em}
\begin{array}{cc}
\inferrule*[right=$\rhd_{-}$]
 {\quad}
  {( [[ t ]] \rhd \_) [[ t' ]] = [[ t' ]]}
%
\;\;\;
&
\inferrule*[right=$\rhd_{var}$]
 {\quad}
 {( [[ t ]] \rhd [[ x ]]) [[ t' ]] = [[ [ t / x ] t' ]]}
 \\[1.25em]
\inferrule*[right=$\rhd_{\Box}$]
 {( [[ t ]] \rhd [[ p ]]) [[ t' ]] = [[ t'' ]]}
 {( [[ [ t ] ]] \rhd [[ [ p ] ]]) [[ t' ]] = [[ t'' ]]}
%
\;
&
\inferrule*[right=$\rhd_{C}$]
 {( [[ ti ]] \rhd [[ pi ]]) [[ t ]]'_{i} = [[ t ]]'_{i+1}}
 {( C\ {t_{1} ... t_{n}} \rhd [[ Con p1 ... pn ]]) [[ t ]]'_{1} = [[ t ]]'_{n+1}}
\end{array}
\end{align*}
}}
As a predicate to the $\beta_{case}$ rule, we require that $j$ be
minimal, i.e.\ the first pattern $[[pj]]$ in $[[p1]] ... [[ pn ]]$ for
which $(t\ \rhd\ [[ pj ]])[[ tj ]] = t'$ is defined. Rule $\eta_{case}$ states that if all branches of the case expression share a common term $t_{2}$ which differs between branches only in the occurrences of terms that match the pattern used, then we can substitute $t_{1}$ for the pattern inside $t_{2}$.

Associativity of case expressions is provided by the \textsc{CaseAssoc} rule.
This rule allows us to restructure nested case expressions such that the output
terms $[[ ti ]]$ of the inner case may be matched against the patterns of the
outer case, to achieve the same resulting output terms $[[ t'i ]]$. The
\textsc{[CaseAssoc]} rule provides a graded alternative to the
\textsc{CaseAssoc} rule, where the nested case expression is graded, provided
that the patterns $[[ p'i ]]$ of the outer case expression are also graded.
Notably, this rule only holds when the patterns of the inner case expression are
linear (i.e., variable or constant) so that there are no nested box patterns,
represented via the $[[ lin pi ]]$ predicate. As with \textbf{letrec},
distributivity of functions over a case expression is given by
\textsc{CaseDistrib}.


Lastly generalisation of an arbitrary boxed pattern to a variable is permitted
through the \textsc{CaseGen} rule. Here, a boxed pattern $[[  [pi] ]]$ and the
output term of the case may be converted to a variable if the output term is
equivalent to the pattern inside the box. The term $[[t]]$ being matched against
must therefore have a grade approximatable by 1, as witnessed by the predicate
$[[ 1 <<= r ]]$ in the typing derivation.




  \begin{figure}
{\scalebox{0.82}{\begin{minipage}{1.0\linewidth}
      \begin{align*}
        {\footnotesize{
        \hspace{-6em}
  \begin{array}{c}
\GRANULEdruleEquivXXbeta{} \\[2.25em]
\GRANULEdruleEquivXXeta{} \\[2.25em]
\GRANULEdruleEquivXXletrecBeta{} \\[2.25em]
\GRANULEdruleEquivXXletrecDist{} \\[2.25em]
\GRANULEdruleEquivXXcaseBeta{} \\[2.25em]
\GRANULEdruleEquivXXcaseEta{} \\[2.25em]
\GRANULEdruleEquivXXcaseGen{} \\[2.25em]
\GRANULEdruleEquivXXcaseAssoc{} \\[2.25em]
\GRANULEdruleEquivXXcaseBoxAssoc{} \\[2.25em]
\GRANULEdruleEquivXXcaseDist{} \\[2.25em]
\end{array}
        }}
\end{align*}
\end{minipage}}}
\label{fig:typed-eqt}
\caption{Typed equational theory for linear base Granule}
\end{figure}
%
In $\GRANULEdruleEquivXXcaseAssocName{}$
the predicate $[[ lin p ]]$ classifies those
patterns which are \emph{linear}, which are those which
are variables or constructor patterns only.

\subsubsection{Derived Rules}

\begin{restatable}[`Case push' property]{prop}{casePush}
%
\[
  {\footnotesize{
\GRANULEdruleEquivXXcasePushDerived{}
  }}
\]
\end{restatable}

\begin{proof}
Applying $\beta_{case}$ and congruence over promotion, to the left-hand side
of the case push equation yields:
$$[[ [case t of [pi] -> ti] ]] = [[ [ (t |> pj) tj ] ]]$$
for the smallest $j$.
Applying $\beta_{case}$ to the right-hand side of the case
push equation yields:
$$[[ case [t] of [pi] -> [ti] ]] = [[ ([t] |> [pi]) [tj] ]]$$
for the same smallest $j$ (since the patterns $pi$ are the same).

By \GRANULEdrulepatSemunboxName{}, then we have the
derivation of pattern matching:
%
\[
\inferrule*[Right=\GRANULEdrulepatSemunboxName{}]
 {[[ ( t |> pi ) [tj] = t'' ]]}
 {[[ ( [ t ] |> [ pi ] ) [tj] = t'']]}
\]
%
therefore $[[ case [t] of [pi] -> [ti] ]] = [[ ([t] |> [pi]) [tj] ]] =
 [[ ( t |> pi ) [tj] ]]$.

Then by Proposition~\ref{prop:pat-distrib} (below),
$[[ ( t |> pi ) [tj] ]] = [[ [ (t |> pj) tj ] ]]$,
yielding case push.
\end{proof}

\begin{restatable}[Pattern matching distributes with promotion]{prop}{patDistrib}
\label{prop:pat-distrib}
For all $[[ t ]], [[ p ]], [[ t' ]]$ then:
%
\[
[[ (t |> p) [t'] ]] = [[ [(t |> p) t'] ]]
\]
\end{restatable}

\begin{proof}
By induction on syntactic pattern matching:
\begin{itemize}
\item (wild) $[[ (t |> _) [t'] ]] = [[ [t'] ]]$
and $[[ [ (t |> _) t'] ]] = [[ [t'] ]]$.

\item (var) $[[ (t |> x) [t'] ]] = [[ [t / x] [t'] ]] = [[ { [ { [t / x] t'  } ] }
  ]]$
and $[[ [(t |> x) t' ] ]] = [[ {[ [t / x] t'  ]} ]]$

\item (unbox)
\[
\GRANULEdrulepatSemunbox{}
\]
%
By induction then $[[ (t |> p) [t'] ]] = [[ { [ (t |> p) t' ] } ]]$
therefore $[[ ([t] |> [p]) [t'] ]] = [[ { [ ([t] |> [p]) t' ] } ]]$
since this rule preserves its result in the conclusion.

\item (constr)
\[
\GRANULEdrulepatSemconstr{}
\]
%
By induction, similarly to the above case, but across
multiple terms.

\end{itemize}
\end{proof}

\subsection{Functor Derivation}
\label{app:functor-derivation}

\begin{definition}[Deriving functor]
Given a function $f : \alpha \multimap \beta$ then
there is a function $\deriv{fmap}{\tcF \overline{\alpha}}(f)
: \tcF\ \alpha \multimap \tcF\ \beta$ derived from the type
$\tcF \overline{\alpha}$ as follows:
%
\begin{align*}
  \begin{array}{ll}
  \deriv{fmap}{\mathsf{Unit}}^\Sigma(f)\ z &= \ [[ case z of () -> () ]]\\
  \deriv{fmap}{\alpha}^\Sigma(f)\ z &= \ f\ z\\
  \deriv{fmap}{X}^\Sigma(f)\ z &= \ (\Sigma(X)\ f)\ z \\
  \deriv{fmap}{\Box_{r}A}(f)\ z &= \derCaseOne{z}{ [[ [y] ]] }{ [ \deriv{fmap}{A}(f)\  [[ y ]] ] } \\
  \deriv{fmap}{A \oplus B}^\Sigma(f)\ z &= \ \derCaseTwo{z}{\mathsf{inl}\
                                       x}{\mathsf{inl}\ \deriv{fmap}{A}^\Sigma(f)\ x}{\mathsf{inr}\ y}
                            {\mathsf{inr}\ \deriv{fmap}{B}^\Sigma(f)\ y}
\\
  \deriv{fmap}{A \otimes B}^\Sigma(f)\ z &= \ \derCaseOne{z}{(x, y)}
   {( \deriv{fmap}{A}^\Sigma(f)\ x, \deriv{fmap}{B}^\Sigma(f)\ y )} \\
  \deriv{fmap}{A \multimap B}^\Sigma(f)\ z &= \  \lambda x . \deriv{fmap}{B}^\Sigma(f)\ (z\ x) \\
  \deriv{fmap}{\mu X . A}^\Sigma(f)\ z &= \ \derLetRec{g}{\deriv{fmap}{A}^{\Sigma, X \mapsto
g : [[ (a -o b) ]] \multimap [[ {mu X . A} ]] \multimap [[ {{(mu X . A)} [ a /* b ]} ]] }(f)}{g\ z}
    \end{array}
\end{align*}
\end{definition}

\subsection{Type Soundness of \emph{push} and \emph{pull}}
\label{proof:deriving-type-soundness}
%
The following shows that the calculation of \emph{push}
and \emph{pull} distributive laws is well-typed.

% \begin{proposition}
% \label{prop:soundness-pull}
% Type soundness of $\deriv{pull}{\tcF\ \overline{\alpha_i}} : \tcF\ (\overline{\Box_{r_i} \alpha_i})
% \rightarrow \Box_{\bigwedge^n_{i = 1} r_i} (\tcF\  \overline{\alpha_i})$.
% \end{proposition}


\pushSound*
% \begin{proposition}
% \label{prop:soundness-push}
% Type soundness of $\deriv{push}{\tcF\ \overline{\alpha_i}}^{\Sigma} :
% \deriv{push}{\tcF \overline{\alpha_i}}^{\Sigma} : \Box_{r} \tcF \overline{\alpha_i}
%   \rightarrow  \tcF  (\overline{\Box_{r} \alpha_i})$.
% \end{proposition}

\begin{proof}
  \
\begin{itemize}
\item $\deriv{push}{ [[ Unit ]]}^{\Sigma} : [[ {[] r Unit} -> Unit ]]$
 (i.e. $\tcF\ \overline{\alpha_i} = [[ Unit ]]$).

{\footnotesize{
\begin{align*}
  \inferrule*[right=case]
   {
    \inferrule*[right=con]
         {\quad}{[[ . |- () : Unit ]]}
    \quad
    \inferrule*[right={[}pbox{]}]{
     \inferrule*[right={[}pcon{]}]
       {[[ | Unit | == 1 ]] }
       {[[ r  |- () : Unit |> . ]]}
     }{
       [[ none |- [ () ] : Unit |> . ]]
     }
   }
   {[[ z : [] r Unit |- case z of [ () ] -> () : Unit ]]}
\end{align*}
    }}

%%%%% push rec var

\item $\deriv{push}{ X }^{\Sigma} : [[ {[] r X} -> {X [ [] r ai /* ai ]} ]]$
 (i.e. $\tcF\ \overline{\alpha_i} = X$).

{\footnotesize{
    \begin{align*}
      \inferrule*[right=app]
      {\inferrule*[right=lookup,leftskip=10em]
      { X : [[ {[] r (mu X . A)} -o {(mu X . A) [ [] r ai /* ai ]} ]] \in [[ Sig ]]}
      {[[ Sig |- {lookup Sig X} : {[] r (mu X . A)} -o {(mu X . A) [ [] r ai /* ai ]} ]]} \\
      \inferrule*[right=var,rightskip=10em]{\quad}
      {[[z : {[] r (mu X . A)} |- z : {[] r (mu X . A)} ]]}}{[[ Sig, z
      : {[] r (mu X . A)} |- {lookup Sig X}  z : (mu X . A) [ [] r ai /* ai ] ]]}
    \end{align*}
    }}
\item $\deriv{push}{ [[ aj ]] }^{\Sigma} : [[ {[] rj aj} -> [] rj aj ]]$
 (i.e. $\tcF\ \overline{\alpha_i} = \alpha $).

{\footnotesize{
\begin{align*}
\inferrule*[right=var]
  {\quad}
  {[[ z : {[] rj aj} |- z : {[] rj aj} ]]}
\end{align*}
    }}

\item $\deriv{push}{ [[ Sum A B ]]}^{\Sigma} : [[ {[] r (Sum A B)} -> (Sum {{A} [ [] r ai /* ai ]} {{B} [ [] r ai /* ai ]}) ]]$


\footnotesize{
\begin{equation}
\label{eq:push-deriv-sum-sub1}
\inferrule*[right=Con]{\inferrule*[right=app]{ \inferrule*[right=push]{\quad}{[[ . |- pushP Sig A : {[] r A} -o {A [ [] r ai /* ai ]} ]] } \\ \inferrule*[right=Pr]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[
          x : A |- x : A ]]}}{[[
       x : [ A ] 1 |- x : A ]]}}{[[ x : [
      A ] r |- [ x ] : [] r A  ]]}}{[[ x : [ A ] r |- push Sig A ( [ x ] ) : {
      A} [ [] r ai /* ai ]
    ]]}}{[[ x : [ A ] r |- inr push Sig A ( [ x ] )  : Sum { {A} [ [] r ai /* ai ]}
  {{B} [ [] r ai /* ai ]} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-sum-sub2}
\inferrule*[right=Con]{\inferrule*[right=app]{ \inferrule*[right=push]{\quad}{[[ . |- pushP Sig B : {[] r B} -o {B [ [] r ai /* ai ]} ]] } \\ \inferrule*[right=Pr]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[
          y : B |- y : B ]]}}{[[
       y : [ B ] 1 |- y : B ]]}}{[[ y : [
      B ] r |- [ y ] : [] r B  ]]}}{[[ y : [ B ] r |- push Sig B ( [ y ] ) : {
      B} [ [] r ai /* ai ]
    ]]}}{[[ y : [ B ] r |- inr push Sig B ( [ y ] )  : Sum { {A} [ [] r ai /* ai ]}
  {{B} [ [] r ai /* ai ]} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-sum-sub3}
\inferrule*[right={[}Pbox{]}]{\inferrule*[right={[}Pcon{]}]{ \inferrule*[right={[}Pvar{]}]{\quad}{[[ r
       |- x : A |> x : [ A ] r ]]} \\ [[ |Sum A B| > 1 ]] \Rightarrow [[ 1 <<= r ]]}{ [[ r |- inl ( x ) : Sum A B |> x :
    [ A ] r  ]] }}{[[ none |- [ inl ( x ) ] : [] r {Sum A B} |> x :
  [ A ] r ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-sum-sub4}
\inferrule*[right={[}Pbox{]}]{\inferrule*[right={[}Pcon{]}]{ \inferrule*[right={[}Pvar{]}]{\quad}{[[ r |- y : B |>  y : [ B ] r ]]} \\ [[ |Sum A B| > 1 ]] \Rightarrow [[ 1 <<= r ]]}{ [[ r  |- inr ( y ) : Sum A B |> y :
    [ B ] r ]] }}{[[ none |- [ inr ( y ) ] : [] r {Sum A B} |> y :
  [ B ] r ]]}
\end{equation}
    }


{\footnotesize{
\begin{equation}
  \label{eq:push-deriv-sum-term}
[[ case z of [ inl ( x ) ] -> inl push Sig A ( [ x ] ) ;
  [ inr ( y ) ] -> inr push Sig B ( [ y ] ) ]] 
\end{equation}
}}

{\footnotesize{
\begin{align*}
  \hspace{-7em}\inferrule*[right=Case]{
    % \inferrule*[right=var,leftskip=7em]{\quad}{[[ z : Sum A B |- z : Sum A B ]]} \\
  \eqref{eq:push-deriv-sum-sub1} \\ \eqref{eq:push-deriv-sum-sub2} \\
  \eqref{eq:push-deriv-sum-sub3} \\ \eqref{eq:push-deriv-sum-sub4}
  }{ [[ z : [] r (Sum A B) ]] \vdash  \eqref{eq:push-deriv-sum-term}: [[ Sum {{ A} [ [] r ai /* ai ]} {{
  B} [ [] r ai /* ai ] } ]]}
\end{align*}
 }}

\item $\deriv{push}{ [[ Tup A B ]]}^{\Sigma} : [[ {[] r (Tup A B)} -> (Tup {{
    A} [ [] r ai /* ai ]} {{B} [ [] r ai /* ai ]}) ]]$

\footnotesize{
\begin{equation}
  \label{eq:push-deriv-pair-sub4}
  \inferrule*[right=app]{\inferrule*[right=push]{\quad}{ [[ . |- pushP Sig A : {[] r A} -o {A [ [] r ai /* ai ]}]]} \\ \inferrule*[right=pr]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[
          x : A |- x : A  ]]}}{[[
        x : [ A ] 1 |- x : A ]]}}{[[ x : [ A ] r |- [ x ] : [] r
      A ]]}}{[[ x : [ A ] r |- push Sig A ( [ x ] ) : {A} [ [] r ai /* ai ]  ]]}
\end{equation}}

\footnotesize{
\begin{equation}
  \label{eq:push-deriv-pair-sub5}
  \inferrule*[right=app]{\inferrule*[right=push]{\quad}{ [[ . |- pushP Sig B : {[] r B} -o {B [ [] r ai /* ai] }]]}\\ \inferrule*[right=pr]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[
          y : B |- y : B   ]]}}{[[
        y : [ B ] 1 |- y : B ]]}}{[[ y : [ B ] r |- [ y ] : [] r
      B ]]}}{[[ y : [ B ] r |-
    push Sig B ( [ y ] ) : {B} [ [] r ai /* ai ]  ]]}
\end{equation}}

\footnotesize{
\begin{equation}
\label{eq:push-deriv-pair-sub1}
\inferrule*[right=Con]
{ \eqref{eq:push-deriv-pair-sub4}
  \\
\eqref{eq:push-deriv-pair-sub5}
  }
{ [[ x : [ A ] r, y : [ B ] r |- pair {push Sig A ( [ x ] )} {push Sig B ( [ y ] )} : Tup
  { {A} [ [] r ai /* ai ] } {  {B} [ [] r ai /* ai ] } ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-pair-sub2}
\inferrule*[right={[}Pbox{]},rightskip=10em]{\inferrule*[right={[}PCon{]}]{\inferrule*[right={[}Pvar{]},leftskip=1em]{\quad}{[[
  r  |- x : A |> x : [ A ] r ]]} \\
\inferrule*[right={[}Pvar{]},rightskip=2em]{\quad}{[[ r  |- y : B |> y : [ B
 ] r ]]} \\ |[[Tup A B]]| = 1 }{[[ r
  |- Pair x y : Tup A B |> x : [ A ] r, y : [ B ] r ]]}}{[[ none |- [ Pair x y ] : [] r
  {Tup A B} |> x : [ A ] r, y : [ B ] r ]]}
\end{equation}
   }

\footnotesize{
  \begin{equation}
    \label{eq:push-deriv-pair-term}
  [[ case z of [ Pair x y ] -> pair {
  push Sig A ( [ x ] )}  {push Sig B ( [ y ] )} ]]
  \end{equation}
}

\footnotesize{
\begin{align*}
  \inferrule*[right=Case]{
  % \inferrule*[right=var,leftskip=7em]{\quad}{[[ z : Tup A B |- z : Tup A B ]]} \\
  \eqref{eq:push-deriv-pair-sub1} \\ \eqref{eq:push-deriv-pair-sub2}
  }{[[ z : [] r (Tup A B) ]] \vdash \eqref{eq-push-deriv-pair-term} : [[ Tup {{A} [ [] ri ai /* ai ]} {{
  B} [ [] ri ai /* ai ]} ]]}
\end{align*}
    }

\item $\deriv{push}{ [[ A -o B ]]}^{\Sigma} : [[ {[] r (A -o B)} -> ({{A} [ [] r ai /* ai ]}
  -o {{B} [ [] ri ai /* ai ]}) ]]$

  \footnotesize{
\begin{equation}
  \label{push-deriv-fun-1}
\inferrule*[right=Pr, rightskip=15em]{\inferrule*[right=app]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[
          f : {A -o B} |- f : A -o B ]]}}{ [[ f : [ { A
      -o B }  ] 1 |- f : A -o B ]]} \\
      \inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[ x : A  |- x : A
          ]]}}{[[  x : [ A ] 1 |- x : A ]]}}{[[ f : [ { A
      -o B } ] 1, x : [ A ] 1 |- f x : B
    ]]}}{[[ f : [ {A -o B} ] r, x : [ A ]
    {BigMeet ri} |- [ f x ] : {[] r {B }}]]}
\end{equation}
  }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-abs-sub3}
\inferrule*[right=app]{ \inferrule*[right=push, leftskip=10em]{\quad}{[[ . |- pushP Sig B : {[] r B} -o {B [ [] r ai /* ai]} ]]} \\ \eqref{push-deriv-fun-1} }
{[[ f : [ {A -o B} ] r, x : [ A ] {BigMeet ri} |- push Sig B [ f x ] : {{B [ [] r ai /* ai ] } }  ]]}
\end{equation}
 }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-abs-sub4}
\inferrule*[right={[}Pbox{]}]{\inferrule*[right={[}Pvar{]}]{\quad}{[[ {BigMeet ri} |- x : A |> x :
    [ A ] {BigMeet ri}]]}}{[[none |- [ x ] : [] r
  A |> x : [ A ] {BigMeet ri} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-abs-sub1}
\inferrule*[right=Case]{
  \inferrule*[right=app]{\inferrule*[right=pull]{\quad}{[[ . |- pullP Sig A : A -o {[] {BigMeet ri} A} ]]} \\ \inferrule*[right=var]{\quad}{[[ y : { A } |- y : {A}
      ]]}}{[[ y : { A } |- pull Sig A (y) : [] {BigMeet
      ri} A ]]} \\
  \eqref{eq:push-deriv-abs-sub3} \\ \eqref{eq:push-deriv-abs-sub4} }{[[ y : {A} , f : [ {A -o B} ] r |- case pull Sig A (y) of [
  x ] -> push Sig B [ f x ] : {{B [ [] r ai /* ai ]}} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:push-deriv-abs-sub2}
\inferrule*[right={[}Pbox{]}]{\inferrule*[right={[}Pvar{]}]{\quad}{[[ r  |- f : (A -o B) |> f : [
    {A -o B}] r ]]}}{[[ none |- [ f ] : [] r ( A -o B ) |> f : [ {A -o B} ] r  ]]}
\end{equation}
    }

  
\footnotesize{
\begin{equation}
  \label{push-deriv-fun-term}
[[ case z of [f] -> case pull Sig A (y) of [ x
  ] -> push Sig B [ f x ] ]] 
\end{equation}
}

{\footnotesize{
\begin{align*}
\hspace{-5em}\inferrule*[right=abs]
  {\inferrule*[right=Case]{
 % \inferrule*[right=Var]{\quad}{[[ z : [] r (A -o B) |- z : [] r ( A -o B ) ]]}
  \eqref{eq:push-deriv-abs-sub1} \\
  \eqref{eq:push-deriv-abs-sub2}}{[[ z : [] r (A -o B), y : {  A } ]] \vdash \eqref{push-deriv-fun-term} : [[ {B} [ [] r ai /* ai ] ]]}}
{[[ z : [] r (A -o B) ]] \vdash \lambda y . \eqref{push-deriv-fun-term} : [[ {{A [ [] r ai /* ai ]}} -o {{B [ [] r ai /* ai ]}} ]]}
\end{align*}
    }}

\item $\deriv{push}{ [[ mu X . A ]] }^{\Sigma} : [[( mu X . {[] r A} ) -> ( mu X
    . { A [ [] ri ai /*
  ai ] }) ]]$
    (i.e. $\tcF\ \overline{\alpha_i} = [[ mu X . A ]]$).


\footnotesize{
  \begin{equation}
    \label{eq:rec-eq-new}
\inferrule*[right=var,leftskip=10em]{\quad}{[[ Sig, f
      : {mu X . {[] r A}} -o (mu X . {A [ [] r ai /* ai ]}) |- f : {mu X . {[] r A}}
                                 -o (mu X . { A [ [] r ai /* ai ]}) ]]}
  \end{equation}
}

    \footnotesize{
\begin{equation}
\label{eq:pull-deriv-rec-sub1}
      \inferrule*[right=app]{\eqref{eq:rec-eq-new}
      \\ \inferrule*[right=var,rightskip=10em]{\quad}{[[ Sig, z : {mu X . {[]
            r A}} |- z :
      {mu X . {[] r A} } ]]}}{[[ Sig, f
      : {mu X . {[] r A}} -o (mu X . {A [ [] r ai /* ai ]}), z : {mu X . {[] r
          A}} |- f z : (mu X . {A [ [] r ai /* ai ]})  ]]}
\end{equation}
    }

{\footnotesize{
    \begin{align*}
      \inferrule*[right=letrec]{ {\inferrule*[right=push,leftskip=10em]{\quad}{
      [[ Sig |- push {Sig, recvar {{mu X . {[] r A }} -o (mu X . {A [ [] r ai /* ai ]})}}  A
      nothing : {mu X . {[] r A}}
      -o (mu X . {A [ [] r ai /* ai ]}) ]]} } \\
      \eqref{eq:pull-deriv-rec-sub1}
  }{[[ Sig, z : (mu X . {[] r A}) |- letrec f =
      {push {Sig, recvar {{mu X . {[] r A }} -o (mu X . {A [ [] r ai
      /* ai ]})}} A nothing} in {f z} : { mu X . {A [ [] r ai /* ai ] }}
      ]]}
      \end{align*}
}}
\end{itemize}
\end{proof}

\pullSound*

\begin{proof}
  \
\begin{itemize}

%%%%% pull Unit

\item $\deriv{pull}{ [[ Unit ]]}^{\Sigma} : [[ Unit -> [] (BigMeet ri) Unit ]]$
    (i.e. $\tcF\ \overline{\alpha_i} = [[ Unit ]]$).
{\footnotesize{
\begin{align*}
  \inferrule*[Right=case]
   {
    %\inferrule*[Right=var]
    %   {\quad}{[[ Sigma, z : Unit |- z : Unit ]]}
   % \\
    \quad
    \inferrule*[Right=pr]
      {\inferrule*[Right=con]
         {\quad}{[[ . |- () : Unit ]]}}
      {[[ . |- [ () ] : [] {BigMeet ri} Unit ]]}
    \\
    \quad
    \\
    \quad
     \inferrule*[Right=Pcon]
       {| [[ Unit ]] = 1 |}
       {[[ none |- () : Unit |> . ]]}
   }
   {[[ z : Unit |- case z of () -> [ () ] : [] {BigMeet ri} Unit ]]}
\end{align*}
}}

%%%%% pull rec var

\item $\deriv{pull}{ X }^{\Sigma} : [[ X -> [] (BigMeet ri) X ]]$
 (i.e. $\tcF\ \overline{\alpha_i} = X$).

{\footnotesize{
    \begin{align*}
      \inferrule*[right=app]
      {\inferrule*[right=lookup,leftskip=10em]{ X : [[{mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] \in [[ Sig ]]}{[[ Sig |- {lookup Sig X} : {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]]} \\
      \inferrule*[right=var,rightskip=10em]{\quad}{[[z : {(mu X . A)
      [ [] ri ai /* ai ]} |- z : {(mu X . A) [ [] ri ai /* ai ]}]]}}{[[ Sig, z
      : {(mu X . A) [ [] ri ai /* ai ]} |- {lookup Sig X}  z : [] {BigMeet ri} (mu X . A)]]}
    \end{align*}
    }}

%%%%% pull ty var

\item $\deriv{pull}{ [[ aj ]] } : [[ {[] rj aj} -> [] (BigMeet ri) aj ]]$
 (i.e. $\tcF\ \overline{\alpha_i} = \alpha $).

\footnotesize{
\begin{align*}
\inferrule*[right=approx]
{\inferrule*[right=var]
  {\quad}
  {[[ Sig, z : {[] rj aj} |- z : {[] rj aj} ]]}
}
{[[ Sig, z : {[] rj aj} |- z : {[] (BigMeet ri) aj} ]]}
\end{align*}
    }

%%%%% pull sum

\item $\deriv{pull}{[[ (Sum A B) [ [] ri ai /* ai ] ]]}^{\Sigma} : [[ { Sum A B } -> [] (BigMeet ri) { Sum A B} ]]$
    (i.e. $\tcF\ \overline{\alpha_i} = [[ Sum A B ]] $).


\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sum-sub4}
  \inferrule*[right=pr]
  {\inferrule*[right=Con]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[
          x' : A |- x' : A]]}}{[[ x' : [ A ] 1 |-
        x' : A ]]}}{[[ x' : [ A ] 1 |- inl (
      x' ) : {Sum A B} ]]}}
  {[[ x' : [ A ] {BigMeet ri} |- [ inl ( x' ) ] : [] {BigMeet ri} {Sum A B} ]]}
\end{equation}
    }


\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sum-sub2}
  \inferrule*[right=case,leftskip=15em]
  {\inferrule*[right=app]{\inferrule*[right=pull]{\quad}{ [[. |- pullP Sig A : A -o [] {BigMeet ri} A ]]} \\ \inferrule*[right=var]{\quad}{[[ x : A [ [] ri ai /*
        ai ] |- x : A [ [] ri ai /*
        ai ] ]]}}{[[ x : A [ [] ri ai /* ai ] |- pull Sig A ( x ) : [] {BigMeet ri} A ]]} \\ \eqref{eq:pull-deriv-sum-sub4} \\
    \inferrule*[right={[}pbox{]},rightskip=15em]{\inferrule*[right={[}pvar{]}]{\quad}{[[ {BigMeet ri} |- x' : A |>
        x' : [ A ] {{BigMeet ri} }]]}}{[[ none |- [ x' ] : [] {BigMeet ri} A |> x' : [ A ] {BigMeet ri} ]]}}
  {[[ x : A [ [] ri ai /* ai ] |- case pull Sig A ( x ) of [ x' ] -> [
  inl (
  x' ) ] : [] {BigMeet ri} {
  Sum A B} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sum-sub5}
  \inferrule*[right=pr]
  {\inferrule*[right=Con]{\inferrule*[right=der]{\inferrule*[right=var]{\quad}{[[y' : B
          |- y' : B]]}}{[[ y' : [ B ] 1 |-
        y' : B ]]}}{[[ y' : [ B ] 1 |- inr (
      y' ) : {Sum A B} ]]}}
  {[[ y' : [ B ] {BigMeet ri} |- [ inr ( y' ) ] : [] {BigMeet ri} {Sum A B} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sum-sub3}
  \inferrule*[right=case,leftskip=15em]
  {\inferrule*[right=app]{\inferrule*[right=pull]{\quad}{[[ . |- pullP Sig B : B -o [] {BigMeet ri} B ]]} \\ \inferrule*[right=var]{\quad}{[[ y : B [ [] ri ai /*
        ai ] |- y : B [ [] ri ai /*
        ai ] ]]}}{[[ y : B [ [] ri ai /* ai ] |- pull B ( y ) : [] {BigMeet ri} B ]]} \\ \eqref{eq:pull-deriv-sum-sub5} \\
    \inferrule*[right={[}pbox{]},rightskip=15em]{\inferrule*[right={[}pvar{]}]{\quad}{[[ {BigMeet ri} |- y' : B |>
        y' : [ B ] { {BigMeet ri} }]]}}{[[ none |- [ y' ] : [] {BigMeet ri} B |> y' : [ B ] {BigMeet ri} ]]}}
  {[[ y : B [ [] ri ai /* ai ] |- case pull Sig B ( y ) of [ y' ] -> [
  inr (
  x2' ) ] : [] {BigMeet ri} {
  Sum A B} ]]}
\end{equation}
}

\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sum-sub6}
  \inferrule*[right=Pcon]{\inferrule*[right=pvar]{\quad}{[[none |- x : A [ [] ri ai /* ai ]
  |> x : A [ [] ri ai /* ai ] ]]}}{[[none |- inl ( x ) : ( Sum A B ) [ [] ri ai /* ai ] |> x : A [ [] ri ai /* ai ] ]]}
\end{equation}
}


\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sum-sub7}
\inferrule*[right=Pcon]{\inferrule*[right=pvar]{\quad}{[[none |- y :
  B [ [] ri ai /* ai ] |> y : B [ [] ri ai /* ai ] ]]}}{[[none |- inr ( x ) : (
Sum A B ) [ [] ri ai /* ai ] |> y : B [ [] ri ai /* ai ] ]]}
\end{equation}
    }


\footnotesize{
  \hspace{-8em}
\begin{equation}
\label{eq:pull-deriv-sum-sub8}
[[ case z of inl ( x ) -> ( case pull Sig A ( x ) of [ x' ] -> [
  inl (
  x' ) ] ) ; inr ( y ) -> ( case pull Sig B ( y ) of [ y' ] -> [ inr ( y' ) ] ) ]]
\end{equation}
}
\\

\footnotesize{
\begin{align*}
 \inferrule*[right=case,leftskip=5em]{
  \eqref{eq:pull-deriv-sum-sub2} \\ \eqref{eq:pull-deriv-sum-sub3} \\
  \\ \eqref{eq:pull-deriv-sum-sub6} \\ \eqref{eq:pull-deriv-sum-sub7} }
  {[[ z : {Sum A B} [ [] ri ai /* ai ] ]] \vdash \eqref{eq:pull-deriv-sum-sub8} : [[ [] {BigMeet ri} {
  Sum A B} ]]}
\end{align*}
}

%%%%%%%% PULL OTIMES
\item $\deriv{pull}{ [[ Tup A B ]] }^{\Sigma} : [[ ( Tup A B ) [ [] ri ai /*
  ai ] -> [] (BigMeet ri) ( Tup A B ) ]]$
    (i.e. $\tcF\ \overline{\alpha_i} = [[ Tup A B ]]$).

\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sub2}
  \inferrule*[Right=pr]
  {\inferrule*[right=Con]{
    \inferrule*[right=der]
      {\inferrule*[right=var]{\quad}{[[ x' : A |- x' :  A ]]}}
      {[[ x' : [ A ] 1 |- x' : A ]]
      } \\
     \inferrule*[right=der]
      {\inferrule*[right=var]{\quad}{[[ y' : B |- y' : B ]]}}
      {[[ y' : [ B ] 1 |- y' : B ]]}
   }
   {{[[ x' : [ A ] 1, y' : [ B ] 1  |- pair x' y' : Tup A B ]]}}
  }
  {[[ x' : [ A ] {BigMeet ri}, y' : [ B ] {BigMeet ri} |- [ pair x' y' ] :  [] {BigMeet ri} { Tup A B} ]]}
\end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sub3}
\inferrule*[right={[}Pcon{]},rightskip=12em]{\inferrule*[right={[}pbox{]},leftskip=3em]{\inferrule*[right={[}pvar{]}]{\quad}{ [[ {BigMeet ri} |- x' :
      A |> x' : [ A ] { {BigMeet ri}  }]]}}{[[ none |- [ x' ] : [] {BigMeet ri} A |> x' : [ A ] {BigMeet ri} ]]} \\
  \inferrule*[right={[}pbox{]},rightskip=3em]{\inferrule*[right={[}pvar{]}]{\quad}{
      [[ {BigMeet ri} |- y' : B |> y' : [ B ] { {BigMeet ri} }]]} \\
    | [[Tup A B ]] | = 1}{[[
    none |- [ y' ] : [] {BigMeet ri} B |> y' : [ B ] {BigMeet ri}  ]]}
}{[[ none |- Pair {[ x' ]} {[ y' ]} : Tup ([] {BigMeet ri} A) ([] {BigMeet ri} B) |> x' : [ A ] {BigMeet ri}, y' : [ B ] {BigMeet ri}  ]]}
\end{equation}
    }

\footnotesize{

}

\footnotesize{
    \begin{equation}
      \label{eq:pull-deriv-sub10}
 \inferrule*[Right=app]{ \inferrule*[right=pull]{\quad}{[[ . |- pullP Sig A : A -o [] {BigMeet ri} A ]]}\\\inferrule*[right=var]{\quad}{[[
          x :
        A [ [] ri ai /* ai ] |- x : A [ [] ri ai /*
        ai ] ]]}}{[[ x :
        A [ [] ri ai /* ai ] |- pull Sig A (x) : [] {BigMeet ri} A ]]}
\end{equation}
}

\footnotesize{
    \begin{equation}
      \label{eq:pull-deriv-sub11}
\inferrule*[Right=app]{\inferrule*[right=pull]{\quad}{ [[ . |- pullP Sig B : B -o [] {BigMeet ri} B]]} \\ \inferrule*[right=var]{\quad}{[[ y : B [ [] ri ai /*
    ai ] |- y : B [ [] ri ai /*
        ai ] ]]}}{[[ y : B [ [] ri ai /* ai ] |-
        pull Sig B (y) : [] {BigMeet ri} B
  ]]}
    \end{equation}
    }

\footnotesize{
\begin{equation}
\label{eq:pull-deriv-sub1}
  \inferrule*[Right=case]
  {\inferrule*[Right=pair,leftskip=15em]{
      \eqref{eq:pull-deriv-sub10}
\\ \eqref{eq:pull-deriv-sub11} }{[[ x : A [ [] ri ai /* ai ] , y : B [ [] ri ai /* ai ]  |-
pair {pull Sig A (x)} {pull Sig B (y)} : Tup ([] {BigMeet ri} A) ([] {BigMeet ri} B) ]]}
\\
  \eqref{eq:pull-deriv-sub2}
\\
  \eqref{eq:pull-deriv-sub3}
  }
  {[[ x : A [ [] ri ai /* ai ] , y : B [ [] ri ai /* ai ] |- case {pair {pull Sig A
    x} {pull Sig B y} } of Pair [ x' ] [
  y' ]
  -> [ pair x' y' ] :  [] {BigMeet ri} { Tup A B} ]]}
\end{equation}
}

{\footnotesize{
\begin{align*}
 \hspace{-7em}\inferrule*[Right=case]
  {
  % elide
  %\inferrule*[Right=var]{\quad}{[[ z : ( Tup A B ) [ [] ri ai /* ai ] |- z : ( Tup A B ) [ [] ri ai /* ai ]  ]]}
  %\\
  \eqref{eq:pull-deriv-sub1}
  \\
  \inferrule*[Right=pcon]
    {\inferrule*[right=pvar,leftskip=5em]
      {\quad}
      {[[ none |- x : A [ [] ri ai /* ai ] |> x : A [ [] ri ai /* ai ] ]]}
  \\ \inferrule*[right=pvar, rightskip=5em]
      {\quad}
      {[[ none |- y : B [ [] ri ai /* ai ] |> y : B [ [] ri ai /* ai ] ]]}
    }{ [[ none |- Pair x y : (Tup A B) [ [] ri ai /* ai ]
            |> x : A [ [] ri ai /* ai ] , y : B [ [] ri ai /* ai ] ]]}
  }{[[ z : ( Tup A B ) [ [] ri ai /* ai ]
       |- case z of Pair x y -> ( case {pair {pull Sig A x} {pull Sig B y} } of
            Pair [ x' ] [ y' ] -> [ pair x' y' ] )
       :  [] {BigMeet ri} { Tup A B} ]]}
\end{align*}
    }}
    %
\item $\deriv{pull}{ [[ mu X . A ]] }^{\Sigma} : [[ ( mu X . A ) [ [] ri ai /*
  ai ] -> [] (BigMeet ri) ( mu X . A ) ]]$
    (i.e. $\tcF\ \overline{\alpha_i} = [[ mu X . A ]]$).

    \footnotesize{
\begin{equation}
\label{eq:pull-deriv-rec-sub1}
      \inferrule*[right=app]{\inferrule*[right=var,leftskip=10em]{\quad}{[[ Sig, f
      : {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) |- f : {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A)]]}
      \\ \inferrule*[right=var,rightskip=10em]{\quad}{[[ Sig, z : {mu X . {A [ [] ri ai /* ai ]}} |- z :
      {mu X . A} [ [] ri ai /* ai ] ]]}}{[[ Sig, f
      : {mu X . A} [ [] ri ai /* ai ]
                                 -o [] {BigMeet ri} (mu X . A), z : {mu X . {A [ [] ri ai /* ai ]}}|- f z :  [] {BigMeet ri} (mu X . A)  ]]}
\end{equation}
    }

{\footnotesize{
    \begin{align*}
      \inferrule*[right=letrec]{ {\inferrule*[right=pull,leftskip=10em]{\quad}{
      [[ Sig |- pull {Sig, recvar {{mu X . {A [ [] ri ai /* ai ]}} -o {[]
      {BigMeet ri} (mu X . A)}}}  A
      nothing : {mu X . {A [ [] ri ai /* ai ]}}
      -o [] {BigMeet ri} (mu X . A) ]]} } \\
      \eqref{eq:pull-deriv-rec-sub1}
  }{[[ Sig, z : (mu X . A) [ ri ai /* ai ] |- letrec f
      = {pull {Sig, recvar {{mu X . {A [ [] ri ai /* ai ]}} -o {[]
      {BigMeet ri} (mu X . A)}}} A nothing} in {f z} : {[] {BigMeet ri} { mu X . A }}
      ]]}
      \end{align*}
}}
\end{itemize}
\end{proof}


\subsection{Inverse Property of the Distributive Laws}
\label{proof:inverse-proofs}

\pushPullInverse*

\begin{proof}
By induction on the syntax of the type $\tcF \overline{\alpha_i}$ which we denote
by $T$ in the following. We first prove a subresult that for
$\deriv{pull}{T}^{\Sigma'}(\deriv{push}{T}^\Sigma \ z) \equiv z$, which by
function extensionality then gives us
$\deriv{pull}{T}^{\Sigma'}(\deriv{push}{T}^\Sigma) \equiv id$,
under the assumption that for all $X$, every $f \in \Sigma(X)$ and $g \in
\Sigma'(X)$ then $g \circ f = id$, in order to apply the recursive argument.
%
\begin{itemize}
\item $T = \mathsf{Unit}$
%
\begin{align*}
\begin{array}{rll}
       & \deriv{pull}{\mathsf{Unit}}^{\Sigma'}(\deriv{push}{\mathsf{Unit}}^\Sigma \ z) & \\
%
\equiv & \deriv{pull}{\mathsf{Unit}}^{\Sigma'}([[ case z of [ () ] -> () ]])
& \{\textit{defn.}\ \deriv{push}{\mathsf{Unit}}^\Sigma \} \\
%
\equiv & [[ case (case z of [ () ] -> () ) of () -> [ () ] ]]
& \{\textit{defn.}\ \deriv{pull}{\mathsf{Unit}}^{\Sigma'}\} \\
%
\equiv & [[ case z of [()] -> case () of () -> [ () ] ]]
& \{\textit{case assoc.}\} \\
%
\equiv & [[ case z of [()] -> [ () ] ]]
& \{\beta_{case}\} \\
%
\equiv & [[ z ]]
& \{\textit{$\eta_{case}$}\}
\end{array}
\end{align*}
%

\item $T = \alpha$
%
\begin{align*}
\begin{array}{rll}
       & \deriv{pull}{\alpha}^{\Sigma'}(\deriv{push}{\alpha}^\Sigma \ z) & \\
%
\equiv & \deriv{pull}{\alpha}^{\Sigma'}([[ z ]])
& \{\textit{defn.}\ \deriv{push}{\alpha}^\Sigma  \} \\
%
\equiv & [[ z ]] & \{\textit{defn.}\ \deriv{pull}{\alpha}^{\Sigma'} \}
\end{array}
\end{align*}

\item $T = X$
%
\begin{align*}
\begin{array}{rll}
       & \deriv{pull}{[[ X ]]}^{\Sigma'}(\deriv{push}{[[ X ]]}^\Sigma \ z) & \\
  %
\equiv & \deriv{pull}{[[ X ]]}^{\Sigma'}(\Sigma ([[ X ]]) z) & \{ \textit{defn.}\  \deriv{push}{[[ X ]]}^\Sigma \} \\
%
\equiv & \Sigma' ([[ X ]]) (\Sigma ([[X]]) z) & \{ \textit{defn.} \  \deriv{pull}{[[ X ]]}^{\Sigma'} \} \\
\equiv & z & \{ \textit{recursion assumption} \}
\end{array}
\end{align*}
\item $T = A \oplus B$:

{\scalebox{0.70}{\begin{minipage}{1\linewidth}
\begin{align*}
\hspace{-7em}\begin{array}{rll}
       & \deriv{pull}{A \oplus B}^{\Sigma'}(\deriv{push}{A \oplus B}^\Sigma \ z) & \\
%
\equiv & \deriv{pull}{A \oplus B}^{\Sigma'}(\derCaseTwoShort{z}{[\mathsf{inl}\ x]}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{[\mathsf{inr}\ y]}
                            {\mathsf{inr}\ \deriv{push}{B}^{\Sigma}[y]})
& \{\textit{defn.}\ \deriv{push}{A \oplus B}^\Sigma  \} \\
%
\equiv &
\derCaseTwoMultiLine{(\derCaseTwoShort{z}{[\mathsf{inl}\ x]}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{[\mathsf{inr}\ y]}
                            {\mathsf{inr}\ \deriv{push}{B}^{\Sigma}[y]})}{\mathsf{inl}\
                                       x}{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ x}{[u]}{[\mathsf{inl}\ u]}}{\mathsf{inr}\ y}
                            {\derCaseOne{\deriv{pull}{B}^{\Sigma'}\
                                       y}{[v]}{[\mathsf{inr}\ v]}}
& \{\textit{defn.}\ \deriv{pull}{A \oplus B}^{\Sigma'} \} \\
%
\equiv &
\derCaseTwo{z}{[\mathsf{inl}\ x]}{\derCaseTwo{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{\mathsf{inl}\
                                       x}{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ x}{[u]}{[\mathsf{inl}\ u]}}{\mathsf{inr}\ y}
                            {\derCaseOne{\deriv{pull}{B}^{\Sigma'}\
                                       y}{[v]}{[\mathsf{inr}\ v]}}}{[\mathsf{inr}\ y]}
                            {\derCaseTwo{\mathsf{inr}\ \deriv{push}{B}^{\Sigma}[y]}{\mathsf{inl}\
                                       x}{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ x}{[u]}{[\mathsf{inl}\ u]}}{\mathsf{inr}\ y}
                            {\derCaseOne{\deriv{pull}{B}^{\Sigma'}\
                                       y}{[v]}{[\mathsf{inr}\ v]}}}
& \{\textit{case assoc.}\} \\
\equiv & \derCaseTwo{z}{[\mathsf{inl}\ x]}
{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ \deriv{push}{A}^{\Sigma}[x]}{[u]}{[\mathsf{inl}\ u]}}
{[\mathsf{inr}\ y]}
{\derCaseOne{\deriv{pull}{B}^{\Sigma'}\ \deriv{push}{B}^{\Sigma}[y]}{[v]}{[\mathsf{inr}\ v]}}
%
& \{\beta_{case} \} \\
%
\equiv & \derCaseTwo{z}{[\mathsf{inl}\ x]}
{\derCaseOne{[x]}{[u]}{[\mathsf{inl}\ u]}}
{[\mathsf{inr}\ y]}
{\derCaseOne{[y]}{[v]}{[\mathsf{inr}\ v]}}
%
& \{\textit{induction}\} \\
%
\equiv & \derCaseTwoShort{z}{[\mathsf{inl}\ x]}
{[\mathsf{inl}\ x]}
{[\mathsf{inr}\ y]}
{[\mathsf{inr}\ y]}
%
& \{\textit{$\beta_{case}$}\} \\
\equiv & [[ z ]]
& \{\textit{$\eta_{case}$}\}
\end{array}
\end{align*}
\end{minipage}
}}

\end{itemize}
%
\item $T = A \otimes B$:

{\scalebox{0.70}{\begin{minipage}{1\linewidth}
\begin{align*}
\hspace{-7em}\begin{array}{rll}
       & \deriv{pull}{A \otimes B}^{\Sigma'}(\deriv{push}{A \otimes B}^\Sigma \ z) & \\
\equiv & \deriv{pull}{A \otimes B}^{\Sigma'} ( \derCaseOne{z}{[(x, y)]}
   {(\deriv{push}{A}^{\Sigma}[x], \deriv{push}{B}^{\Sigma}[y])})
                                                                                & \{\textit{defn.}\ \deriv{push}{A \otimes B}^\Sigma \} \\
\equiv & \derCaseOne{(\derCaseOne{z}{[(x, y)]}
   {(\deriv{push}{A}^{\Sigma}[x], \deriv{push}{B}^{\Sigma}[y])})}{(x, y)}
   \\ & \qquad {\derCaseOne{(\deriv{pull}{A}^{\Sigma'}\ x, \deriv{pull}{B}^{\Sigma'}\ y)}
                {([u], [v])}{[(u, v)]}}
& \{\textit{defn.}\ \deriv{pull}{A \otimes B}^{\Sigma'} \} \\
\equiv & \derCaseOne{z}{[(x,
         y)]}{\derCaseOne{(\deriv{push}{A}^{\Sigma}[x],
         \deriv{push}{B}^{\Sigma}[y])}{(x, y)}{\\ & \hspace{8em}  \derCaseOne{(\deriv{pull}{A}^{\Sigma'}\ x, \deriv{pull}{B}^{\Sigma'}\ y)}
                {([u], [v])}{[(u, v)]}}}
& \{\textit{case assoc.} \} \\
\equiv & \derCaseOne{z}{[(x, y)]}
   {(\derCaseOne{(\deriv{pull}{A}^{\Sigma'}\deriv{push}{A}^{\Sigma}\ [x], \deriv{pull}{B}^{\Sigma'}\deriv{push}{B}^{\Sigma}\ [y])}{([u], [v])}{[(u, v)]})}
& \{\beta_{case}\} \\
\equiv & \derCaseOne{z}{[(x, y)]}
   {(\derCaseOne{([x], [y])}{([u], [v])}{[(u, v)]})}
& \{\textit{induction}\} \\
\equiv & \derCaseOne{z}{[(x, y)]}
   {[(x, y)]}
& \{\textit{$\beta_{case}$}\} \\
\equiv & [[ z ]]
& \{\textit{$\eta_{case}$}\}
\end{array}
\end{align*}
\end{minipage}
}}

\item $T = \mu X . A$:
%

{\scalebox{0.70}{\begin{minipage}{1\linewidth}
\begin{align*}
\hspace{-12em}\begin{array}{rll}
  & \deriv{pull}{\mu X . A}^{\Sigma'}(\deriv{push}{\mu X . A}^{\Sigma}\ z)& \\
  \equiv & \deriv{pull}{\mu X . A}^{\Sigma'}(\derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}{f\ z}) &\{\textit{defn.}\ \deriv{push}{\mu X . A}^{\Sigma} \} \\
  \equiv & \derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}\\ & \qquad \qquad {f' (\derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}{f\ z})} &\{\textit{defn.}\ \deriv{pull}{\mu X . A}^{\Sigma'} \} \\
  \equiv & \derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}\\ & \qquad \qquad {\derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}{f' (f\ z)}} &\{\textit{let dist.}\ \} \\
  \equiv & \derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}\\ & \qquad \qquad {\derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}{f'} ({{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}\ z})} &\{\beta_{letrec} \} \\
  \equiv & \derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }}\\ & \qquad \qquad {\derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }} ({{\deriv{push}{A}^{\Sigma, X \mapsto
           f }}\ z})} &\{\beta_{letrec} \} \\
  \equiv & \derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }}\\ & \qquad \qquad {{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }} ({{\deriv{push}{A}^{\Sigma, X \mapsto
           [[ letrec f = pushP {Sig, X |-> f} A in f ]] }}\ z})} &\{\beta_{letrec} \} \\
  \equiv & {{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto [[ letrec f' = pullP {Sig', X |-> f'} A in f' ]] }} ({{\deriv{push}{A}^{\Sigma, X \mapsto
           [[ letrec f = pushP {Sig, X |-> f} A in f ]] }}\ z})} &\{\beta_{letrec} \} \\
\equiv & z & \{\textit{induction}\}
\end{array}
\end{align*}
\end{minipage}
}}
\\
\end{proof}

\pullPushInverse*

\begin{proof}
By induction on the syntax of the type $\tcF \overline{\alpha_i}$ which we denote
by $T$ in the following. The following proof is for
$\deriv{push}{T}^\Sigma(\deriv{pull}{T}^\Sigma \ z) \equiv z$, which by
function extensionality then gives us
$\deriv{push}{T}^\Sigma(\deriv{pull}{T}^\Sigma) \equiv id$,
under the assumption that for all $X$, every $f \in \Sigma(X)$ and $g \in
\Sigma'(X)$ then $g \circ f = id$, in order to apply the recursive argument.
%
\begin{itemize}
\item $T = 1$
%
\begin{align*}
\begin{array}{rll}
       & \deriv{push}{\mathsf{Unit}}^\Sigma(\deriv{pull}{\mathsf{Unit}}^{\Sigma'} \ z) & \\
%
\equiv & \deriv{push}{\mathsf{Unit}}^{\Sigma}( [[ case z of () -> [ () ] ]] )
& \{\textit{defn.}\ \deriv{pull}{\mathsf{Unit}}^{\Sigma'} \} \\
%
\equiv & [[ case (case z of () -> [ () ]) of [ () ] -> () ]]
& \{\textit{defn.}\ \deriv{push}{1}^{\Sigma} \} \\
\equiv & [[ case z of () -> case [ () ] of [ () ] -> () ]]
& \{\textit{case assoc.} \} \\
%
\equiv &  [[ case z of () -> () ]]
& \{\beta_{case} \} \\
%
\equiv & [[ z ]]
& \{\eta_{case} \}
\end{array}
\end{align*}
\item $T = \alpha$
%
\begin{align*}
\begin{array}{rll}
       & \deriv{push}{\alpha}^\Sigma(\deriv{pull}{\alpha}^{\Sigma'} \ z) & \\
%
\equiv & \deriv{push}{\alpha}^\Sigma([[ z ]])
& \{\textit{defn.}\ \deriv{pull}{\alpha}^{\Sigma'} \} \\
%
\equiv & [[ z ]] & \{\textit{defn.}\ \deriv{push}{\alpha}^\Sigma \}
\end{array}
\end{align*}
%
\item $T = X$
%
\begin{align*}
\begin{array}{rll}
       & \deriv{push}{[[ X ]]}^{\Sigma}(\deriv{pull}{[[ X ]]}^{\Sigma'} \ z) & \\
%
\equiv &  \deriv{push}{[[ X ]]}^{\Sigma}(\Sigma' ([[X]]) z) & \{\textit{defn.}\ \deriv{pull}{[[ X ]]}^{\Sigma'} \}
\\
\equiv & \Sigma ([[ X ]]) (\Sigma' ([[X]]) z) & \{\textit{defn.}\ \deriv{push}{[[ X ]]}^{\Sigma} \} \\
\equiv & z & \{ \textit{recursion assumption}\}
\end{array}
\end{align*}
%
\item $T = A \oplus B$
%

{\scalebox{0.7}{\begin{minipage}{1\linewidth}
\begin{align*}
\hspace{-5em}\begin{array}{rll}
  & \deriv{push}{A \oplus B}^\Sigma(\deriv{pull}{A \oplus B}^{\Sigma'} \ z) & \\
%
\equiv & \deriv{push}{A \oplus B}^\Sigma \derCaseTwo{z}{\mathsf{inl}\
                                       x}{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ x}{[u]}{[\mathsf{inl}\ u]}}{\mathsf{inr}\ y}
                            {\derCaseOne{\deriv{pull}{B}^{\Sigma'}\
                                       y}{[v]}{[\mathsf{inr}\ v]}}
& \{\textit{defn.}\ \deriv{pull}{A \oplus B}^{\Sigma'} \} \\
\equiv & \derCaseTwo{(\derCaseTwo{z}{\mathsf{inl}\
                                       x}{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ x}{[u]}{[\mathsf{inl}\ u]}} {\mathsf{inr}\ y}
                            {\derCaseOne{\deriv{pull}{B}^{\Sigma'}\
                                       y}{[v]}{[\mathsf{inr}\ v]}})}{[\mathsf{inl}\ x]}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{[\mathsf{inr}\ y]}
                            {\mathsf{inr}\
                                      \deriv{push}{B}^{\Sigma}[y]} & \{\textit{defn.}\ \deriv{push}{A \oplus B}^\Sigma\} \\
\equiv & \derCaseTwo{z}{\mathsf{inl}\
                                       x}{\derCaseTwo{\derCaseOne{\deriv{pull}{A}^{\Sigma'}\ x}{[u]}{[\mathsf{inl}\ u]}}{[\mathsf{inl}\ x]}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{[\mathsf{inr}\ y]}
                            {\mathsf{inr}\
                                      \deriv{push}{B}^{\Sigma}[y]}} {\mathsf{inr}\ y}
                            {\derCaseTwo{\derCaseOne{\deriv{pull}{B}^{\Sigma'}\
                                       y}{[v]}{[\mathsf{inr}\ v]}}{[\mathsf{inl}\ x]}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{[\mathsf{inr}\ y]}
                            {\mathsf{inr}\
                                      \deriv{push}{B}^{\Sigma}[y]}} & \{\textit{case assoc.}\} \\
\equiv & \derCaseTwo{z}{\mathsf{inl}\ x}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}\deriv{pull}{A}^{\Sigma'}\ x}{\mathsf{inr}\ y}{\mathsf{inr}\ \deriv{push}{B}^{\Sigma}\deriv{pull}{B}^{\Sigma'}\ y}
 & \{\beta_{case}\} \\
\equiv & \derCaseTwo{z}{\mathsf{inl}\ x}{\mathsf{inl}\ x}{\mathsf{inr}\ y}{\mathsf{inr}\ y}
                                                                            & \{\textit{induction}\} \\
 \equiv & z  & \{\eta_{case}\}
\end{array}
\end{align*}
\end{minipage}}}

%
\item $T = A \otimes B$

{\scalebox{0.7}{\begin{minipage}{1\linewidth}
\begin{align*}
  \hspace{-7em}\begin{array}{rll}
    & \deriv{push}{A \otimes B}^{\Sigma}(\deriv{pull}{A \otimes B}^{\Sigma'}\ z) & \\
    \equiv & \deriv{push}{A \otimes B}^{\Sigma}(\derCaseOne{z}{(x, y)}
   {\derCaseOne{(\deriv{pull}{A}^{\Sigma'}\ x, \deriv{pull}{B}^{\Sigma'}\ y)}
                {([u], [v])}{[(u, v)]}})
& \{\textit{defn.}\ \deriv{pull}{A \otimes B}^{\Sigma'} \} \\
\equiv & \derCaseOne{(\derCaseOne{z}{(x, y)}
   \\ & \qquad {\derCaseOne{(\deriv{pull}{A}^{\Sigma'}\ x, \deriv{pull}{B}^{\Sigma'}\ y)}
                {([u], [v])}{[(u, v)]}})}{[(x, y)]}
   {(\deriv{push}{A}^{\Sigma}[x], \deriv{push}{B}^{\Sigma}[y])}
& \{\textit{defn.}\ \deriv{push}{A \otimes B}^{\Sigma}\} \\
\equiv & \derCaseOne{z}{(x, y)}
   \\ & \qquad {\derCaseOne{(\deriv{pull}{A}^{\Sigma'}\ x, \deriv{pull}{B}^{\Sigma'}\ y)}
                {([u], [v])}{\derCaseOne{[(u, v)]}{{[(x, y)]}}{(\deriv{push}{A}^{\Sigma}[x], \deriv{push}{B}^{\Sigma}[y])}}}
& \{\textit{case assoc.}\} \\
\equiv & \derCaseOne{z}{(x, y)}
   (\deriv{push}{A}^{\Sigma}\deriv{pull}{A}^{\Sigma'}\ x, \deriv{push}{B}^{\Sigma}\deriv{pull}{B}^{\Sigma'}\ y)
& \{\beta_{case}\} \\
\equiv & \derCaseOne{z}{(x, y)}{(x, y)}
& \{\textit{induction}\} \\
\equiv & z
& \{\eta_{case}\}
  \end{array}
\end{align*}
\end{minipage}
}}

%
\item $T = \mu X . A$
%

{\scalebox{0.7}{\begin{minipage}{1\linewidth}
\begin{align*}
  \hspace{-12em}\begin{array}{rll}
  & \deriv{push}{\mu X . A}^{\Sigma}(\deriv{pull}{\mu X . A}^{\Sigma'}\ z)& \\
  \equiv & \deriv{push}{\mu X . A}^{\Sigma}(\derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}{f'\ z}) &\{\textit{defn.}\ \deriv{pull}{\mu X . A}^{\Sigma'} \} \\
  \equiv & \derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}\\ & \qquad \qquad {f\  (\derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}{f'\ z})} &\{\textit{defn.}\ \deriv{push}{\mu X . A}^{\Sigma} \} \\
  \equiv & \derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}\\ & \qquad \qquad {\derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}{f\ (f'\ z)}} &\{\textit{let dist.}\  \} \\
  \equiv & \derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}\\ & \qquad \qquad {\derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}{f\ ({\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }}\ z)}} &\{\beta_{letrec} \} \\
  \equiv & \derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}\\ & \qquad \qquad {\derLetRec{f'}{\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }\ ({\deriv{pull}{A}^{\Sigma',
                                 X \mapsto f' }}\ z)}} &\{\beta_{letrec} \} \\
  \equiv & \derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}\\ & \qquad \qquad {{\deriv{push}{A}^{\Sigma, X \mapsto
           f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }\ ({\deriv{pull}{A}^{\Sigma',
                                 X \mapsto [[ letrec f' = pullP {Sig', X |-> f'} A in f']] }}\ z)}} &\{\beta_{letrec} \} \\
  \equiv & {\deriv{push}{A}^{\Sigma, X \mapsto {[[ letrec f = pushP {Sig, X |-> f} A in f ]] }}\ ({\deriv{pull}{A}^{\Sigma',
                                 X \mapsto [[ letrec f' = pullP {Sig', X |-> f'} A in f' ]]}}\ z)} &\{\beta_{letrec} \} \\
\equiv & z & \{\textit{induction}\}
  \end{array}
\end{align*}
\end{minipage}
}}
\end{itemize}
\end{proof}



\section{Proofs for the Fully Graded Synthesis Calculus}
This section contains the soundness proof for the fully graded 
synthesis calculus presented in Chapter~\ref{chapter:extended}, as well 
as the proof of soundness for focusing this calculus.

\subsection{Soundness of the Fully Graded Synthesis Calculus}
\label{proofs:graded-base-soundness}

\synthSound*
\begin{proof}
Induction on the synthesis rules. We consider the cases of the lemma in order, first proving soundness for 
synthesis of open terms from types, followed by soundness of synthesis for closed term from type schemes.
\begin{enumerate}
\item \begin{enumerate}
\item Case $\textsc{Var}$ \\
        For synthesis of a variable term, we have the derivation:
        \begin{align*}
          \synVarP
        \end{align*}
        From the premise, we have that: 
        \begin{align*}
          [[ Sig |- A : Type ]]
        \end{align*}
        from which we can construct the following typing derivation, matching the above conclusion:
        \begin{align*}
          \tyVarP
        \end{align*}
\item Case $\textsc{Def}$ \\
        For synthesis of a top-level definition usage, we have the derivation:
        \begin{align*}
          \synDefP
        \end{align*}
        From the premise, we have that: 
        \begin{align*}
          [[ Sig |- inst A A' ]]
        \end{align*}
        from which we can construct the following typing derivation, matching the above conclusion:
        \begin{align*}
          \tyDefP
        \end{align*}
\item Case $\rightarrow_{\textsc{R}}$\\
        For synthesis of an abstraction term, we have the derivation:
        \begin{align*}
          \synAbsP
        \end{align*}
        By induction on the premise, we have:
        \begin{align*}
          [[  Sig; D, x : [ A ] r |- t : B ]] \tag{ih}
        \end{align*}
        and that:
        \begin{align*}
          [[ r <<= q ]]
        \end{align*}
        from which we can construct the following typing derivation, matching the conclusion:
        \begin{align*}
          \inferrule*[Right=Abs]
            {\inferrule*[Right=Approx]{[[  Sig ; D, x : [A] r |- t : B ]] \\ [[ r <<= q ]]}{[[  Sig; D, x : [ A ] q |- t : B ]]}}
            {[[  Sig ; D |- \ x ^ q . t  : A ^ q -> B ]]}
        \end{align*}
\item Case $\rightarrow_{\textsc{L}}$\\
        For synthesising an application, we have the derivation:
        \begin{align*}
          \hspace{-5em}\synAppP
        \end{align*}
        By induction on the premises, we obtain the following typing judgements:
        \begin{align*}
          [[  Sig; D1, x1 : [ A ^ q -> B ] s1, x2 : [ B ] s2 |- t1 : C  ]] \tag{ih} \\ 
          [[  Sig; D2, x1 : [ A ^ q -> B ] s3 |- t2 : A  ]] \tag{ih}
        \end{align*}
        and from the premises, we have that: 
        \begin{align*}
          [[ Sig |- {A ^q -> B} : Type ]]
        \end{align*}
        from which we can construct the following derivation, making use of the admissibility of substitution:
        \begin{equation}
          \label{soundAppSub1}
          \inferrule*[Right=App, leftskip=4em]{
            \inferrule*[Right=Var, leftskip=4em]
              {[[ Sig |- {A ^q -> B} : Type ]]}
              {[[  Sig; x1 : [ A ^ q -> B ] 1 |- x1 : A ^ q -> B ]]} \\ [[  Sig; D2, x1 : [A ^ q -> B] s3 |- t2 : A]]}{ [[  Sig; {q * D2}, x1 : [ A ^ q -> B ] {1 + (q * s3)} |-  x1 t2 : B ]]}
        \end{equation}

        \begin{align*}
          \inferrule*[Right=Subst]{
          \eqref{soundAppSub1} \\ [[  Sig ; D1, x1 : [ A ^ q -> B ] s1, x2 : [ B ] s2 |- t1 : C ]]}
          {[[  Sig; (D1 + s2 * {q * D2}), x1 : [ A ^ q -> B ] {s2 + {s1 + (s2 * {q * s3})}} |- {[ ( x1 t2 ) / x2 ] t1} : C  ]]}
        \end{align*}
        making use of the distributivity property of semirings, along with unitality of $1$
        and commutativity of $+$, such that
        $[[ s1 + s2 * (1 + (q * s3)) ]] =  [[ s1 + (s2 * 1) + (s2 * q * s3) ]] = [[  s2 + s1 + (s2 * q * s3) ]]$.

\item Case $\textsc{C}_{\textsc{R}}$\\
        For synthesising a constructor introduction, we have the derivation:
        \begin{align*}
          \synConP
        \end{align*}
        By induction on the premises, we obtain the following typing judgements:
        \begin{align*}
          [[  Sig; D1 |- t1 : B1 ]] \quad , ..., \quad [[  Sig; Dn |- tn : Bn ]] \tag{ih}
        \end{align*}
        from which we can construct the following derivation, matching the above conclusion:
% 
\begin{equation}
  \label{soundConRSub1}
\inferrule*[Right=Con]
                  {[[ ( Con Forall : B'1 - q1 .*. B'n - qn -> {K {A' Many}} ) elem Defines]] \\\\ [[ Sig |- inst {B1 - q1 .*. Bn - qn -> {K {A Many}}} {B'1 - q1 .*. B'n - qn -> {K {A' Many}}}  ]]  }
                  {[[  Sig; 0 * G |- Con . : B1 - q1 .*. Bn - qn -> {K {A Many}}  ]]}
\end{equation}

\begin{equation}
          \label{soundConRSub2}
            \inferrule*[Right=App]
              {\inferrule*[right=App, vdots=1em]
                {\eqref{soundConRSub1} \\  [[  Sig; D1 |- t1 : B1 ]]}
                {{[[  Sig; {0 * G} + q1 * D1 |- Con t1 : {B2 - q2 .*. Bn - qn -> { K {A Many} } } ]]}}}
              {[[  Sig; {0 * G} + q1 * D1 + ... + qn-1 * Dn-1 |-  Con t1 ... tn-1 : Bn ^ qn -> { K {A Many} } ]]} 
\end{equation}
        \begin{align*}
          \inferrule*[Right=App]
              { \eqref{soundConRSub2} \\ [[  Sig; Dn |- tn : Bn ]]}
            {  \Sigma ; [[ {0 * G} + q1 * D1 ]]+ ...+  [[ qn * Dn |- Con t1 ... tn :  K { A Many } ]]}
        \end{align*}

\item Case $\textsc{C}_{\textsc{L}}$ \\
        For synthesising a case statement, we have the derivation:
        \begin{align*}
          \hspace{-10em}\synCaseP
        \end{align*}
        By induction on the premises we obtain the following typing judgements:
        \begin{align*}
          [[  Sig; {{Di, x : [K {A Many}] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {s Vari Varn} |- ti : B ]] \tag{ih}
        \end{align*}
        % By monotonicty of $\sqcup$ we have that $ [[ {Vari s} <<= {{Var1 s} \*/ {Varn s}}  ]]$
        % and by $*_{1}$ that $[[ assn {Vari s} {{s Vari Var1} \*/ {s Vari Varn}} ]]$. Therefore, by monotonicty of $\sqcup$
        % we have that $[[ {s Vari Varj} <<= {{Var1 s} \*/ {Varn s}} ]]$
        % from which we can construct the following
        % derivation, matching the above conclusion:
        We have by the definition of $\sqcup$:
        %
        \begin{enumerate}
                \item $ [[ Di]] \sqsubseteq [[(D1 ++*+ Dm) ]]$
                \item $ [[ {Vari r} <<= {{Var1 r} \*/ {Varm r}}  ]]$
                % \item $[[ assn {Vari s} {{s Vari Var1} \*/ {s Vari Varn}} ]]$
                % \item $[[ {s Vari Varj} <<= {{Var1 s} \*/ {Varn s}} ]]$
        \end{enumerate}

        and from the premises of the synthesis rule:
        \begin{enumerate}[resume]
                \item $[[ {s' Vari Varj} <<= {{Var1 s} \*/ {Varm s}} ]]$
                \item $ [[ {s Vari Varj} <<= {s' Vari Varj } * {q Vari Varj} ]]$
                \item $ [[ {PolyConSimple {K A} {{Var1 s} \*/ {Varm s}}} ]] $
                \item $ [[ Sig |- {K {A Many}} : Type ]]$ 
        \end{enumerate}
        and from rule $\kappa_\rightarrow$ we have that 
        \begin{align*}
           [[ Sig |- {K {A Many}} : Type ]] \Rightarrow {B_1}^{q^i_1} \rightarrow ... \rightarrow {B_n}^{q^i_n} \rightarrow [[ {K {A Many}} ]] : [[ Type ]]
        \end{align*}
        thus we have that 
        \begin{enumerate}[resume]
          \item $[[ Sig |- Bj : Type ]]$
        \end{enumerate}
        We then construct the following three derivations towards the goal:
        \begin{equation}
          \label{soundConLSub3}
          \inferrule*[Right=PVar]
              {(g)}
              { [[  Sig; {q Vari Varj} * {{Var1 s} \*/ {Varm s}} |- Special y : Bj |> {y Vari Varj} : [Bj] {q Vari Varj} * {{Var1 s} \*/ {Varm s}} ]] }
        \end{equation}
        %
        \begin{equation}
          \label{soundConLSub1}
          \inferrule*[Right=PCon]
            {  [[ ( Con Forall : B'1 - q1 .*. B'n - qn -> {K {A' Many}} ) elem Defines ]] \\\\ [[ Sig |- inst {B1 - q1 .*. Bn - qn -> {K {A Many}}} {B'1 - q1 .*. B'n - qn -> {K {A' Many}}} ]] \\\\  \eqref{soundConLSub3} \\  (e) }
            {[[  Sig; {{Var1 s} \*/ {Varm s}} |- Coni Var1 Varn Vari y y   : K {A Many} |> {y Vari Varj} : [ Bj ] {q Vari Varj} * {{Var1 s} \*/ {Varm s}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s} \*/ {Varm s}}  ]]}\\
        \end{equation}
        and
        \begin{equation}
          \label{soundConLSub2}
          \hspace{-7em}
          \inferrule*[Right=Approx, rightskip=5em]
            {\inferrule*[Right=Approx]
              {\inferrule*[Right=induction]
                {\quad}
                {[[  Sig; {{Di, x : [K {A Many}] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {s Vari Varn} |- ti : B ]]} \qquad \\ (d) }
                {\inferrule*[Right=Approx]
                  { [[  Sig; { Di, x : [ {K {A Many}} ] {Vari r}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {s' Vari Varj}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {s' Vari Varj} |- ti : B  ]] \qquad (c)}
                  {\inferrule*[Right=Approx, leftskip=3em]
                    { [[  Sig; { Di, x : [ {K {A Many}} ] {Vari r}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s} \*/ {Varm s}}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s} \*/ {Varm s}} |- ti : B  ]] \qquad (b)}
                    {[[  Sig; { Di, x : [ {K {A Many}} ] {({Var1 r} \*/ {Varm r})}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s} \*/ {Varm s}}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s} \*/ {Varm s}} |- ti : B  ]] \qquad (a)} }}}{ [[  Sig; { (D1 ++*+ Dm), x : [ {K {A Many}} ] {({Var1 r} \*/ {Varm r})}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s} \*/ {Varm s}}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s} \*/ {Varm s}} |- ti : B  ]] \\}
        \end{equation}


        \begin{align*}
          \hspace{-10em}\inferrule*[Right=Case]{ \inferrule*[Right=Var,leftskip=5em]{(f)}{[[  Sig; x : [ {K {A Many}} ] 1 |- x : {K A} ]]} \quad \\ \eqref{soundConLSub1} \\ \eqref{soundConLSub2} }
          { \inferrule*[Right=$\equiv$] {[[  Sig; ((D1 ++*+ Dm), {x : [ {K {A Many}} ] {({Var1 r} \*/ {Varm r})}}) + x : [{K {A Many}}] {({{Var1 s} \*/ {Varm s}} * 1)} |- case x of Coni Var1 Varn Vari y y -*> ti : B ]]} {[[  Sig ;(D1 ++*+ Dm), {x : [ {K {A Many}} ] {({Var1 r} \*/ {Varm r})} + {({{Var1 s} \*/ {Varm s}})}} |- case x of Coni Var1 Varn Vari y y -*> ti : B ]]}}
        \end{align*}



% \item Case $\textsc{Con}_{L}$ \\
%         For synthesising a case statement, we have the derivation:
%         \begin{align*}
%           \synCaseAltAlt
%         \end{align*}
%         By induction on the premises we obtain the following typing judgements:
%         \begin{align*}
%           [[ {{Di, x : [K A] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {s Vari Varn} |- ti : B ]]
%         \end{align*}
%         % By monotonicty of $\sqcup$ we have that $ [[ {Vari s} <<= {{Var1 s} \*/ {Varn s}}  ]]$
%         % and by $*_{1}$ that $[[ assn {Vari s} {{s Vari Var1} \*/ {s Vari Varn}} ]]$. Therefore, by monotonicty of $\sqcup$
%         % we have that $[[ {s Vari Varj} <<= {{Var1 s} \*/ {Varn s}} ]]$
%         % from which we can construct the following
%         % derivation, matching the above conclusion:
%         We have:

%         \begin{enumerate}
%                 \item $ [[ Di]] \sqsubseteq [[(D1 ++*+ Dn) ]]$
%                 \item $ [[ {Vari r} <<= {{Var1 r} \*/ {Varn r}}  ]]$
%                 % \item $[[ assn {Vari s} {{s Vari Var1} \*/ {s Vari Varn}} ]]$
%                 % \item $[[ {s Vari Varj} <<= {{Var1 s} \*/ {Varn s}} ]]$
%                 \item $[[ {Vari s'} <<= {{Var1 s'} \*/ {Varn s'}} ]]$
%                 \item $ [[ {Vari s} <<= {Vari s'} * {q Vari Varj} ]]$
%                 \item $[[ {s Vari Varj} <<= {Vari s} ]]$
%         \end{enumerate}
%         \begin{equation}
%           \label{soundConLAltSub1}
%           \inferrule*[Right=PCon]{\inferrule*[Right=PVar]{\quad}{ [[  {q Vari Varj} * {{Var1 s'} \*/ {Varn s'}} |- Special y : Bj |> {y Vari Varj} : [Bj] {q Vari Varj} * {{Var1 s'} \*/ {Varn s'}} ]]  }}{[[ {{Var1 s'} \*/ {Varn s'}} |- Coni Var1 Varn Vari y y   : K A |> {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s'} \*/ {Varn s'}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s'} \*/ {Varn s'}}  ]]}\\
%         \end{equation}

%         \begin{equation}
%           \label{soundConLAltSub2}
%           \inferrule*[Right=Approx, rightskip=5em]{ \inferrule*[Right=Approx]{ [[ {{Di, x : [K A] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {s Vari Varn} |- ti : B ]] \\ (e)}{\inferrule*[Right=Approx]{[[ {{Di, x : [K A] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {Vari s} |- ti : B ]] \\ (e)}{\inferrule*[Right=Approx]{[[ { Di, x : [ {K A} ] {Vari r}, {y Vari Var1} : [ B1 ] {Vari s}} , .M. , {y Vari Varn} : [ Bn ]  {Vari s } |- ti : B  ]]  \\ (d)  }{\inferrule*[Right=Approx]{ [[ { Di, x : [ {K A} ] {Vari r}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {Vari s'}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {Vari s' } |- ti : B  ]] \\ (c)}{\inferrule*[Right=Approx]{ [[ { Di, x : [ {K A} ] {Vari r}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s} \*/ {Varn s}}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s'} \*/ {Varn s'}} |- ti : B  ]] \\ (b)}{[[ { Di, x : [ {K A} ] {({Var1 r} \*/ {Varn r})}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s'} \*/ {Varn s'}}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s'} \*/ {Varn s'}} |- ti : B  ]] \\ (a)} }}}}}{ [[ { (D1 ++*+ Dn), x : [ {K A} ] {({Var1 r} \*/ {Varn r})}, {y Vari Var1} : [ B1 ] {q Vari Var1} * {{Var1 s'} \*/ {Varn s'}}} , .M. , {y Vari Varn} : [ Bn ] {q Vari Varn} * {{Var1 s'} \*/ {Varn s'}} |- ti : B  ]] }
%         \end{equation}


%         \begin{align*}
%           \inferrule*[Right=Case]{ \inferrule*[Right=Var,leftskip=5em]{\quad}{[[ x : [ {K A} ] 1 |- x : {K A} ]]} \\ \eqref{soundConLAltSub1} \\ \eqref{soundConLAltSub2} }
%           {[[ (D1 ++*+ Dn), {x : [ {K A} ] {({Var1 r} \*/ {Varn r})} + {({{Var1 s'} \*/ {Varn s'}} * 1)}} |- case x of Coni Var1 Varn Vari y y -*> ti : B ]]}
        % \end{align*}

\item Case $\Box_{\textsc{R}}$ \\
        For synthesising a promotion, we have the derivation:
        \begin{align*}
          \synBoxP
        \end{align*}
        By induction on the premise we have:
        \begin{align*}
          [[  Sig; D |- t : A ]]
        \end{align*}
        From which we can construct the following derivation, matching the above conclusion:
        \begin{align*}
          \inferrule*[Right=Pr]{[[  Sig; D |- t : A ]]}{ [[ r * D |- [ t ] : [] r  A ]]}
        \end{align*}
  \item Case $\Box_{\textsc{L}}$ \\
        For synthesising an unboxing, we have the derivation:
        \begin{align*}
          \synUnboxP
        \end{align*}
        By induction on the premise we have:
        \begin{align*}
          [[  Sig; {D, y : [A] s1}, x : [ [] q A ] s2 |- t : B ]] \tag{ih}
        \end{align*}
        and from the premises we have that:
        \begin{enumerate}[resume]
          \item $[[ s1 <<= {s3 * q} ]]$
          \item $[[ Sig |- {[] q A} : Type ]]$
        \end{enumerate}
        and through the $\kappa_\Box$ rule, we have that: 
        \begin{align*}
          [[ Sig |- {[] q A} : Type ]] \Rightarrow [[ Sig |- A : Type]]
        \end{align*}       
        From this we can construct the following derivation, towards the goal:
        \begin{equation}
          \label{soundBoxLSub1}
            \inferrule*[Right=Var]{(i)}{[[  Sig; x : [ [] q A ] 1 |- x : [] q A ]]}  
        \end{equation}
        \begin{align*}
          \inferrule*[Right=Case]{ \inferrule*[Right=PBox, leftskip=1.5em]{\inferrule*[Right=PVar]{[[Sig |- A : Type ]]}{[[  Sig; s3 * q |- y : A |> y : [A] {s3 * q} ]]}}{[[  Sig; s3 |- [ y ] : [] q A |> y : [A] {s3 * q}  ]]}  \\ \eqref{soundBoxLSub1} \\ \inferrule*[Right=Approx, rightskip=0.5em] {[[  Sig; D, y : [A ] s1, x : [ [] q A ] s2 |- t : B ]] \\ [[ s1 <<= {s3 * q} ]]} { [[  Sig ; D, y : [A ] {s3 * q}, x : [ [] q A ] s2 |- t : B ]]} }{[[  Sig; D, x : [ [] q A ] {s3 + s2} |- case x of [ y ] -> t : B  ]]}
        \end{align*}
  \item Case $\mu{\textsc{R}}$ \\
        For synthesising a recursive data type introduction form, we have the derivation:
        \begin{align*}
          \synMuRP
        \end{align*}
        By induction on the premise we have:
        \begin{align*}
          % {\Gamma \vdash [[ A ]] [ \mu X . A / X] \Rightarrow t \mid\ \Delta}
          { D; \Sigma; \Delta \vdash t : [[ A ]] [ \mu X . A / X] } \tag{ih}
        \end{align*}
        from which we can construct the derivation, matching the form of the lemma, leveraging the equirecursivity of our types:
        \begin{align*}
          \inferrule*[right=$\mu_1$]{D ; \Sigma; \Delta \vdash t : [[ A ]] [ \mu X . A / X] }
          {D ; \Sigma ; \Delta \vdash t :  \mu X . A  }
        \end{align*}
  \item Case $\mu{\textsc{L}}$ \\
        For synthesising a recursive data type elimination form, we have the derivation:
        \begin{align*}
          \synMuLP
        \end{align*}
        By induction on the premise we have:
        \begin{align*}
          {D ; \Sigma ; [[D]], x :_r [[ A]] [\mu X . [[ A ]] / X ] \vdash [[ t ]] : [[ B ]] } \tag{ih}
        \end{align*}
        from which we can construct the derivation:
        \begin{align*}
          \inferrule*[right=$\mu_2$]
            {\inferrule*[right=\textsc{Var}]
            {[[ Sig ]] \vdash \mu X . A :  \text{Type} } 
            {D ; \Sigma ; x :_r \mu X . [[ A ]] \vdash x :_1 \mu X . A }}
            { D ; \Sigma ; x :_r \mu X . [[ A ]] \vdash x :_1 A [\mu X . A] }
        \end{align*}
        and by using lemma \ref{lemma:substitution} on :
        \begin{align*}
            D ; \Sigma ; x : A [ \mu X . A / X ] \vdash [[ t ]] : B
        \end{align*}
        we obtain the following, matching the above conclusion:
        \begin{align*}
            D ; \Sigma ; D, x : \mu X . A \vdash [x/x] t : B = D ; \Sigma ; D, x : \mu X . A \vdash t : B
        \end{align*}
        % \begin{align*}
        %   \inferrule*[right=$\mu_2$]{ D ; \Sigma ; [[D]], x :_r [[ A]] [\mu X . [[ A ]] / X ] \vdash [[ t ]] : [[ B ]] }
        %   { D ; \Sigma; [[ D ]], x :_r \mu X . [[ A ]] \vdash [[ t ]] : [[ B ]] } 
        % \end{align*}
        
\end{enumerate}
\item 
  \begin{enumerate}
  \item Case $\textsc{TopLevel}$ \\
        For the top-level of synthesis, we have the derivation:
        \begin{align*}
          \synTopP
        \end{align*}
        from induction on the premise, we have that:
        \begin{align*}
          [[ alpha : k ; .  |- t : A  ]] \tag{ih}
        \end{align*}
        from which we can construct the following typing derivation, matching the above conclusion:
        \begin{align*}
          \inferrule*[right=\GRANULEdruleTyTopLevelPName{}]
            {[[  alpha : k ; . |- t : A ]]}
            {[[ . ; . |- t : Forall alpha : k . A ]]}
        \end{align*}
      \end{enumerate}
    \end{enumerate}


\end{proof}

% \focusSynthSound*
% \begin{proof}

% \end{proof}
\subsection{Soundness of Focusing for the Fully Graded Synthesis Calculus}
\label{proof:focus-graded-sound}
\gradedBaseFocusingSoundness*
% \begin{restatable}[Soundness of focusing for graded-base synthesis]{lemma}{gradedBaseFocusingSoundness}
%   For all contexts $[[ G ]]$, $[[ O ]]$ and types $[[ A ]]$
%   then:
%   \begin{align*}
%   \begin{array}{lll}
%    1.\ TopLevel: & \emptyset ; \emptyset ; \emptyset \vdash [[ Forall alpha : k . A ]] \Rightarrow [[ t ]] \mid \emptyset \quad &\implies \quad  \emptyset ; \emptyset \vdash [[ Forall alpha : k . A ]] \Rightarrow [[ t ]] \mid \emptyset\\
%    1.\ Right\ Async: & [[ Sig ]] ; [[ G ; O |- A async => t ; D ]] \quad &\implies \quad [[ Sig ; G ,, O |- A =>+ t ; D ]]\\
%    2.\ Left\ Async: & [[ Sig ]] ; [[ G ; O async |- B => t ; D ]] \quad &\implies \quad [[  Sig ; G ,, O |- B =>+ t ; D ]]\\
%    3.\ Right\ Sync: & [[ Sig ]] ; [[ G ]] ; \emptyset \vdash [[ A ]] \Downarrow\ \ \Rightarrow [[ t ]] \mid\  [[ D ]] \quad &\implies \quad [[  Sig ; G |- A =>+ t ; D ]]\\
%    4.\ Left\ Sync: & [[ Sig ]] ; [[ G ; {x : [A] r} sync |- B => t ; D ]] \quad &\implies \quad [[ Sig; G, x : [ A] r |- B =>+ t ; D ]]\\
%    5.\ Focus\ Right: &  [[ Sig ]] ; [[ G ]] ; \emptyset \vdash [[ B]] \Rightarrow [[ t]] \mid\ [[ D ]] \quad &\implies \quad [[ Sig ; G |- B =>+ t ; D ]]\\
%    6.\ Focus\ Left: & [[ Sig ]]  ; [[ G, x : [A] r ]] ; \emptyset \vdash [[ B]] \Rightarrow [[t ]] \mid\ [[ D ]] \quad &\implies \quad [[ Sig; G, x : [A ] r |- B =>+ t ; D ]]
%   \end{array}
%   \end{align*}
%   \end{restatable}
  \begin{proof}
  \begin{enumerate}
  \item Case: 1. TopLevel: \\
    \begin{enumerate}
        \item Case $\textsc{TopLevel}$\\
            In the case of the right asynchronous rule for abstraction introduction, the synthesis rule has the form:
            \[
              \fsynTopP
            \]
            By induction on the first premise, we have that:
            \[
              [[ alpha : k; . |- A =>+ t ; . ]]   \tag{ih}
            \]
            from case 1 of the lemma. From which, we can construct the following instantiation of the $\textsc{TopLevel}$ synthesis rule in the non-focusing calculus:
            \[
      \inferrule*[right=$\textsc{TopLevel}$]
      {[[ alpha : k ; . |- A =>+ t ; . ]]}{[[ . ; . |- Forall alpha : k . A =>+ t ; . ]]}
            \]
    \end{enumerate}
  \item Case: 2. Right Async: \\
      \begin{enumerate}
        \item Case $\rightarrow_{\textsc{R}}$\\
            In the case of the right asynchronous rule for abstraction introduction, the synthesis rule has the form:
            \[
              \fsynAbsP
            \]
            By induction on the premise, we have that:
            \[
              [[ Sig; (G , O), x : [ A] q |- B =>+ t ; D, x : [A ] r]]   \tag{ih}
            \]
            from case 2 of the lemma. From which, we can construct the following instantiation of the $\rightarrow_{\textsc{R}}$ synthesis rule in the non-focusing calculus:
            \[
      \inferrule*[right=$\rightarrow_{\textsc{R}}$]
      {[[ Sig; (G , O), x : [ A ] q |- B =>+ t ; D, x : [A] r && r <<= q ]]}{[[  Sig ; G , O |- A -> B =>+ \x ^ q . t ; D]]}
            \]
            \item Case \fsynRAsyncTransName\ \\
            In the case of the right asynchronous rule for transition to a left asynchronous judgement, the synthesis rule has the form:
            \[
              \fsynRAsyncTransP
            \]
            By induction on the first premise, we have that:
            \[
              [[  Sig; G , O |- B =>+ t ; D ]] \tag{ih}
            \]
            from case 3 of the lemma.
      \end{enumerate}
  \item Case 3. Left Async: \\
      \begin{enumerate}
        \item Case $\textsc{Con}_{\textsc{L}}$\\
          In the case of the left asynchronous rule for constructor elimination, the synthesis rule has the form:
              \[
              \fsynCaseP
              \]
              By induction on the second premise, we have that:
              \[
  [[ Sig; {(G, O) , {{{x : [K {A Many}] {r}}, {y Vari Var1} : [B1] {r * {q Vari Var1}} } , .M. , {y Vari Varn} : [Bn] {r * {q Vari Var1}}}} async |- B =>+ ti ; {{Di, x : [K {A Many}] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {s Vari Varn} ]] \tag{ih}
              \]
              from case 3 of the lemma. From the second premise, we have that:
              \[
                [[ Sig |- {K {A Many}} : Type ]]
                \] 
              From which we can construct the following instantiation of the $\textsc{Con}_{\textsc{L}}$ rule in the non-focusing calculus:
              \begin{align*}
              \hspace{-10em}\inferrule*[right=$\textsc{Con}_{\textsc{L}}$]
              {
              [[ ( Coni Forall : B'1 -* q1 .*. B'n -* qn -> {K {A' Many}} ) elem Defines ]]\\ [[  Sig |- {K {A Many}} : Type ]] \\\\
              [[  Sig |- inst {B1 - q1 .*. Bn - qn -> {K {A Many}}} {B'1 - q1 .*. B'n - qn -> {K {A' Many}}}  ]] \\\\
              [[  Sig ; { {(G, O), x : [K {A Many}] {r}}, {y Vari Var1} : [B1] {r * {q Vari Var1}} } , .M. , {y Vari Varn} : [Bn] {r * {q Vari Var1}} |- B =>+ ti ; {{Di, x : [K {A Many}] {ri}}, {y Vari Var1} : [B1] {s Vari Var1} } , .M. , {y Vari Varn} : [Bn] {s Vari Varn}]]\\\\
              [[ exists {s' Vari Varj} . {s Vari Varj} <= {s' Vari Varj} * {q Vari Varj} <= r * {q Vari Varj} ]]\\
              [[ assn {Vari s} {{s' Vari Var1} \*/ {s' Vari Varn}} ]]\\ [[ {PolyConSimple {K {A Many}} {{Var1 s} \*/ {Varm s}}} ]]
              }
              {[[ Sig ; (G, O), x : [ {K {A Many}} ] r |- B =>+ case x of Coni Var1 Varn Vari y y -*> ti ; (D1 ++*+ Dm), {x : [ {K {A Many}} ] {({Var1 r} \*/ {Varm r})} + {({Var1 s} \*/ {Varm s})}}]]
              }
              \end{align*}
  
  
        \item Case $\Box_{\textsc{L}}$ \\
              In the case of the left asynchronous rule for graded modality elimination, the synthesis rule has the form:
              \[
              \fsynUnboxP
              \]
              By induction on the first premise, we have that:
              \[
              [[ Sig; {{(G, O), y : [ A ] { r * q }}, x : [ [] q A ] r} |- B =>+ t ; D, y : [ A ] { s1 } , x : [ [] q A ] s2 ]] \tag{ih}
              \]
              from case 3 of the lemma. 
              From the third premise, we have that:
              \[
                [[ Sig |- {[] q A} : Type ]]
                \]           
              From which, we can construct the following instantiation of the $\Box_{\textsc{L}}$ synthesis rule in the non focusing calculus:
              \[
              \inferrule*[right=$\Box_{\textsc{L}}$]
              {
              [[ Sig;  {{(G, O), y : [ A ] { r * q }}, x : [ [] q A ] r} |- B =>+ t ; D, y : [ A ] { s1 } , x : [ [] q A ] s2 ]] \\
              [[ exists s3 . s1 <= {s3 * q} <= {r * q} ]] \\ [[ Sig |- {[] q A} : Type ]]
              }
              {
              [[ Sig; {(G, O), x : [ [] q A ] r} |- B =>+ case x of [ y ] -> t ; {D}, x : [ [] q A ] {s3 + s2} ]]
              }
              \]

        \item Case $\mu_{\textsc{L}}$ \\
              In the case of the left asynchronous rule for recursive data type elimination, the synthesis rule has the form:
              \[
              \fsynMuLP
              \]
              By induction on the first premise, we have that:
              \[
              { \Sigma ; ([[G]], [[O]] ), x :_r [[ A]] [\mu X . [[ A ]] / X ] \vdash [[ B ]] \Rightarrow [[ t ]] \mid\ [[ D]]}   \tag{ih}
              \]
              from case 3 of the lemma. From which, we can construct the following instantiation of the $\mu_{\textsc{L}}$ synthesis rule in the non focusing calculus:
              \[
              \inferrule*[right=$\mu_\textsc{L}$]
                {{  \Sigma ; ([[G]], [[O]]), x :_r [[ A]] [\mu X . [[ A ]] / X ] \vdash [[ B ]] \Rightarrow [[ t ]] \mid\ [[ D]]}}
                {{ \Sigma ; ([[ G ]], [[ O]]), x :_r \mu X . [[ A ]] \vdash [[ B ]] \Rightarrow [[ t]] \mid\ [[D]]}}
              \]
  
          \item Case \fsynLAsyncTransName \\
            In the case of the left asynchronous rule for transitioning an assumption from the focusing context $[[ O ]]$ to the non-focusing context $[[G]]$, the synthesis rule has the form:
            \[
              \fsynLAsyncTransP
            \]
            By induction on the first premise, we have that:
            \[
              [[ Sig ; {G, x : A}, O |- C =>+ t ; D ]] \tag{ih}
            \]
            from case 3 of the lemma.
      \end{enumerate}
  \item Case 4. Right Sync: \\
      \begin{enumerate}
        \item Case $\textsc{C}_{\textsc{R}}$\\
            In the case of the right synchronous rule for constructor introduction, the synthesis rule has the form:
            \footnotesize{
              \[
              \inferrule*[Right=$\textsc{C}_{\textsc{R}}$]
              { [[ ( Con Forall : B'1 - q1 .*. B'n - qn -> {K {A' Many}}) elem Defines  ]] \\\\
               [[ Sig |- inst {B1 - q1 .*. Bn - qn -> {K {A Many}}} {B'1 - q1 .*. B'n - qn -> {K {A' Many}}} ]] \\\\
                \Sigma ; [[ G ]] ; \emptyset \vdash [[ Bi ]] \Downarrow\ \Rightarrow [[ ti ]] \mid\ [[ Di ]]}
              {  \Sigma ; [[  G ]] ; \emptyset \vdash [[{K {A Many}}]] \Downarrow\ \Rightarrow [[Con t1 ... tn]] \mid\ [[  {D1 + ... + Dn} ]]}
              \]
            }
            By induction on the second premise, we have that:
              \[
              [[  Sig ; G |- Bi =>+ ti ; Di]] \tag{ih}
              \]
            from case 4 of the lemma. From which, we can construct the following instantiation of the $\textsc{C}_{\textsc{R}}$\ synthesis rule in the non-focusing calculus:
            \footnotesize{
              \[
              \inferrule*[Right=$\textsc{Con}_{\textsc{R}}$]
              {
              [[ ( Con Forall : B1 - q1 .*. Bn - qn -> { K {A Many} } ) elem Defines ]] \\\\
               [[ Sig |- inst {B1 - q1 .*. Bn - qn -> { K {A Many} } } {B'1 - q1 .*. B'n - qn -> { K {A' Many} }} ]] \\\\
              [[  Sig ; G |- Bi =>+ ti ; Di]]
              }
              {[[  Sig ; G |- K {A Many} =>+ Con t1 ... tn ; {0 * G} + {(q1 * D1) + ... + (qn * Dn)} ]]}
              \]
            }
        \item Case $\Box_{\textsc{R}}$ \\
  
            In the case of the right synchronous rule for graded modality introduction, the synthesis rule has the form:
              \[
              \inferrule*[Right=$\Box_{\textsc{R}}$]
              { \Sigma ; [[ G ]] ; \emptyset \vdash [[ A ]] \Downarrow\ \Rightarrow [[ t ]] \mid\ [[D]]}
              {  \Sigma ; [[ G ]] ; \emptyset \vdash [[ {[] r A} ]] \Downarrow\ \Rightarrow [[ [t] ]] \mid\ [[ r * D ]]}
              \]
            By induction on the premises, we have that:
              \[
              [[ Sig ; G |- A =>+ t ; D]] \tag{ih}
              \]
            from case 4 of the lemma. From which, we can construct the following instantiation of the $\mu{\textsc{R}}$\ synthesis rule in the non-focusing calculus:
              \[
              \synBoxP
              \]

        \item Case $\mu_{\textsc{R}}$ \\ 
            In the case of the right synchronous rule for recursive data type introduction, the synthesis rule has the form:
              \[
                \fsynMuRP
              \]
            By induction on the premises, we have that:
              \[
              {  \Sigma ; \Gamma \vdash [[ A ]] [ \mu X . A / X] \Rightarrow t \mid\ \Delta} \tag{ih}
              \]
            from case 4 of the lemma. From which, we can construct the following instantiation of the $\mu_{\textsc{R}}$\ synthesis rule in the non-focusing calculus:
              \[
              \synMuRP
              \]

          \item Case \fsynRSyncTransName \\
            In the case of the right synchronous rule for transitioning from the right focusing phase to an asynchronous right phase, the synthesis rule has the form:
            \[
              \fsynRSyncTransP
            \]
            By induction on the first premise, we have that:
            \[
              [[ Sig ; G |- A =>+ t ; D ]] \tag{ih}
            \]
            from case 4 of the lemma.
      \end{enumerate}
  \item Case 5. Left Sync: \\
      \begin{enumerate}
        \item Case $\rightarrow_{\textsc{L}}$\\
              In the case of the left synchronous rule for application, the synthesis rule has the form:
              \[
              \inferrule*[]{
              [[  Sig ]] ; [[ G, x1 : [ A ^ q -> B ] r1 ; {x2 : [B] r1} sync |- C => t1 ; D1, x1 : [ A ^ q -> B ] s1, x2 : [B] s2 ]] \\
              [[ Sig ]] ; [[ G, x1 : [ A ^ q -> B ] r1]] ; \emptyset \vdash [[A]] \Downarrow\ \Rightarrow [[t2]] \mid\ [[D2, x1 : [ A ^ q -> B ] s3 ]] \\ [[ Sig |- {A ^ q -> B} : Type ]]
              }
              {
              [[  Sig ]] ; [[ G ; {x1 : [ A ^ q -> B ] r1} sync |- C => {[ ( x1 t2 ) / x2 ] t1} ; (D1 + s2 * {q * D2}), x1 : [A ^ q -> B] {s2 + {s1 + {(s2 * {q * s3})}}}
              ]]
              }
              \]
              By induction on the first premise, we have that:
              \[
  [[  Sig ; G, x1 : [ A ^ q -> B ] r1, {x2 : [B] r1} |- C =>+ t1 ; D1, x1 : [ A ^ q -> B ] s1, x2 : [B] s2 ]]
              \]
              from case 5 of the lemma. By induction on the second premise, we have that:
              \[
               [[ Sig ]] ; [[ G, x1 : [ A ^ q -> B ] r1]] \vdash [[ A ]] \Rightarrow [[ t2 ]] \mid\ [[ D2, x1 : [ A ^ q -> B ] s3 ]] \tag{ih}
              \]
              from case 4 of the lemma. From the third premise, we have that:
              \[
                [[ Sig |- {A ^ q -> B} : Type ]]
              \]
              From which, we can construct the following instantiation of the $\rightarrow_{{\textsc{L}}}$ synthesis rule in the non-focusing calculus:
              \[
              \inferrule*[right=$\rightarrow_{{\textsc{L}}}$]
              {
              [[  Sig ; G, x1 : [ A ^ q -> B ] r1 , x2 : [B] r1 |- C =>+ t1 ; D1, x1 : [ A ^ q -> B ] s1, x2 : [B] s2
              ]]\\
              [[  Sig ; G, x1 : [ A ^ q -> B ] r1 |- A =>+ t2 ; D2, x1 : [ A ^ q -> B ] s3
              ]] \\ [[ Sig |- {A ^ q -> B} : Type ]]
              }
              {[[  Sig ; G, x1 : [ A ^ q -> B ] r1 |- C =>+ {[ ( x1 t2 ) / x2 ] t1} ; (D1 + s2 * {q * D2}), x1 : [A ^ q -> B] {s2 + {s1 + {(s2 * {q * s3})}}}
              ]]}
              \]
  
        \item Case $\textsc{Var}$ \\
          In the case of the left synchronous rule for variable synthesis, the synthesis rule has the form:
            \[
            \fsynVarP
            \]
            From the premise, we have that: 
            \[
            [[ Sig |- A : Type ]]   
            \]
            from which, we can construct the following instantiation of the \textsc{Var}\ synthesis rule in the non-focusing calculus:
            \[
              \synVarP
            \]
        \item Case $\textsc{Def}$ \\
          In the case of the left synchronous rule for synthesis of a top-level definition usage, the synthesis rule has the form:
            \[
            \fsynDefP
            \]
            From the premise, we have that: 
            \[
            [[ Sig |- A : Type ]]   
            \]
            from which, we can construct the following instantiation of the \textsc{Var}\ synthesis rule in the non-focusing calculus:
            \[
              \synDefP
            \]
          \item Case \fsynLSyncTransName \\
            In the case of the left synchronous rule for transitioning from the right focusing phase to an asynchronous left phase, the synthesis rule has the form:
            \[
              \fsynLSyncTransP
            \]
            By induction on the first premise, we have that:
            \[
              [[  Sig ; G, x : [A ] r |- B =>+ t ; D ]] \tag{ih}
            \]
            from case 5 of the lemma.
      \end{enumerate}
  \item Case 6. Right Focus: \\
            In the case of the focusing rule for transitioning from a left asynchronous judgement to a right synchronous judgement, the synthesis rule has the form:
            \[
              \fsynFocusRNoLabelP
            \]
            By induction on the first premise, we have that:
            \[
              [[  Sig ; G |- C =>+ t ; D ]] \tag{ih}
            \]
            from case 3 of the lemma.
  \item Case 7. Left Focus: \\
            In the case of the focusing rule for transitioning from a left asynchronous judgement to a left synchronous judgement, the synthesis rule has the form:
            \[
              \fsynFocusLP
            \]
            By induction on the first premise, we have that:
            \[
              [[  Sig; G, x :  [A] r |- C =>+ t ; D ]] \tag{ih}
            \]
            from case 3 of the lemma.
  \end{enumerate}
  \end{proof}
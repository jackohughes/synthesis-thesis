When programming with graded modal types, we have observed
there is often a need to `distribute' a graded modality over a type, and
vice versa, in order to compose programs. That is,
we may find ourselves in possession of a $\Box_r (\mathsf{F} \alpha)$
value (for some parametric data type $\mathsf{F}$) which needs
to be passed to a pre-existing function (of our own codebase or a library) which requires
a $\mathsf{F} (\Box_r \alpha)$ value, or perhaps vice versa. A \emph{distributive
law} (in the categorical sense, e.g.,~\cite{street1972formal})
provides a conversion from one to the other.
In this paper, we present a procedure to automatically synthesise these
distributive operators, applying a generic programming
methodology~\cite{hinze2000new} to compute these operations given the
base type (e.g., $\mathsf{F} \alpha$ in the above description). This
serves to ease the use of graded modal types in practice, removing
boilerplate code by automatically generating these `interfacing
functions' on-demand, for user-defined data types as well as
built-in types.

%%% Talk about synthesis


Whilst this work can be viewed as synthesis, it is 


Throughout, we refer to distributive laws of the form
$\Box_r (\mathsf{F} \alpha) \rightarrow \mathsf{F} (\Box_r \alpha)$
as \emph{push} operations (as they `push' the graded modality inside
the type constructor $\mathsf{F}$), and dually
$\mathsf{F} (\Box_r \alpha) \rightarrow \Box_r (\mathsf{F} \alpha)$
as \emph{pull} operations (as they `pull' the graded modality outside
the type constructor $\mathsf{F}$).

The primary contributions of this paper are then:
%
\begin{itemize}[itemsep=0em,leftmargin=1em]
  \item an overview of the application of distributive laws
    in the context of graded modal types;
  \item an automatic procedure for calculating distributive laws from
    types and a formal analysis of their properties;
  \item a realisation of this approach in both Granule (embedded into
    the compiler) and Linear Haskell (expressed within the language itself, leveraging
    Haskell's advanced features);
  \item and derivations of related combinators for structural use
    of values in a graded linear setting.
%  \item an evaluation of similar combinators derived from distributive laws
%    in the context of Linear Haskell.
\end{itemize}
%
Along the way, we also analyse choices made around the typed-analysis
of pattern matching in various recent works on graded modal types.
Through the comparison between Granule and Linear Haskell, we also
highlight ways in which Linear Haskell could be made more general
and flexible in the future.
%Through the analysis of distributive laws for programming, we also highlights ways
%in which Linear Haskell could be made more flexible in the future, by
%\mnote{what do we want to say here, exactly?}.

Section~\ref{sec:calculus} defines a core calculus \grminip{} with
linear and graded modal types which provides an idealised,
simply-typed subset of Granule with which we develop the core
contribution.  Section~\ref{sec:push-pull} gives the
procedures for deriving \emph{push} and \emph{pull} operators for the core calculus,
and verifies that these are distributive laws of endofunctors over the
$\Box_r$ graded comonadic modality.
Section~\ref{sec:implementation} describes the details of how these
procedures are realised in the Granule language.
Section~\ref{sec:linhaskell} relates this work to Linear Haskell, and
demonstrates how the \emph{push} and \emph{pull} combinators for user-defined data types
may be automatically generated at compile-time using Template Haskell.
Section~\ref{sec:matching-and-consumption} gives a comparison of the
recent literature with regards the typed (graded) analysis of pattern
matching, which is germane to the typing and derivation of our
distributive laws.
Section~\ref{sec:other} covers how other structural combinators for
Granule and Linear Haskell may be derived. Finally,
Section~\ref{sec:conclusion} discusses more related and future work.

We start with an extended motivating example typifying the kind
of software engineering impedance problem that distributive laws
solve. We use Granule since it is the main vehicle for the developments
here, and introduce some of the key concepts of graded modal types (in
a linear context) along the way.

\subsection{Motivating Example}
\label{sec:motivating-example}

Consider the situation of projecting the first element of a pair. In Granule,
this first-projection is defined and typed as the following
polymorphic function (whose syntax is reminiscent of Haskell or ML):
%
\begin{granule}
fst : forall {a b : Type} . (a, b [0]) -> a
fst (x, [y]) = x
\end{granule}
%
Linearity is the default, so this represents a linear function applied
to linear values.\footnote{Granule uses $\rightarrow$ syntax rather than
$\multimap$ for linear functions for the sake of familiarity with
standard functional languages} However, the second component of the pair
has a \emph{graded modal type}, written \granin{b [0]}, which means that we can use
the value ``inside'' the graded modality $0$ times by first `unboxing'
this capability via the pattern match \granin{[y]} which allows
weakening to be applied in the body to discard \granin{y} of type \granin{b}.
In calculus of Section~\ref{sec:calculus}, we denote
`\granin{b [0]}' as the type $\Box_0 b$ (Granule's graded
modalities are written postfix with the `grade' inside the box).
% do we need to make sure this is 0 : r for all r : Semiring?

The type for \granin{fst} is however somewhat restrictive: what if
we are trying to use such a function with a value (call it
\granin{myPair}) whose type is not
of the form \granin{(a, b [0])} but rather \granin{(a, b) [r]} for
some grading term \granin{r} which permits weakening? Such a situation
readily arises when we are composing functional code, say between
libraries or between a library and user code. In this situation,
\granin{fst myPair} is ill-typed. Instead, we could define a
different first projection function for use with \granin{myPair : (a,
  b) [r]} as:
%
\begin{granule}
fst' : forall {a b : Type, s : Semiring, r : s} . {0 <= r} => (a, b) [r] -> a
fst' [(x, y)] = x
\end{granule}
%
This implementation uses various language features of Granule to make
it as general as possible. Firstly, the function is polymorphic
in the grade \granin{r} and in the semiring \granin{s} of which \granin{r}
is an element. Next, a refinement constraint \granin{0 <= r} specifies
that by the preordering \granin{<=} associated with the semiring
\granin{s}, that \granin{0} is approximated by \granin{r}
(essentially, that \granin{r} permits weakening). The rest
of the type and implementation looks more familiar for computing
a first projection, but now the graded
modality is over the entire pair.

From a software engineering perspective, it is cumbersome to
create alternate versions of generic combinators every time we are
in a slightly different situation with regards the position of a
graded modality.  Fortunately, this is an example to which a
general \emph{distributive law} can be deployed. In this case,
we could define the following distributive law of graded modalities over
products, call it \granin{pushPair}:
%
\begin{granule}
pushPair : forall {a b : Type, s : Semiring, r : s} . (a, b) [r] -> (a [r], b [r])
pushPair [(x, y)] = ([x], [y])
\end{granule}
%
This `pushes' the graded modality \granin{r} into
the pair (via pattern matching on the modality and the pair inside it, and then
reintroducing the modality on the right hand side via \granin{[x]} and
\granin{[y]}), distributing the graded modality to each component.
Given this combinator, we can now apply \granin{fst (pushPair myPair)} to yield a value of
type \granin{a [r]}, on which we can then apply the Granule standard library
function \granin{extract}, defined:
\begin{granule}
  extract : forall {a : Type, s : Semiring, r : s} . {(1 : s) <= r} => a [r] -> a
  extract [x] = x
\end{granule}
 to get the original \granin{a} value we desired:
%
\begin{granule}
extract (fst (pushPair myPair)) : a
\end{granule}
%
The \granin{pushPair} function could be provided by the standard
library, and thus we have not had to write any specialised combinators
ourselves: we have applied supplied combinators to solve the problem.

Now imagine we have introduced some custom data type \granin{List}
on which we have a \emph{map} function:
%
\begin{granule}
data List a = Cons a (List a) | Nil

map : forall {a b : Type} . (a -> b) [0..Inf] -> List a -> List b
map [f] Nil = Nil;
map [f] (Cons x xs) = Cons (f x) (map [f] xs)
\end{granule}
%
Note that, via a graded modality, the type of \granin{map} specifies that the parameter
function, of type \granin{a -> b} is non-linear, used between
$0$ and $\infty$ times. Imagine now we have a value
\granin{myPairList : (List (a, b)) [r]} and we want to map first
projection over it. But \granin{fst} expects \granin{(a, b [0])}
and even with \granin{pushPair} we require \granin{(a, b) [r]}.
\emph{We need another distributive law}, this time of the graded modality
over the \granin{List} data type. Since \granin{List} was
user-defined, we now have to roll our own \granin{pushList} operation, and so we
are back to having to make specialised combinators for our
data types.

The crux of this paper is that such distributive laws can be
automatically calculated given the definition of a type. With
our Granule implementation of this approach (Section~\ref{sec:implementation}),
we can then solve this combination problem via the following
composition of combinators:
%
\begin{granule}
map (extract . fst . push @(,)) (push @List myPairList) : List a
\end{granule}
%
where the \granin{push} operations are written with their base type
via \granin{@} (a type application) and whose definitions and types
are automatically generated during type checking. Thus the
\granin{push} operation is a \textit{data-type generic
  function}~\cite{hinze2000new}. This generic function is defined
inductively over the structure of types, thus a programmer can introduce a new
user-defined algebraic data type and have the implementation of the generic
distributive law derived automatically.
This reduces both the
initial and future effort (e.g., if an ADT definition changes or new ADTs are
introduced).

Dual to the above, there are situations where a programmer
may wish to \emph{pull} a graded modality out of a structure. This is
possible with a dual distributive law, which could be written
by hand as:
%
\begin{granule}
pullPair : forall {a b : Type, s : Semiring, m n : s} . (a [n], b [m]) -> (a, b) [n /\ m]
pullPair ([x], [y]) = [(x, y)]
\end{granule}
%
Note that the resulting grade is defined by the greatest-lower bound
(meet) of \granin{n} and \granin{m}, if it exists as defined
by a preorder for semiring \granin{s}
 (that is, $\sqcap$ is not a total operation). This
allows some flexibility in the use of the \emph{pull} operation when
grades differ in different components but have a
greatest-lower bound which can be `pulled out'.
Our approach also allows such operations to be generically derived.

% Another potential example here?
% \granin{copyFst : forall {a, b : Type} . (a, b) [0..2] -> (a, a)}
% \granin{copyFst x = let x' = pushPair x in copy (fst x')}
%
%\granin{copyPair : forall {a, b : Type} . (a [0..2], b [0..2]) -> (a, b)[0..2]} }
%\granin{copyPair x = copy (pullPair x)}

%Our approach here is reminiscent ``push'' and ``pull'' operations are defined
%throughout the standard library for sums, products, and other ADTs such as
%lists. There is a general pattern to these distributive operations which allows
%their programs to be automatically synthesised from their type structure alone
%by a simple inductive procedure.



 \lstset{
  language=Haskell,
  basicstyle=\ttfamily\footnotesize,
  literate={\\\%}{\%}2
}

While Granule has been pushing the state-of-the-art in graded modal types,
similar features have been added to more mainstream languages. Haskell has
recently added support for linear types via an underlying
graded system which enables linear types as a smooth extension
to GHC's current type system~\cite{linear-haskell}.\footnote{Released
as part of GHC v9.0.1 in February 2021 \url{https://www.haskell.org/ghc/download_ghc_9_0_1.html}}
Functions may be linear with respect to
their input (meaning, the function will consume its argument exactly
once if the result is consumed exactly once), but
they can also consume their argument \granin{r}
times for some multiplicity \granin{r} via explicit `multiplicity polymorphism'.
Unlike Granule, Linear Haskell limits this multiplicity to the set of either
one or many (the paper speculates about extending this with zero)---full natural
numbers or other semirings are not supported.
% previously
% arbitrary user-defined data types are not supported.

In Linear Haskell, the function type (\haskin{a \%r -> b})
can be read as ``a function from \granin{a}
to \granin{b} which uses \granin{a} according to \granin{r}'' where
\granin{r} is either $1$ (also written as \haskin{'One}) or $\omega$
(written as \haskin{'Many}).
For example, the following defines and types the linear and non-linear functions
\granin{swap} and \granin{copy} in Linear Haskell:
%
\begin{haskell}
{-# LANGUAGE LinearTypes #-}
import GHC.Types

swap :: (a %1 -> b %1 -> c) %1 -> (b %1 -> a %1 -> c)
swap f x y = f y x

copy :: a %'Many -> (a, a)
copy x = (x, x)
\end{haskell}
%
Assigning the type \haskin{a \%1 -> (a, a)} to
\haskin{copy} would result in a type error due to a mismatch in
multiplicity.

The approach of Linear Haskell (as formally defined by Bernardy et al.~\cite{linear-haskell})
resembles earlier coeffect
systems~\cite{ghica2014bounded,petricek2014coeffects} and
more recent work on graded systems which have appeared
since~\cite{abel-barnardy-icfp2020,choudhury2021}. In
these approaches there is no underlying linear type system (as there is in Granule) but
grading is instead pervasive with function arrows carrying a grade
describing the use of their parameter. Nevertheless, recent systems also provide a graded modality
as this enables more fine-grained usage information to be ascribed to compound data.
For example, without graded modalities it cannot be explained that the first projection on
a pair uses the first component once and its second component not at
all (instead a single grade would have to be assigned to the entire pair).

We can define a graded modality in Linear Haskell
via the following \haskin{Box} data type that is parameterized
over the multiplicity \granin{r} and the value type \granin{a}, defined as:
%
\begin{haskell}
data Box r a where { Box :: a %r -> Box r a }
\end{haskell}
%
A \granin{Box} type is necessary
to make explicit the notion that a value may be consumed a certain number of times,
where ordinarily Linear Haskell is concerned only with whether individual functions
consume their arguments linearly or not.
Thus, distributive laws of the form discussed in this paper
then become useful in practice when working with Linear Haskell.

The \granin{pushPair} and \granin{pullPair} functions from Section~\ref{sec:intro}
can then be implemented in Linear Haskell with the help of this \granin{Box} type:
%
\begin{haskell}
pushPair :: Box r (a, b) %1 -> (Box r a, Box r b)
pushPair (Box (x, y)) = (Box x, Box y)
\end{haskell}
%
\begin{haskell}
pullPair :: (Box r a, Box r b) %1 -> Box r (a, b)
pullPair (Box x, Box y) = Box (x, y)
\end{haskell}
%
Interestingly, \haskin{pushPair} could also be implemented as a function of type
\haskin{(a, b) \%r -> (Box r a, Box r b)}, and in general we can formulate
push combinators typed \haskin{(f a) \%r -> f (Box r a)}, i.e., consuming
the input \granin{r} times, returning a box with multiplicity \granin{r}, but
we stick with the above formulation for consistency.

While more sophisticated methods are outlined in this paper for automatically
synthesizing these functions in the context of Granule, in the
context of Linear Haskell (which has a simpler notion of grading) distributive laws over unary and binary type
constructors can be captured with type classes:
%
\begin{haskell}
class Pushable f where
  push :: Box r (f a) %1-> f (Box r a)
class Pushable2 f where
  push2 :: Box r (f a b) %1-> f (Box r a) (Box r b)

class Pullable f where
   pull :: f (Box r a) %1-> Box r (f a)
class Pullable2 f where
  pull2 :: f (Box r a) (Box r b) %1-> Box r (f a b)
\end{haskell}
%
Separate classes here are defined for unary and binary cases, as working generically
over both is tricky in Haskell.
%
%
Implementing an instance of \granin{Pushable2} for pairs is then:
%
\begin{lstlisting}[language=Haskell]
instance Pushable2 (,) where
  push2 (Box (x, y)) = (Box x, Box y)
\end{lstlisting}
%
This implementation follows the procedure of
Section~\ref{sec:push-pull}.
A pair type $A \otimes B$ is handled by pattern matching on \granin{(Box (x, y))} and boxing both
fields in the pair \granin{(Box x, Box y)}.

A Haskell programmer may define instances of these type classes
for their own data types, but as discussed in Section~\ref{sec:intro}, this is
tedious from a software engineering perspective.
%
Template Haskell is a meta-programming system for Haskell that allows
compile-time generation of code, and one of the use cases for Template Haskell
is generating boilerplate code~\cite{template-haskell}. The instances of
\granin{Pushable} and \granin{Pullable} for algebraic data types are relatively
straightforward, so we implemented procedures that will automatically generate
these type class instances for arbitrary user-defined types (though types with
so-called ``phantom'' parameters are currently not supported).

For example, if a programmer wanted to define a \granin{Pushable} instance for
the data type of a linear \granin{List a}, they would write:
%
\begin{lstlisting}[language=Haskell,mathescape=true]
data List a where
  Cons :: a %1-> List a %1-> List a
  Nil  :: List a
$\$$(derivePushable ''List)
\end{lstlisting}
%
Here, \granin{derivePushable} is a Template Haskell procedure\footnote{Available online: \url{https://github.com/granule-project/deriving-distributed-linear-haskell}} that takes a name
of a user-defined data type and emits a top-level declaration, following the
strategy outlined in Section~\ref{sec:push-pull}.
%
For the \granin{List a} data type above, we can walk through the type as
\granin{derivePushable} would. Because \granin{List a} has two constructors, a case statement
is necessary (our code generator will use a `case lambda'). This case will have branches for each
of the \granin{Cons} and \granin{Nil} constructors---in the body of the former it must box the
first field (of type \granin{a}) and recursively apply \granin{push} to the second field (of
type \granin{List a}) after boxing it, and in the body of the latter it must simply return
\granin{Nil.}
%
The full code generated by \granin{derivePushable ''List} is given below.
\begin{lstlisting}
derivePushable ''List
======>
instance Pushable List where
  push
    = \case
        Box (Cons match_a4BD match_a4BE)
          -> (Cons (Box match_a4BD)) (push (Box match_a4BE))
        Box Nil -> Nil
\end{lstlisting}
%
Later, in Section~\ref{sec:other}, we will discuss other combinators and type classes that are
useful in Linear Haskell.

The applicability of our proposed deriving method to Haskell shows that it is
useful beyond the context of the Granule project. Despite Haskell not having a formal semantics, we believe the same equational reasoning can be applied to show that the properties in Section~\ref{subsection:properties} also hold for these distributive laws in Linear Haskell. As more programming languages
adopt type system features similar to Granule and Linear Haskell, we expect that
deriving/synthesizing or otherwise generically implementing combinators derived
from distributive laws will be increasingly useful.

% Furthermore, in cases where \granin{f} is already an applicative functor, the
% single parameter case can be implemented elegantly with a function from
% Haskell's standard library:

% \begin{lstlisting}[language=Haskell]
% sequenceA :: Applicative f => t (f a) -> f (t a)
% \end{lstlisting}



% Pushing the \granin{r} parameter by distributing it over a pair
% is done by straightforward pattern matching:

% \begin{lstlisting}[language=Haskell]
% pushPair :: Box r (a, b) %1 -> (Box r a, Box r b)
% pushPair (Box (x, y)) = (Box x, Box y)
% \end{lstlisting}

% Defining the pull combinator is similarly straightforward:

% \begin{lstlisting}[language=Haskell]
% pullPair :: (Box r a, Box r b) %1 -> Box r (a, b)
% pullPair (Box x, Box y) = Box (x, y)
% \end{lstlisting}
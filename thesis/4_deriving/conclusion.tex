Section~\ref{sec:matching-and-consumption} considered, in some detail,
systems related to Granule and different typed analyses
of pattern matching. Furthermore, in
applying our approach to both Granule and Linear Haskell
we have already provided some detailed comparison between the two. This section
considers some wider related work alongside ideas for future work,
then concludes the paper.

\paragraph{Generic Programming Methodology}
The deriving mechanism for Granule is based on the methodology of
generic functional programming~\cite{hinze2000new}, where functions
may be defined generically for all possible data types in the language;
generic functions are defined inductively on the structure of the types.
This technique has notably been used before in Haskell, where there
has been a strong interest in deriving type
class instances automatically. Particularly relevant to this paper is the work
on generic deriving~\cite{generic-deriving}, which allows Haskell programmers to
automatically derive arbitrary class instances using standard datatype-generic
programming techniques as described above. In this paper we opted to rely on
compile-time metaprogramming using Template Haskell~\cite{template-haskell}
instead, but it is possible that some of the combinators we describe could be
implemented using generic deriving as well, which is future work.

\paragraph{Non-graded Distributive Laws}
Distributive laws are standard components in abstract
mathematics. Distributive laws between categorical structures used for
modelling modalities (like monads and comonads) are well explored. For
example, Brookes and Geva defined a categorical semantics using monads
combined with comonads via a distributive law capturing both
intensional and effectful aspects of a
program~\cite{brookes1993intensional}. Power and Watanabe study in
detail different ways of combining comonads and monads via
distributive laws~\cite{power2002combining}. Such distributive laws
have been applied in the programming languages literature, e.g., for
modelling streams of partial elements~\cite{uustalu2006essence}.

\paragraph{Graded Distributive Laws}
Gaboardi et al. define families of graded distributive laws
for graded monads and comonads~\cite{combining2016}. They
include the ability to interact the grades, e.g., with operations
such as $\Box_{\iota(r,f)} \Diamond_f A \rightarrow \Diamond_{\kappa(r,f)} \Box_r A$
between a graded comonad $\Box_r$ and graded monad $\Diamond_f$ where
$\iota$ and $\kappa$ capture information about the distributive law
in the grades. In comparison, our distributive laws here are more
prosaic since they involve only a graded comonad (semiring graded
necessity) distributed over a functor and vice versa. That said,
the scheme of Gaboardi et al. suggests that there might be interesting
graded distributive laws between $\Box_r$ and the indexed types,
for example, $\Box_r (\mathsf{Vec}\, n \, A) \rightarrow \mathsf{Vec}\,
  (r * n) \, (\Box_1 A)$ which internally replicates a
  vector. However, it is less clear how useful such combinators would
be in general or how systematic their construction would be. In
contrast, the distributive laws explained here appear frequently
and have a straightforward uniform calculation.

We noted in Section~\ref{sec:push-pull} that neither of our
distributive laws can be derived over graded modalities themselves,
i.e., we cannot derive
$\textit{push} : \Box_r \Box_s A \rightarrow \Box_s \Box_r A$. Such an
operation would itself be a distributive law between two graded modalities,
which may have further semantic and analysis consequences beyond the normal derivations here
for regular types. Exploring this is future work, for which the previous
work on graded distributive laws can provide a useful
scheme for considering the possibilities here.
Furthermore, Granule has both graded comonads and graded monads
so there is scope for exploring possible graded distributive laws
between these in the future following Gaboardi et
al.~\cite{combining2016}.

In work that is somewhat adjacent to this paper, we define program
synthesis procedures for graded linear
types~\cite{DBLP:conf/lopstr/HughesO20}. This program synthesis
approach can synthesis \emph{pull} distributive laws that are
equivalent to the algorithmically derived operations of this
paper. Interestingly the program synthesis approach cannot derive the
\emph{push} laws though as its core theory has a simplified notion of
pattern typing that doesn't capture the full power of Granule's
pattern matches as described in this paper.

\paragraph{Conclusions}
The slogan of graded types is to imbue types with
information reflecting and capturing the underlying program semantics
and structure. This provides a mechanism for fine-grained intensional
reasoning about programs at the type level, advancing the power of
type-based verification. Graded types are a burgeoning technique that is
gaining traction in mainstream functional programming and is being
explored from multiple different angles in the literature. The
work described here addresses the practical aspects of applying
these techniques in real-world programming. Our hope is that this
aids the development of the next generation of programming languages
with rich type systems for high-assurance programming.
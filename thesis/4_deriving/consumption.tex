
 \newcommand{\abname}{$\Lambda^p$}
 \newcommand{\gradname}{\textsc{GraD}}
 
 This paper's study of distributive laws provides
 an opportunity to consider design decisions for the \emph{typed
   analysis of pattern matching} since the operations of
 Section~\ref{sec:push-pull} are derived by pattern matching in concert
 with grading. We compare here the choices made surrounding the typing of
 pattern matching in four works (1) Granule and
 its core calculus~\cite{DBLP:journals/pacmpl/OrchardLE19} (2) the graded
 modal calculus \abname{} of Abel and Bernardy~\cite{abel-barnardy-icfp2020} (3) the dependent graded system
 \gradname{} of Choudhury et al.~\cite{choudhury2021} and (4) Linear
 Haskell~\cite{linear-haskell}.
 
 \paragraph{Granule}
 %
 Pattern matching against a graded modality $\Box_r A$ (with pattern
 $[p]$) in Granule is provided by the \textsc{Pbox} rule
 (Figure~\ref{fig:pattern-rules}) which triggers typing pattern $p$
 `under' a grade $r$ at type $A$. This was denoted via the optional grade information
 $[[ r |- p : A |> G ]]$ which then pushes grading down onto the
 variables bound within $p$. Furthermore, it is only under such a
 pattern that wildcard patterns are allowed (\textsc{[Pwild]}),
 requiring $\coeff{[[ 0 <<= r]]}$, i.e., $[[ r ]]$ can approximate
 $0$ (where $\coeff{0}$ denotes weakening).
 None of the other systems considered here have such a facility
 for weakening via pattern matching.
 
 For a type $A$ with more than one
   constructor ($[[ | A | > 1 ]]$), pattern matching its
   constructors underneath an $r$-graded box requires $[[ 1 <<=
   r]]$. For example, eliminating sums inside an $\coeff{[[r]]}$-graded box
 $[[ [] r (Sum A B) ]]$ requires $[[ 1 <<= r ]]$ as
 distinguishing $\mathsf{inl}$ or $\mathsf{inr}$
 constitutes a \emph{consumption} which reveals information (i.e.,
 pattern matching on the `tag' of the data constructors).
 By contrast, a type with only one constructor cannot convey any information
 by its constructor and so matching on it is not counted as a consumption:
 eliminating $[[ [] r (Tup A B) ]]$ places no
 requirements on $r$.
 The idea that unary data types do not incur consumption (since no
 information is conveyed by its constructor) is a refinement here to the
 original Granule paper as described by Orchard et
 al.~\cite{DBLP:journals/pacmpl/OrchardLE19}, which for \textsc{[Pcon]}
 had only the premise $[[ 1 <<= r]]$ rather than
 $[[ | A | > 1 ]] \implies [[ 1 <<= r ]]$ here (although the
 implementation already reflected this idea).
 
 \paragraph{The \abname{} calculus}
 Abel and Bernardy's unified modal system \abname{} is akin to Granule,
 but with pervasive grading (rather than base linearity) akin to the
 coeffect calculus~\cite{petricek2014coeffects} and Linear
 Haskell~\cite{linear-haskell} (discussed in
 Section~\ref{sec:linhaskell}). Similarly to the situation in Granule,
 \abname{} also places a grading requirement when pattern matching on a
 sum type, given by the following typing rule in their syntax~\cite[Fig
 1, p.4]{abel-barnardy-icfp2020}:
 %
 \begin{align*}
 \dfrac{\gamma \Gamma \vdash t : A_1 + A_2 \qquad \delta\Gamma, x_i :^q
   A_i \vdash u_i : C \qquad q \leq 1}
       {(q\gamma + \delta)\Gamma \vdash \mathsf{case}^q\ t\ \mathsf{of}\
   \{\mathsf{inj}_1 x_1 \mapsto u_1; \mathsf{inj}_2 x_2 \mapsto u_2 \}
   : C}\textsc{$+$-elim}
 \end{align*}
 %
 The key aspects here are that variables $x_i$ bound in the case are used
 with grade $q$ as denoted by the graded assumption $x_i :^q A_i$ in the context of
 typing $u_i$ and then that $q \leq 1$ which is exactly our
 constraint that $[[ 1 <<= r ]]$ (their ordering just runs in the
 opposite direction to ours). For the elimination of pair and unit
 types in \abname{} there is no such constraint, matching our idea that arity
 affects usage, captured in Granule by $[[ | A | > 1 ]] \implies [[ 1
 <<= r ]]$. Their typed-analysis of patterns is motivated
 by their parametricity theorems.
 
 \paragraph{\gradname{}}
 The dependent graded type system \gradname{} of Choudhury et al. also considers
 the question of how to give the typing of pattern matching on sum
 types, with a rule in their system~\cite[p.8]{choudhury2021} which
 closely resembles the \textsc{$+$-elim} rule for \abname{}:
 %
 \begin{align*}
 \dfrac{
   \Delta ; \Gamma_1 \vdash q : A_1 \oplus A_2
   \qquad
   \Delta ; \Gamma_2 \vdash b_1 : A_1 \xrightarrow{q} B
   \qquad
   \Delta ; \Gamma_2 \vdash b_2 : A_2 \xrightarrow{q} B
   \qquad
   1 \leq q
 }
 {\Delta ; q \cdot \Gamma_1 + \Gamma_2 \vdash \mathbf{case}_q\ a\
   \mathbf{of}\ b_1; b_2 : B}
 \textsc{STcase}
 \end{align*}
 %
 %The key aspects are that each branch represent a function with grade
 %$q$ and that $q$ must decompose into $q = q' + 1$ for some $q'$
 %capturing the idea that the case matching on a sum type causes a
 %consumption.
 The direction of the preordering in \gradname{} is the same
 as that in Granule but, modulo this ordering and some slight
 restructuring, the case rule
 captures the same idea as \abname{}: ``both branches
 of the base analysis \emph{must} use the scrutinee at least once,
 as indicated by the $1 \leq q$ constraint.''~\cite[p.8]{choudhury2021}.
 Choudhury et al., also provide a heap-based semantics which serves to connect the
 meaning of grades with a concrete operational model of usage, which
 then motivates the grading on sum elimination here. % Choudhury et
 %al. note that this approach has some philosophical similarities to
 %Abel and Bernardy's $q \leq 1$ constraint, but point out that these
 %two constraints are not necessarily equivalent for arbitrary semirings
 %(although it is true for $\mathbb{N}$).
 In the simply-typed version of \gradname{}, matching on the components
 of a product requires that each component is consumed linearly.
 %Thus, we see a similar idea
 %here to both Granule and \abname{} on the type-analysis of patterns,
 %but with a slightly different characterisation motivating by a more
 %concrete model.
 
 \paragraph{Linear Haskell}
 % \dnote{Can someone (Mike?) look over the Linear Haskell paper again
 %   check to see if they saying anything about grades and pattern
 %   matching? I looked and didn't see}
 The paper on Linear Haskell by Bernardy et
 al.~\cite{linear-haskell} has a \textbf{case} expression for
 eliminating arbitrary data constructors, with grading similar
 to the rules seen above. Initially, this rule is for the setting
 of a semiring over $\mathcal{R} = \{1, \omega\}$ (described
 in Section~\ref{sec:linhaskell}) and has no requirements on the grading
 to represent the notion of inspection, consumption, or usage due to
 matching on (multiple) constructors.
 This is reflected in the current
 implementation where we can define the following sum elimination:
 %
 \begin{haskell}
 match :: (Either a b) %r -> (a %1 -> c) -> (b %1 -> c) -> c
 match (Left x) f _  = f x
 match (Right x) _ g = g x
 \end{haskell}
 %
 However, later when considering
 the generalisation to other semirings they state that
 ``\emph{typing rules are mostly unchanged with the caveat that
 $\mathsf{case}_\pi$ must exclude $\pi = 0$}''~\cite[\S{}7.2,
 p.25]{linear-haskell} where $\pi$ is the grade of the $\textbf{case}$ guard.
 This appears a more coarse-grained restriction
 than the other three systems, excluding even the possibility of
 Granule's weakening wildcard pattern which requires $0 \leq \pi$.
 Currently, such a pattern must be marked as \haskin{'Many} in Linear
 Haskell (i.e., it cannot explain that first projection on a pair
 does not use the pair's second component).
 Furthermore, the condition $\pi \neq 0$ does not require that $\pi$
 actually
 represents a consumption, unlike the approaches of the other three
 systems.
 %
 %Note that this multiplicity polymorphic (variable \haskin{r}), leading to the
 %question of whether $\texttt{r} = 0$ is a possible unification. The rest of the
 %literature as described above would all prevent $\texttt{r} = 0$ here, requiring
 %instead $\texttt{r} = 1$ or $\texttt{r} = \omega$, and this is briefly touched
 %on by Bernardy et al.~\cite{linear-haskell} as well, where the authors note that
 %if a multiplicity of $0$ were allowed, pattern match statements would need to be
 %restricted.
 The argument put forward by Abel and Bernardy for their restriction to
 mark a consumption ($q \leq 1$)
 for the sake of parametricity is a compelling one, and the concrete model of
 Choudhury et al. gives further confidence that this restriction captures well an
 operational model.
 Thus, it seems there is a chance for fertilisation
 between the works mentioned here and Linear Haskell's vital work, towards a
 future where grading is a key tool in the typed-functional programmer's toolbox.
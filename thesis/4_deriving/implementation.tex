 The Granule type checker implements the algorithmic derivation of \emph{push}
 and \emph{pull} distributive laws as covered in the previous section. Whilst the
 syntax of \grminip{} types had unit, sum, and product types as primitives, in
 Granule these are provided by a more general notion of type constructor which
 can be extended by user-defined, generalized algebraic data types (GADTs). The
 procedure outlined in Section~\ref{sec:push-pull} is therefore generalised
 slightly so that it can be applied to any data type: the case for $A \oplus B$
 is generalised to types with an arbitrary number of data constructors.
 
 Our deriving mechanism is exposed to programmers via explicit (visible) type
 application (akin to that provided in GHC Haskell~\cite{eisenberg2016visible})
 on reserved names \granin{push} and \granin{pull}. Written \granin{push @T} or
 \granin{pull @T}, this signals to the compiler that we wish to derive the
 corresponding distributive laws at the type \granin{T}. For example, for the
 \granin{List : Type -> Type} data type from the standard library, we can write
 the expression \granin{push @List} which the type checker recognises as a
 function of type:
 %
 \begin{granule}
 push @List : forall {a : Type, s : Semiring, r : s} . {1 <= r} => (List a) [r] -> List (a [r])
 \end{granule}
 %
 Note this function is not only polymorphic in the grade, but polymorphic in the
 semiring itself. Granule identifies different graded modalities by
 their semirings, and thus this operation is polymorphic in the graded
 modality. When the type checker encounters such a type application, it
 triggers the derivation procedure of Section~\ref{sec:push-pull},
 which also calculates the type. The result is then stored in the state
 of the frontend to be passed to the interpreter (or compiler) after
 type checking. The derived operations are memoized so that they need not be re-calculated if a particular distributive law is required more than once.
 Otherwise, the implementation largely follows
 Section~\ref{sec:push-pull} without surprises,
 apart from some additional machinery for specialising the types
 of data constructors coming from (generalized) algebraic data types.
 
 \paragraph{Examples}
 Section~\ref{sec:intro} motivated the crux of this paper with a
 concrete example, which we can replay here in concrete Granule, using
 its type application technique for triggering the automatic derivation
 of the distributive laws. Previously, we defined \granin{pushPair} by
 hand which can now be replaced with:
 %
 \begin{granule}
 push @(,) : forall {a, b : Type, s : Semiring, r : s} . (a, b) [r] -> (a [r], b [r])
 \end{granule}
 %
 Note that in Granule \granin{(,)} is an infix type constructor for products as well as terms. We could then replace the previous definition of \granin{fst'} from
 Section~\ref{sec:intro} with:
 %
 \begin{granule}
 fst' : forall {a, b : Type, r : Semiring} . {0 <= r} => (a, b) [r] -> a
 fst' = let [x'] = fst (push @(,) x) in x'
 \end{granule}
 %
 The point however in the example is that we need not even define this
 intermediate combinator, but can instead write the following
 wherever we need to compute the first projection
 of \granin{myPair : (a, b) [r]}:
 %
 \begin{granule}
 extract (fst (push @(,) myPair)) : a
 \end{granule}
 %
 We already saw that we can then generalise this by applying
 this first projection inside of the list \\ \granin{myPairList : (List (a, b))
   [r]} directly, using \granin{push @List}.
 
 In a slightly more elaborate example, we can use the \granin{pull} combinator
 for pairs to implement a function that duplicates a pair (given that both elements
 can be consumed twice):
 %
 \begin{granule}
 copyPair : forall {a, b : Type} . (a [0..2], b [2..4]) -> ((a, b), (a, b))
 copyPair x = copy (pull @(,) x) -- where, copy : a [2] -> (a, a)
 \end{granule}
 %
 Note \granin{pull} here computes the greated-lower
 bound of intervals \granin{0..2} and \granin{2..4} which is
 \granin{2..2}, i.e., we can provide a pair of \granin{a} and \granin{b}
 values which can each be used exactly twice, which is what is required
 for \granin{copy}.
 
 As another example, interacting with Granule's indexed types
 (GADTs), consider a simple programming task of taking the head of a sized-list (vector)
 and duplicating it into a pair. The \granin{head} operation
 is typed: \granin{head : forall \{a : Type, n : Nat\} . (Vec (n + 1) a)
   [0..1] -> a} which has a graded modal input with grade \granin{0..1} meaning
 the input vector is used 0 or 1 times:
 the head element is used once (linearly) for the return
 but the tail is discarded.
 
 This head element can then be copied
 if it has this capability via a graded modality, e.g., a value of type \granin{(Vec (n + 1) (a [2]))
   [0..1]} permits:
 %
 \begin{granule}
 copyHead' : forall {a : Type, n : Nat} . (Vec (n + 1) (a [2])) [0..1] -> (a, a)
 copyHead' xs = let [y] = head xs in (y, y) -- [y] unboxes (a [2]) to y:a usable twice
 \end{granule}
 %
 Here we ``unbox'' the graded modal value of type \granin{a [2]} to
 get a non-linear variable \granin{y} which we can use precisely twice.
 However, what if we are in a programming
 context where we have a value \granin{Vec (n + 1) a} with no
 graded modality on the type \granin{a}? %What requirements can we place
 %on such a value to explain we need to be able to discard the tail of
 %the vector and reuse the head twice?
 We can employ two idioms here:
 (i) take a value of type \granin{(Vec (n + 1) a) [0..2]} and
 split its modality in two: \granin{(Vec (n + 1) a) [2] [0..1]}
 (ii) then use \textit{push} on the inner graded modality
 \granin{[2]} to get
 \granin{(Vec (n + 1) (a [2])) [0..1]}.
 
 Using \granin{push @Vec} we can thus write the following to duplicate
 the head element of a vector:
 %
 \begin{granule}
 copyHead : forall {a : Type, n : Nat} . (Vec (n + 1) a) [0..2] -> (a, a)
 copyHead = copy . head . boxmap [push @Vec] . disject
 \end{granule}
 %
 which employs combinators from the standard library and
 the derived distributive law, of type:
 %
 \begin{granule}
 boxmap    : forall {a b : Type, s : Semiring, r : s}        . (a  -> b) [r] -> a [r] -> b [r]
 disject   : forall {a : Type, s : Semiring, n m : s}        . a [m * n] -> (a [n]) [m]
 push @Vec : forall {a : Type, n : Nat, s : Semiring, r : s} . (Vec n a) [r] -> Vec n (a [r])
 \end{granule}
 %
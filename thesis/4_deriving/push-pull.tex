Now that we have established the core theory, we describe the
algorithmic calculation of distributive laws in \grminip{}.
Note that whilst \grminip{} is simply typed (monomorphic), it includes
type variables (ranged over by $\alpha$) to enable
the distributive laws to be derived on parametric types. In the implementation,
these will really be polymorphic type variables, but the derivation
procedure need only treat them as some additional syntactic type construct.

%We will be concerned with $n$-ary type constructors,
%of kind $\tcF : \mathsf{Type}^n \rightarrow \mathsf{Type}$,
%where we write $\tcF (\overline{A_i})$ to represent
%the application of $\tcF$ to a family of
%argument types $A_i$ for all $1 \leq i \leq n$.
%%DAO: don't think we need this now
%%We represent an indexed set of $n$-types as $\{A_i\}^n_i$.

%
\paragraph{Notation}
Let $\tcF : \mathsf{Type}^n \rightarrow \mathsf{Type}$
be an $n$-ary type constructor (i.e. a constructor which takes $n$ type arguments), whose free type variables
provide the $n$ parameter types. We write $\tcF \overline{\alpha_i}$ for
the application of $\tcF$ to
type variables $\alpha_i$ for all $1 \leq i \leq n$.

%\dnote{Split and do one at time? Might be better.}
%\paragrapho{Pull}
%
\paragraph{Push}
We automatically
calculate \emph{push} for $\mathsf{F}$
applied to $n$ type variables
% $\{\alpha_i\}^n_i$
$\overline{\alpha_i}$
as the operation:
%
\begin{align*}
\deriv{push}{\tcF \overline{\alpha_i}} : \Box_{r} \tcF \overline{\alpha_i}
  \multimap  \tcF  (\overline{\Box_{r} \alpha_i})
 \end{align*}
where we require $[[ 1 <<= r ]]\ \textit{if}\ |\tcF \overline{\alpha_i}| > 1$
due to the $[\textsc{Pcon}]$ rule (e.g., if $\tcF$ contains a sum).

For types $A$ closed with respect to recursion variables, let $\deriv{push}{A} = \lambda z
. \deriv{push}{A}^\emptyset\ z$ given by an intermediate
interpretation $\deriv{push}{A}^\Sigma$ where $\Sigma$ is a context of \textit{push} combinators for the
recursive type variables:
%and $\deriv{pull}{A} = \lambda z. \deriv{pull}{A}^\emptyset z$
%
%\dnote{put very short descriptions like comments on the right hand side?}
\begin{align*}
\deriv{push}{[[ Unit ]]}^\Sigma \ z & = [[ case z of [ () ] -> () ]]
\\
\deriv{push}{\alpha}^\Sigma       \ z & = z
  \\
  \deriv{push}{X}^\Sigma     \ z & = \Sigma(X)\ z
\\
\deriv{push}{A \oplus B}^\Sigma \ z & =
\derCaseTwoShort{z}{[\mathsf{inl}\ x]}{\mathsf{inl}\ \deriv{push}{A}^{\Sigma}[x]}{[\mathsf{inr}\ y]}
                            {\mathsf{inr}\
                                      \deriv{push}{B}^{\Sigma}[y]}
\\
\deriv{push}{A \otimes B}^\Sigma \ z & =
\derCaseOne{z}{[(x, y)]}
   {(\deriv{push}{A}^{\Sigma}[x], \deriv{push}{B}^{\Sigma}[y])}
\\
  \deriv{push}{A \multimap B}^\Sigma \ z & =
                                \lambda y .
                                \derCaseOne{z}{[f]}{\derCaseOne{\deriv{pull}{A}^{\Sigma}\
                                    y}{[u]}{\deriv{push}{B}^{\Sigma}[(f
                                \ u)]}}
\\
%%%%%
\deriv{push}{\mu X . A}^\Sigma \ z & =
 \derLetRec{f}{\deriv{push}{A}^{\Sigma, X \mapsto
f : [[ {mu X . {[] r A}} -o {{(mu X . A)} [ [] r ai /* ai ]} ]] }}{f\ z}
\end{align*}
%
In the case of \emph{push} on a value of type $[[ Unit ]]$, we pattern match on the value, eliminating the graded modality via the unboxing pattern match and returning the unit value. For type variables, \emph{push} is simply the identity of the value, while for recursion variables we lookup the $X$'s binding in $\Sigma$ and apply it to the value. For sum and product types, \emph{push} works by pattern matching on the type's constructor(s) and then inductively applying \emph{push} to the boxed arguments, re-applying them to the constructor(s).
Unlike \emph{pull} below, the \emph{push} operation can be derived for function
types, with a contravariant use of \emph{pull}.
For recursive types, we inductively apply \emph{push} to the value
with a fresh recursion variable bound in $\Sigma$, representing a
recursive application of push.

There is no derivation of a distributive law for types which are themselves graded
modalities (see further work discussion in Section~\ref{sec:conclusion}).

The appendix~\cite{appendix} proves that
$\deriv{push}{A}$ is type sound, i.e., its derivations are well-typed.

\paragraph{Pull}
We automatically
calculate \emph{pull} for $\mathsf{F}$
applied to $n$ type variables
% $\{\alpha_i\}^n_i$
$\overline{\alpha_i}$
as the operation:
\begin{align*}
\deriv{pull}{\tcF\ \overline{\alpha_i}} : \tcF\ (\overline{\Box_{r_i} \alpha_i})
\multimap \Box_{\bigwedge^n_{i = 1} r_i} (\tcF\  \overline{\alpha_i})
 \end{align*}
Type constructor $\tcF$ here is applied to $n$
arguments each of the form $\Box_{r_i} \alpha_i$, i.e., each with a
different grading of which the greatest-lower bound\footnote{The greatest-lower bound $\wedge$ is partial operation which can be defined in terms of the semiring's pre-order: $r \wedge s = t$ if $t \sqsubseteq r$, $t \sqsubseteq s$ and there exists no other $t'$ where $t' \sqsubseteq r$ and $t' \sqsubseteq s$ and $t \sqsubseteq t'$.} $\bigwedge^n_{i =
  1} r_i$ is the resulting grade (see
\granin{pullPair} from Section~\ref{sec:motivating-example}).

For types $A$ closed with respect to recursion variables, let $\deriv{pull}{A} = \lambda z
. \deriv{pull}{A}^\emptyset\ z$ where:% (for recursion variables $\Sigma$):
%and $\deriv{pull}{A} = \lambda z. \deriv{pull}{A}^\emptyset z$
\begin{align*}
  \deriv{pull}{[[ Unit ]]}^\Sigma            \ z & = [[ case z of () -> [ () ] ]]
\\
\deriv{pull}{\alpha}^\Sigma      \ z & = z
                                       \\
\deriv{pull}{X}^\Sigma           \ z & = \Sigma(X)\ z
                                    \\
\deriv{pull}{A \oplus B}^\Sigma  \ z & =\derCaseTwo{z}{\mathsf{inl}\
                                       x}{\derCaseOne{\deriv{pull}{A}^{\Sigma}\ x}{[u]}{[\mathsf{inl}\ u]}}{\mathsf{inr}\ y}
                            {\derCaseOne{\deriv{pull}{B}^{\Sigma}\
                                       y}{[v]}{[\mathsf{inr}\ v]}}
\\
\deriv{pull}{A \otimes B}^\Sigma \ z & =
\derCaseOne{z}{(x, y)}
   {\derCaseOne{(\deriv{pull}{A}^{\Sigma}\ x, \deriv{pull}{B}^{\Sigma}\ y)}
                {([u], [v])}{[(u, v)]}} \\
%%%
\deriv{pull}{\mu X . A}^\Sigma \ z & =
   \derLetRec{f}{\deriv{pull}{A}^{\Sigma, X \mapsto f : [[ {mu X . {A [ [] ri ai /* ai ]}}
                                 -o [] {BigMeet ri} (mu X . A) ]] }}{f\ z}
 \end{align*}
%\paragrapho{Push}
%
%
Just like \emph{push}, we cannot apply \emph{pull} to graded modalities themselves. Unlike
\emph{push}, we cannot apply \emph{pull} to function types. That is, we
cannot derive a distributive law of the form $(\Box_r A \multimap \Box_r B)
\multimap \Box_r (A \multimap B)$ since introducing the concluding $\Box_r$
would require the incoming function $(\Box_r A \multimap \Box_r B)$ to
itself be inside $\Box_r$ due to the promotion rule (\textsc{pr}), which does not
match the type scheme for \emph{pull}.

The rest of the derivation above is
similar but dual to that of \emph{push}.

The appendix~\cite{appendix} proves that
$\deriv{pull}{A}$ is type sound, i.e., its derivations are well-typed.

\begin{example}
  \label{ex:push-fun}
  To illustrate the above procedures, the derivation of
  $\deriv{push}{(\alpha \otimes \alpha) \multimap \beta}$ is:
  %
  \begin{align*}
       & \lambda z . \deriv{push}{(\alpha \otimes \alpha) \multimap \beta}^\emptyset \ z
         : \Box_r ((\alpha \otimes \alpha) \multimap \beta) \multimap
             ((\Box_r \alpha \otimes \Box_r \alpha) \multimap \Box_r \beta)
\\
  = \; & \lambda z . \lambda y . \derCaseOne{z}{[f]}{\derCaseOne{\deriv{pull}{\alpha
      \otimes \alpha}^{\emptyset}\
         y}{[u]}{\deriv{push}{\beta}^{\emptyset}[(f \ u)]}}
    \\
  = \; & \lambda z . \lambda y . \derCaseOne{z}{[f]}{\\ & \hspace{3em} \derCaseOne{(\derCaseOne{y}{(x', y')}
   {\\ & \hspace{6em} \derCaseOne{(\deriv{pull}{\alpha}^{\emptyset}\ x', \deriv{pull}{\alpha}^{\emptyset}\ y')}
                {([u], [v])}{[(u, v)]}})}{[u]}{\deriv{push}{\beta}^{\emptyset}[(f \ u)]}}
%%
    \\
  = \; & \lambda z . \lambda y . \derCaseOne{z}{[f]}{\derCaseOne{(\derCaseOne{y}{(x', y')}
   {\derCaseOne{(x', y')}
                {([u], [v])}{[(u, v)]}})}{[u]}{[(f \ u)]}}
  \end{align*}
  %
\end{example}

\begin{remark}
One might ponder whether linear logic's exponential $!
A$~\cite{girard1987linear} is modelled by the graded necessity modality over
$\mathbb{N}_{\infty}$ intervals, i.e., with $! A \triangleq \Box_{\textcolor{coeffectColor}{[[
  IntervalSyn 0 Inf ]] }} A$. This is a reasonable assumption, but
$\Box_{\textcolor{coeffectColor}{[[ IntervalSyn 0 Inf ]] }} A$ has a slightly different meaning to $! A$,
exposed here: whilst $\deriv{push}{A \otimes B} : \Box_{\textcolor{coeffectColor}{[[
  IntervalSyn 0 Inf ]]}} (A \otimes B) \multimap (\Box_{\textcolor{coeffectColor}{[[ IntervalSyn 0 Inf ]] }} A \otimes \Box_{\textcolor{coeffectColor}{[[ IntervalSyn 0 Inf ]]}} B)$
is derivable in \grminip{}, linear logic does not permit $!(A \otimes B) \multimap
(!A \otimes !B)$. Models of $!$ provide only a monoidal functor
structure which gives \emph{pull} for $\otimes$, but not
\emph{push}~\cite{benton1992linear}. This structure can be recovered in Granule through
the introduction of a partial type-level operation which selectively
disallows \emph{push} for $\otimes$ in semirings which model the $!$
modality of linear logic\footnote{The work in ~\cite{hughes:lirmm-03271465} arose as a result of the writing of this paper.} ~\cite{hughes:lirmm-03271465}.
\end{remark}

The algorithmic definitions of `push' and `pull' can be leveraged
in a programming context to automatically yield these combinators for
practical purposes. We discuss how this is leveraged inside the
Granule compiler in Section~\ref{sec:implementation} and two techniques
for leveraging it for Linear Haskell in Section~\ref{sec:linhaskell}.
Before that, we study the algebraic behaviour of the derived distributive laws.

\subsection{Properties}
\label{subsection:properties}

%We consider here some properties of the distributive laws: that they
%are mutually inverse (under some restriction) and that they behave
%well with respect to structure associated with the graded modalities,
%specifically that they yield distributive laws of endofunctors over
%graded comonads. Proofs are given in Appendix~\ref{app:properties}.

We consider here the properties of these derived operations.  Prima
facie, the above \emph{push} and \emph{pull} operations are simply
distributive laws between two (parametric) type constructors $\tcF$
and $\Box_r$, the latter being the graded modality. However, both
$\tcF$ and $\Box_r$ have additional structure. If the mathematical
terminology of `distributive laws' is warranted, then such additional structure
should be preserved by \emph{push} and \emph{pull} (e.g., as in how
a distributive law between a monad and a comonad must preserve
the behaviour of the monad and comonad operations after applying
the distributive law~\cite{power2002combining}); we explain here the relevant
additional structure and verify the distributive law properties.

Firstly, we note that these distributive laws are mutually inverse:

\begin{restatable}[Pull is right inverse to push]{prop}{pushPullInverse}
  For all $n$-arity types $\tcF$ which do not contain function types,
  then for type variables $(\alpha_i)_{i \in [1..n]}$
  and for all grades $r \in \mathcal{R}$ where $[[1 <<= r]]$ if $|\tcF
    \overline{\alpha_i}| > 1$, then:
    %
  \begin{align*}
\deriv{pull}{\tcF\
  \overline{\alpha_i}}(\deriv{push}{\tcF\
  \overline{\alpha_i}}) = id\ : \Box_{r} \tcF \overline{\alpha_i}
\multimap \Box_{r} \tcF \overline{\alpha_i}
    \end{align*}
\end{restatable}

\begin{restatable}[Pull is left inverse to push]{prop}{pullPushInverse}
  For all $n$-arity types $\tcF$ which do not contain function types,
  then for type variables $(\alpha_i)_{i \in [1..n]}$
  and for all grades $r \in \mathcal{R}$ where $[[1 <<= r]]$ if $|\tcF
    \overline{\alpha_i}| > 1$, then:
  \begin{align*}
\deriv{push}{\tcF\
  \overline{\alpha_i}}(\deriv{pull}{\tcF\
  \overline{\alpha_i}}) = id\ : \tcF (\Box_{r} \overline{\alpha_i})
\multimap \tcF (\Box_{r} \overline{\alpha_i})
    \end{align*}
  \end{restatable}

\noindent
The appendix~\cite{appendix} gives the proofs, leveraging the
equational theory of \grminip{}.

Applying a mathematical perspective, $\Box_r$ is also an endofunctor with
its object mapping provided by the type constructor itself and its
morphism mapping behaviour defined as follows:
%
\begin{definition}[$\Box_r$ functor]
  Given a function $f : \alpha \multimap \beta$ (a closed function
  term) then $\Box_r f : \Box_r \alpha \multimap \Box_r \beta$ is the
  morphism mapping of the endofunctor $\Box_r$ defined:
  %
  \begin{align*}
    \Box_r\ f = \lambda x. [[ case x of [y] -> [f y] ]]
  \end{align*}
  %
\end{definition}
%
\noindent
For types $\tcF \alpha$ we can also automatically derive the
morphism mapping of a covariant functor, which we write as $\deriv{fmap}{\tcF \alpha}$
whose definition is standard (e.g., applied in Haskell~\cite{generic-deriving})  given in
the appendix~\cite{appendix}. Distributive laws between
endofunctors should be natural transformations, which is indeed the case for our
derivations:

\begin{restatable}[Naturality of push]{prop}{pushNatural}
  For all unary type constructors $\tcF$ such that $\deriv{push}{\tcF \alpha}$ is defined, and given a closed function term $f : \alpha \multimap \beta$, then: $ {\deriv{fmap}{\tcF} \Box_{r}f} \circ \deriv{push}{\tcF {\alpha}} = \deriv{push}{\tcF {\beta}} \circ  \Box_{r} \deriv{fmap}{\tcF} f $, i.e.:
\begin{align*}
\xymatrix@C=3.5em{
{\alpha} \ar[d]_{f}
\\
{\beta} &
}
\quad
\xymatrix@C=5em{
{\Box_{r} \tcF {{\alpha}}} \ar[d]_{\Box_{r} \deriv{fmap}{\tcF } f } \ar[r]^{\deriv{push}{\tcF {\alpha}}}  &   {\tcF \Box_{r} {\alpha}}
\ar[d]^{\deriv{fmap}{\tcF } \Box_{r}f}   \\
{\Box_{r} \tcF {{\beta}}}  \ar[r]_{\deriv{push}{\tcF {\beta}}} &  {\tcF \Box_{r} {\beta}}}
\end{align*}
\end{restatable}

\begin{restatable}[Naturality of pull]{prop}{pullNatural}
  For all unary type constructors $\tcF$ such that $\deriv{pull}{\tcF \alpha}$ is defined, and given a closed function term $f : \alpha \multimap \beta$, then: $\Box_{r} \deriv{fmap}{\tcF} f \circ \deriv{pull}{\tcF {\alpha}} = \deriv{pull}{\tcF {\beta}} \circ {\deriv{fmap}{\tcF} \Box_{r}f}$, i.e.:
\begin{align*}
\xymatrix@C=3.5em{
{\alpha} \ar[d]_{f}
\\
{\beta} &
}
\quad
\xymatrix@C=5em{
{\tcF \Box_{r} {\alpha}} \ar[d]_{\deriv{fmap}{\tcF}\Box_{r}f} \ar[r]^{\deriv{pull}{\tcF {\alpha}}}  & {\Box_{r} \tcF {{\alpha}}}
\ar[d]^{ \Box_{r}\deriv{fmap}{\tcF} f}   \\
{ \tcF \Box_{r} {\beta}}  \ar[r]_{\deriv{pull}{\tcF {\beta}}} &  {\Box_{r} \tcF {{\beta}}}}
\end{align*}
\end{restatable}
%
\noindent
The appendix~\cite{appendix} gives the proofs.
Note that the naturality results here are for cases of unary type
constructors $\tcF$ that are covariant functors, written with a single parameter $\alpha$. This can
easily generalise to $n$-ary type constructors.

Not only is $\Box_r$ an endofunctor but it also has the structure
of a \emph{graded comonad}~\cite{combining2016,DBLP:conf/fossacs/Katsumata18,petricek2014coeffects,DBLP:conf/icalp/PetricekOM13}.
%

\begin{definition}[Graded comonadic operations]
The \grminip{} calculus (and Granule) permits the derivation of graded
comonadic
operations~\cite{DBLP:journals/pacmpl/OrchardLE19}
for the semiring graded necessity $\Box_r$, defined:
%
\begin{align*}
\varepsilon_A & : \Box_1 A \multimap A = \lambda x . [[ case x of [z] -> z ]] \\
\delta_{r,s,A} & : \Box_{r \ast{} s} A \multimap \Box_r \Box_s A
= \lambda x . [[ case x of [z] -> [ [z] ] ]]
 \end{align*}
 \end{definition}
%
\noindent
 The derived distributive laws preserve these graded comonadic
 operations i.e., the distributive laws are
 well-behaved with respect to the graded comonadic structure of
 $\Box_r$, captured by the following properties:

\begin{restatable}[Push preserves graded comonads]{prop}{pushPreserve}
%
For all $\tcF$ such that $\deriv{push}{\tcF \overline{\alpha_i}}$ is defined
and $\tcF$ does not contain $\multimap$ (to avoid issues of
contravariance in $\tcF$) then:
%
\begin{align*}
\xymatrix@C=3.5em@R=1.4em{
\Box_{1} \tcF \overline{\alpha_i} \ar[r]^{\deriv{push}{\tcF
  \overline{\alpha_i}}} \ar[d]_{\varepsilon}
& \tcF \overline{\Box_{1} \alpha_i}
\ar[dl]^{\tcF \varepsilon}
\\
\tcF \overline{\alpha_i} &
}
\quad
\xymatrix@C=5em@R=1.4em{
\Box_{r\ast{}s}
\tcF \overline{\alpha_i} \ar[d]_{\delta_{r,s}} \ar[rr]^{\deriv{push}{\tcF \overline{\alpha_i}}}
& & \tcF \overline{\Box_{r\ast{}s} \alpha_i} \ar[d]^{\tcF \delta_{r,s}}
\\
\Box_{r} \Box_{s} \tcF \overline{\alpha_i} \ar[r]_{\Box_r \deriv{push}{\tcF \overline{\alpha_i}}}&
\Box_{r}\tcF \overline{\Box_{s} \alpha_i} \ar[r]_{\deriv{push}{\tcF \overline{\alpha_i}}} &
\tcF \overline{\Box_{r} \Box_{s} \alpha_i}
&
}
\end{align*}
\end{restatable}

\begin{restatable}[Pull preserves graded comonads]{prop}{pullPreserve}
\label{prop:pullPreserve}
%
% TODO: DAO 23/10/2020
% There might be a more general thing we can do here with taking the
% meet of many grades, but it's too complicated for me to think about
% right now!
%
For all $\tcF$ such that $\deriv{pull}{\tcF \overline{\alpha_i}}$ is defined then:
%
\begin{align*}
\xymatrix@C=3.5em@R=1.4em{
\Box_{1} \tcF \overline{\alpha_i} \ar[d]_{\varepsilon}
&  \ar[l]_{\deriv{pull}{\tcF \overline{\alpha_i}}} \tcF
  \overline{\Box_{1} \alpha_i}
\ar[dl]^{\tcF \varepsilon}
\\
\tcF \overline{\alpha_i} &
}
\quad
\xymatrix@C=5em@R=1.4em{
\Box_{r\ast{}s}
\tcF \overline{\alpha_i} \ar[d]_{\delta_{r,s}}
& & \ar[ll]_{\deriv{pull}{\tcF \overline{\alpha_i}}} \tcF
    \overline{\Box_{r\ast{}s} \alpha_i}
\ar[d]^{\tcF \delta_{r,s}}
\\
\Box_{r} \Box_{s} \tcF \overline{\alpha_i} & \ar[l]^{\Box_r \deriv{pull}{\tcF \overline{\alpha_i}}}
\Box_{r}\tcF \overline{\Box_{s} \alpha_i} & \ar[l]^{\deriv{pull}{\tcF \overline{\alpha_i}}}
\tcF \overline{\Box_{r} \Box_{s} \alpha_i}
&
}
\end{align*}
\end{restatable}
%
\noindent
The appendix~\cite{appendix} gives the proofs.